This patch contains all the Debian-specific
changes mixed together. 
--- /dev/null
+++ dttsp-0~svn675/bufvec.h
@@ -0,0 +1,119 @@
+/* bufvec.h
+
+defs for vector and buffer data structures and utilities
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _bufvec_h
+
+#define _bufvec_h
+
+#include <fromsys.h>
+#include <datatypes.h>
+#include <complex.h>
+#include <cxops.h>
+
+typedef struct _complex_buffer_desc {
+  COMPLEX *data;
+  int size, ovlp, want, have, done, mine;
+} CXBuffer, *CXB;
+
+/* all these should be OK rhs or lhs */
+
+#define CXBbase(p) ((p)->data)
+#define CXBdata(p, i) (CXBbase(p)[(i)])
+#define CXBreal(p, i) (CXBbase(p)[(i)].re)
+#define CXBimag(p, i) (CXBbase(p)[(i)].im)
+#define CXBsize(p) ((p)->size)
+#define CXBovlp(p) ((p)->ovlp)
+#define CXBwant(p) ((p)->want)
+#define CXBhave(p) ((p)->have)
+#define CXBdone(p) ((p)->done)
+#define CXBmine(p) ((p)->mine)
+
+typedef struct _real_buffer_desc {
+  REAL *data;
+  int size, ovlp, want, have, done, mine;
+} RLBuffer, *RLB;
+
+#define RLBbase(p) ((p)->data)
+#define RLBdata(p, i) (RLBbase(p)[(i)])
+#define RLBsize(p) ((p)->size)
+#define RLBovlp(p) ((p)->ovlp)
+#define RLBwant(p) ((p)->want)
+#define RLBhave(p) ((p)->have)
+#define RLBdone(p) ((p)->done)
+#define RLBmine(p) ((p)->mine)
+
+extern char *safealloc(int count, int nbytes, char *tag);
+extern void safefree(char *p);
+extern size_t safememcurrcount(void);
+extern void safememreset(void);
+
+extern REAL *newvec_REAL(int size, char *tag);
+extern void delvec_REAL(REAL *vec);
+extern IMAG *newvec_IMAG(int size, char *tag);
+extern void delvec_IMAG(IMAG *vec);
+extern COMPLEX *newvec_COMPLEX(int size, char *tag);
+extern void delvec_COMPLEX(COMPLEX * buf);
+extern COMPLEX *newvec_COMPLEX_fftw(int size, char *tag);
+extern void delvec_COMPLEX_fftw(COMPLEX * buf);
+extern void dump_REAL(FILE *fp, char *head, REAL *ptr, int beg, int fin);
+extern void dump_IMAG(FILE *fp, char *head, IMAG *ptr, int beg, int fin);
+extern void dump_CX(FILE *fp, char *head, COMPLEX *ptr, int beg, int fin);
+
+extern CXB newCXB(int size, COMPLEX *base, char *tag);
+extern void delCXB(CXB p);
+
+extern RLB newRLB(int size, REAL *base, char *tag);
+extern void delRLB(RLB p);
+
+extern REAL normalize_vec_REAL(REAL *, int);
+extern REAL normalize_vec_COMPLEX(COMPLEX *, int);
+
+typedef
+struct _simple_vector {
+  REAL *base;
+  int size;
+  BOOLEAN mine;
+} SimpleVector, *SV;
+
+#define SVbase(p) ((p)->base)
+#define SVsize(p) ((p)->size)
+#define SVdata(p, i) (SVbase(p)[(i)])
+#define SVmine(p) ((p)->mine)
+
+extern SV newSV(int size, REAL *base, char *tag);
+extern void delSV(SV sv);
+extern void SVfill(SV sv, REAL val);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/configure.ac
@@ -0,0 +1,54 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ(2.60)
+AC_INIT(dttsp, new, [ab2kt@arrl.net> or <rwmcgwier@gmail.com])
+#AM_INIT_AUTOMAKE([-Wall -Werror foreign])
+#AM_INIT_AUTOMAKE([-Werror foreign])
+AM_INIT_AUTOMAKE([])
+AC_CONFIG_SRCDIR([am_demod.c])
+#AC_CONFIG_HEADER([config.h])
+
+AC_CANONICAL_HOST
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_RANLIB
+
+dnl XXX we need to cover Intel as well as PowerPC
+if test $host_cpu = "powerpc" && test $host_vendor = "apple"; then
+
+	dnl set specific macosx paths (fink)
+	CFLAGS="$CFLAGS -I/sw/include"
+	LDFLAGS="$LDFLAGS -L/sw/lib"
+	CPPFLAGS="$CPPFLAGS -I/sw/include"
+fi
+
+# Checks for libraries.
+AC_CHECK_LIB([fftw3f], [fftwf_execute], ,
+	[AC_MSG_ERROR("Could not find library fftw3f.")])
+AC_CHECK_LIB([jack], [jack_connect], ,
+	[AC_MSG_ERROR("Could not find library jack.")])
+AC_CHECK_LIB([m], [pow])
+AC_CHECK_LIB([pthread], [pthread_create])
+
+# Checks for header files.
+AC_HEADER_STDC
+AC_HEADER_SYS_WAIT
+AC_CHECK_HEADERS([fcntl.h stdlib.h string.h sys/ioctl.h sys/param.h sys/socket.h sys/time.h unistd.h])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_C_INLINE
+AC_TYPE_SIZE_T
+AC_HEADER_TIME
+AC_HEADER_STDBOOL
+AC_TYPE_UID_T
+
+# Checks for library functions.
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_STAT
+AC_CHECK_FUNCS([floor gettimeofday memset pow sqrt])
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
--- /dev/null
+++ dttsp-0~svn675/graphiceq.h
@@ -0,0 +1,75 @@
+/* graphiceq.h
+ * 
+ *   PCM time-domain equalizer
+ *
+ This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+This is derived from equ.xmms:
+
+ *   Copyright (C) 2002  Felipe Rivera <liebremx at users sourceforge net>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *   $Id: iir.c,v 1.10 2004/05/16 02:24:31 liebremx Exp $ */
+
+#ifndef _graphiceq_h
+#define _graphiceq_h
+
+#include <datatypes.h>
+#include <bufvec.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <fftw3.h>
+
+typedef struct _eq {
+  CXB data;
+  FiltOvSv p;
+  CXB in, out;
+  COMPLEX num[9], den[6];
+  BOOLEAN notchflag;
+} eq, *EQ;
+
+extern void graphiceq(EQ a);
+extern EQ new_EQ(CXB d, REAL samplerate, int pbits);
+
+#endif /* #define GRPHEQ_H */
--- /dev/null
+++ dttsp-0~svn675/noiseblanker.h
@@ -0,0 +1,52 @@
+/* noiseblanker.h
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _noiseblanker_h
+#define _noiseblanker_h
+
+#include <cxops.h>
+#include <bufvec.h>
+
+typedef struct _nbstate {
+  CXB sigbuf;
+  REAL average_mag, threshold;
+  COMPLEX average_sig, delay[8];
+  int delayindex, sigindex, hangtime;
+} nbstate, *NB;
+
+extern NB new_noiseblanker(CXB sigbuf, REAL threshold);
+extern void del_nb(NB nb);
+extern void noiseblanker(NB nb);
+extern void SDROMnoiseblanker(NB nb);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/cxops.h
@@ -0,0 +1,418 @@
+/* cxops.h
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _cxops_h
+
+#define _cxops_h
+
+#include <complex.h>
+#include <datatypes.h>
+#include <fastrig.h>
+#ifdef __SSE3__
+#include <pmmintrin.h>
+#endif
+
+extern COMPLEX cxzero;
+extern COMPLEX cxone;
+extern COMPLEX cxJ;
+extern COMPLEX cxminusone;
+extern COMPLEX cxminusJ;
+
+
+
+// scalar
+
+PRIVATE INLINE
+COMPLEX
+Cmplx(REAL x, IMAG y) {
+  COMPLEX z;
+  z.re = x, z.im = y;
+  return z;
+}
+
+PRIVATE INLINE
+COMPLEX
+Cscl(COMPLEX x, REAL a) {
+  COMPLEX z;
+  c_re(z) = c_re(x) * a;
+  c_im(z) = c_im(x) * a;
+  return z;
+}
+
+PRIVATE INLINE
+COMPLEX
+Cadd(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) + c_re(y);
+  c_im(z) = c_im(x) + c_im(y);
+  return z;
+}
+
+PRIVATE INLINE
+COMPLEX
+Csub(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) - c_re(y);
+  c_im(z) = c_im(x) - c_im(y);
+  return z;
+}
+
+PRIVATE INLINE
+COMPLEX
+Cmul(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) * c_re(y) - c_im(x) * c_im(y);
+  c_im(z) = c_im(x) * c_re(y) + c_re(x) * c_im(y);
+  return z;
+}
+
+
+//PRIVATE INLINE
+//REAL
+//Cappmag(COMPLEX z) {
+//  REAL tmpr = (REAL) fabs(z.re),
+//       tmpi = (REAL) fabs(z.im);
+//  if (tmpr < tmpi) return 0.4f * tmpr + 0.7f * tmpi;
+//  else             return 0.4f * tmpi + 0.7f * tmpr;
+//}
+
+PRIVATE INLINE
+REAL
+Cmag(COMPLEX z) {
+  return (REAL) hypot(z.re, z.im);
+}
+
+PRIVATE INLINE
+REAL
+Cabs(COMPLEX z) {
+  return (REAL) hypot(z.re, z.im);
+}
+
+PRIVATE INLINE
+REAL
+Csqrmag(COMPLEX z) {
+  return (REAL) (sqr(z.re) + sqr(z.im));
+}
+
+PRIVATE INLINE
+COMPLEX
+Conjg(COMPLEX z) {
+  return Cmplx(z.re, -z.im);
+}
+
+PRIVATE INLINE
+COMPLEX
+Cexp(COMPLEX z) {
+  REAL r = (REAL) exp(z.re);
+  return Cmplx((REAL) (r * cos(z.im)), (IMAG) (r * sin(z.im)));
+}
+
+PRIVATE INLINE
+COMPLEX
+Cp2r(COMPLEX z) {
+  return Cmplx((REAL) (z.re * cos(z.im)), (IMAG) (z.re * sin(z.im)));
+}
+
+PRIVATE INLINE
+COMPLEX
+Cr2p(COMPLEX z) {
+  return Cmplx((REAL) hypot(z.re, z.im),
+	       (REAL) ATAN2(z.im, z.re));
+}
+
+
+
+PRIVATE INLINE
+COMPLEX
+Cdiv(COMPLEX x, COMPLEX y) {
+  REAL d = sqr(c_re(y)) + sqr(c_im(y));
+  COMPLEX z;
+  c_re(z) = (c_re(x) * c_re(y) + c_im(x) * c_im(y)) / d;
+  c_im(z) = (c_re(y) * c_im(x) - c_im(y) * c_re(x)) / d;
+  return z;
+}
+
+
+
+#define alphaC 0.948059448969
+#define betaC 0.392699081699
+
+PRIVATE INLINE
+REAL
+Cappmag(COMPLEX z) {
+  REAL tmpr = fabs(z.re), tmpi = fabs(z.im);
+  if (tmpr > tmpi) return alphaC * tmpr + betaC * tmpi;
+  else             return alphaC * tmpi + betaC * tmpr;
+}
+
+
+// end of scalar section
+
+#ifdef __SSE3__
+
+// vector complex arithmetic accelerated by SSE3
+
+PRIVATE INLINE
+void
+sse3ComplexMult(COMPLEX *c, COMPLEX *a, COMPLEX *b)
+{
+  __m128 x, y, yl, yh, z, tmp1, tmp2;
+
+  x = _mm_load_ps((float *)a);  // Load as (r,i)
+  y = _mm_load_ps((float *)b);  // Load as (r,i)
+
+  yl = _mm_moveldup_ps(y);  // Load yl with cr, cr, dr, dr
+  yh = _mm_movehdup_ps(y);  // Load yh with ci, ci, di ,di
+
+  tmp1 = _mm_mul_ps(x,yl);  // tmp1 = ar*cr, ai*cr, br*dr, bi*dr
+
+  x = _mm_shuffle_ps(x, x, 0xB1); // Re-arrange x tp be ai,ar,bi,br
+
+  tmp2 = _mm_mul_ps(x,yh);  // tmp2 = ai*ci, ar*ci, bi*di, br*di
+
+  z = _mm_addsub_ps(tmp1,tmp2); // ar*cr-ai*ci, ai*cr+ar*ci, br*dr-bi*di, bi*dr+br*di
+
+  _mm_store_ps((float *)c,z); // Store the results in the target Complex container
+}
+
+PRIVATE INLINE
+void
+CmulSSE3(COMPLEX *c, COMPLEX *a, COMPLEX *b, int len)
+{
+  COMPLEX *aPtr;
+  COMPLEX *bPtr;
+  COMPLEX *cPtr;
+  int i;
+
+  aPtr = a;
+  bPtr = b;
+  cPtr = c;
+
+  for(i=0;i<len;i+=2) {
+    // Do 2 Complex Multiplies per loop
+    sse3ComplexMult(cPtr, aPtr, bPtr);
+    cPtr += 2;
+    aPtr += 2;
+    bPtr += 2;
+  }
+
+  if (len%2) //take care of the odd dangler
+      *cPtr = Cmul(*aPtr,*bPtr);
+}
+
+
+
+// The following routines are adapted from code done by  Phil Covington, N8VB
+// p.covington@gmail.com
+// N8VB
+
+PRIVATE INLINE
+void 
+DoSSEScaleCOMPLEX(COMPLEX * c, COMPLEX * a, float b) {
+    __m128 x, y, z;
+           
+    x = _mm_load_ps((float *)a);
+    y = _mm_load_ps1(&b);
+           
+    z = _mm_mul_ps(x, y); 
+    
+    _mm_store_ps((float *)c, z);    
+}
+
+PRIVATE INLINE
+void 
+SSEScaleCOMPLEX(COMPLEX * c, COMPLEX * a, float b, int size) {
+    COMPLEX * aa;
+    float sb;
+    COMPLEX * cc;
+    int i;
+
+    aa = a;
+    sb = b;
+    cc = c;
+
+    for (i = 0; i < size; i+=2) {
+        DoSSEScaleCOMPLEX(cc, aa, sb);
+        cc += 2;
+        aa += 2;        
+    }
+    if (size%2)
+        *cc = Cscl(*aa, sb); 
+}
+
+
+PRIVATE INLINE void DoSSEAddCOMPLEX(COMPLEX * c, COMPLEX * a, COMPLEX * b) {
+    __m128 x, y, z;
+           
+    x = _mm_load_ps((float *)a);
+    y = _mm_load_ps((float *)b);
+           
+    z = _mm_add_ps(x, y); 
+    
+    _mm_store_ps((float *)c, z);    
+}
+
+PRIVATE INLINE 
+void 
+SSEAddCOMPLEX(COMPLEX * c, COMPLEX * a, COMPLEX * b, int size) {
+    COMPLEX * aa;
+    COMPLEX * bb;
+    COMPLEX * cc;
+    int i;
+
+    aa = a;
+    bb = b;
+    cc = c;
+    
+    for (i = 0; i < size; i+=2) {
+        DoSSEAddCOMPLEX(cc, aa, bb);
+        cc += 2;
+        aa += 2;
+        bb += 2;
+    }
+    if (size%2)
+        *cc = Cadd(*aa, *bb);
+}
+
+
+PRIVATE INLINE
+void 
+DoSSEMultCOMPLEX(COMPLEX * c, COMPLEX * a, COMPLEX * b) {
+    
+    __m128 x, y, yl, yh, t1, t2, z;
+           
+    x = _mm_load_ps((float *)a);
+    y = _mm_load_ps((float *)b);
+    
+    yl = _mm_moveldup_ps(y);
+    yh = _mm_movehdup_ps(y);
+    
+    t1 = _mm_mul_ps(x, yl);
+    
+    x = _mm_shuffle_ps(x, x, _MM_SHUFFLE(2,3,0,1));
+    
+    t2 = _mm_mul_ps(x, yh);
+    
+    z = _mm_addsub_ps(t1, t2);
+    
+    _mm_store_ps((float *)c, z);    
+}
+
+PRIVATE INLINE
+void
+SSEMultCOMPLEX(COMPLEX * c, COMPLEX * a, COMPLEX * b, int size) {
+
+    COMPLEX * aa;
+    COMPLEX * bb;
+    COMPLEX * cc;
+    int i;
+    
+    aa = a;
+    bb = b;
+    cc = c;
+    
+    for (i = 0; i < size; i+=2) {
+        DoSSEMultCOMPLEX(cc, aa, bb);
+        cc += 2;
+        aa += 2;
+        bb += 2;
+    }
+    if (size%2)
+        *cc = Cmul(*aa, *bb);
+}
+
+PRIVATE INLINE
+void
+DoSSEMagCOMPLEX(COMPLEX * c, COMPLEX * a) {
+    __m128 x, y, t1, z;
+           
+    x = _mm_load_ps((float *)a);
+    y = _mm_load_ps((float *)a);
+            
+    t1 = _mm_mul_ps(x, y);
+    
+    t1 = _mm_hadd_ps(t1, t1);
+    
+    t1 = _mm_shuffle_ps(t1, t1, _MM_SHUFFLE(3,1,2,0));
+    
+    z = _mm_sqrt_ps(t1);
+    
+    _mm_store_ps((float *)c, z);    
+}
+
+PRIVATE INLINE
+void
+SSEMagCOMPLEX(COMPLEX * c, COMPLEX * a, int size) {
+    COMPLEX * aa;
+    COMPLEX * cc;
+    int i;
+    
+    aa = a;
+    cc = c;
+    
+    for (i = 0; i < size; i+=2) {
+        DoSSEMagCOMPLEX(cc, aa);
+        cc += 2;
+        aa += 2;        
+    }
+    if (size%2) {
+        cc->re = Cmag(*aa);
+        cc->im = cc->re;
+    }
+}
+
+
+// End p.c. contribution.
+
+#endif  // end of SSE3 section
+  
+
+
+#if 0
+extern INLINE COMPLEX Cscl(COMPLEX, REAL);
+extern INLINE COMPLEX Cadd(COMPLEX, COMPLEX);
+extern INLINE COMPLEX Csub(COMPLEX, COMPLEX);
+extern INLINE COMPLEX Cmul(COMPLEX, COMPLEX);
+extern INLINE COMPLEX Cdiv(COMPLEX, COMPLEX);
+extern INLINE REAL Cmag(COMPLEX);
+extern INLINE REAL Cappmag(COMPLEX);
+extern INLINE REAL Cabs(COMPLEX);
+extern INLINE REAL Csqrmag(COMPLEX);
+extern INLINE COMPLEX Cmplx(REAL, IMAG);
+extern INLINE COMPLEX Conjg(COMPLEX);
+extern INLINE COMPLEX Cexp(COMPLEX);
+
+extern INLINE COMPLEX Cp2r(COMPLEX);
+extern INLINE COMPLEX Cr2p(COMPLEX);
+#endif
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/spectrum.c
@@ -0,0 +1,204 @@
+/** 
+* @file spectrum.c
+* @brief Functions to take a snapshot of the spectrum 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <spectrum.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to take a stapshot of the spectrum 
+* 
+* snapshot of current signal
+*
+* @param sb 
+* @param label 
+* @param stamp 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+snap_spectrum(SpecBlock *sb, int label, int stamp) {
+  int i, j;
+
+  // where most recent signal started
+  j = sb->fill;
+
+  // copy starting from there in circular fashion,
+  // applying window as we go
+  if (!sb->polyphase) {
+    for (i = 0; i < sb->size; i++) {
+      CXBdata(sb->timebuf, i) = Cscl(CXBdata(sb->accum, j), sb->window[i]);
+      j = (++j & sb->mask);
+    }
+  } else {
+    int k;
+    for (i = 0; i < sb->size; i++) {
+      CXBreal(sb->timebuf, i) = CXBreal(sb->accum, j) * sb->window[i];
+      CXBimag(sb->timebuf, i) = CXBimag(sb->accum, j) * sb->window[i];
+      for (k = 1; k < 8; k++) {
+	int accumidx = (j + k * sb->size) & sb->mask,
+	    winidx = i + k * sb->size;
+	CXBreal(sb->timebuf, i) +=
+	  CXBreal(sb->accum, accumidx) * sb->window[winidx];
+	CXBimag(sb->timebuf, i) +=
+	  CXBimag(sb->accum, accumidx) * sb->window[winidx];
+      }
+      j = ++j & sb->mask;
+    }
+
+  }
+  sb->label = label;
+  sb->stamp = stamp;
+  sb->last = SPEC_LAST_FREQ;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief cwFunction to take a snapshot of the osillascope 
+* 
+* @param sb 
+* @param label 
+* @param stamp 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+snap_scope(SpecBlock *sb, int label, int stamp) {
+  int i, j;
+
+  // where most recent signal started
+  j = sb->fill;
+
+  // copy starting from there in circular fashion
+  for (i = 0; i < sb->size; i++) {
+    sb->oscope[i] = CXBreal(sb->accum, j);
+    j = (++j & sb->mask);
+  }
+
+  sb->label = label;
+  sb->stamp = stamp;
+  sb->last = SPEC_LAST_TIME;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Compute the spectrum block 
+* 
+* snapshot -> frequency domain
+*
+* @param sb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+compute_spectrum(SpecBlock *sb) {
+  int i, j, half = sb->size / 2;
+
+  // assume timebuf has windowed current snapshot
+
+  fftwf_execute(sb->plan);
+
+  if (sb->scale == SPEC_MAG) {
+    for (i = 0, j = half; i < half; i++, j++) {
+      sb->output[i] = Cmag(CXBdata(sb->freqbuf, j));
+      sb->output[j] = Cmag(CXBdata(sb->freqbuf, i));
+    }
+  } else {			// SPEC_PWR
+    for (i = 0, j = half; i < half; i++, j++) {
+      sb->output[i] = Log10P(Csqrmag(CXBdata(sb->freqbuf, j)));
+      sb->output[j] = Log10P(Csqrmag(CXBdata(sb->freqbuf, i)));
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Initialize the spectrum block 
+* 
+* @param sb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+init_spectrum(SpecBlock *sb) {
+  sb->fill = 0;
+  sb->accum = newCXB(sb->size * 16, 0, "spectrum accum");
+  sb->timebuf = newCXB(sb->size, 0, "spectrum timebuf");
+  sb->freqbuf = newCXB(sb->size, 0, "spectrum freqbuf");
+  sb->oscope = newvec_REAL(sb->size, "scope vec");
+  sb->window = newvec_REAL(sb->size * 16, "spectrum window");
+  makewindow(BLACKMANHARRIS_WINDOW, sb->size, sb->window);
+  sb->mask = sb->size - 1;
+  sb->polyphase = FALSE;
+  sb->output = (float *) safealloc(sb->size, sizeof(float), "spectrum output");
+  sb->plan = fftwf_plan_dft_1d(sb->size,
+			       (fftwf_complex *) CXBbase(sb->timebuf),
+			       (fftwf_complex *) CXBbase(sb->freqbuf),
+			       FFTW_FORWARD, sb->planbits);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reinitiate the spectrum block 
+* 
+* @param sb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reinit_spectrum(SpecBlock *sb) {
+  size_t polysize = 1;
+  sb->fill = 0;
+  if (sb->polyphase)
+    polysize = 8;
+  memset((char *) CXBbase(sb->accum), 0, polysize * sb->size * sizeof(REAL));
+  memset((char *) sb->output, 0, sb->size * sizeof(float));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Finish and cleanup the spectrum block 
+* 
+* @param sb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+finish_spectrum(SpecBlock *sb) {
+  if (sb) {
+    delCXB(sb->accum);
+    delCXB(sb->timebuf);
+    delCXB(sb->freqbuf);
+    delvec_REAL(sb->oscope);
+    delvec_REAL(sb->window);
+    safefree((char *) sb->output);
+    fftwf_destroy_plan(sb->plan);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/fm_demod.h
@@ -0,0 +1,81 @@
+/* fm_demod.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _fm_demod_h
+#define _fm_demod_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <fastrig.h>
+#include <update.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <oscillator.h>
+
+typedef struct _fm_demod {
+  int size;
+  CXB ibuf, obuf;
+  struct {
+    REAL alpha, beta;
+    struct { REAL f, l, h; } freq;
+    REAL phs;
+    struct { REAL alpha; } iir;
+    COMPLEX delay;
+  } pll;
+
+  REAL lock, afc, cvt;
+} FMDDesc, *FMD;
+
+extern void FMDemod(FMD fm);
+extern FMD newFMD(REAL samprate,
+		  REAL f_initial,
+		  REAL f_lobound,
+		  REAL f_hibound,
+		  REAL f_bandwid,
+		  int size,
+		  COMPLEX *ivec,
+		  COMPLEX *ovec,
+		  char *tag);
+extern void delFMD(FMD fm);
+
+#ifndef TWOPI
+#define TWOPI (2.0*M_PI)
+#endif
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/meter.c
@@ -0,0 +1,76 @@
+/** 
+* @file meter.c
+* @brief Functions to implement a meter
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <meter.h>
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Snapshot of Receive meter 
+* 
+* snapshots of current measurements
+*
+* @param mb 
+* @param label 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+snap_meter_rx(METERBlock *mb, int label) {
+  memcpy ((char *) mb->snap.rx,
+	  (char *) mb->rx.val,
+	  MAXRX * RXMETERPTS * sizeof (REAL));
+  mb->label = label;
+  mb->last = METER_LAST_RX;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Snapshot of the Transmit meter 
+* 
+* @param mb 
+* @param label 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+snap_meter_tx(METERBlock *mb, int label) {
+  memcpy ((char *) &mb->snap.tx,
+	  (char *) &mb->tx.val,
+	  TXMETERPTS * sizeof (REAL));
+  mb->label = label;
+  mb->last = METER_LAST_TX;
+}
--- /dev/null
+++ dttsp-0~svn675/filter.c
@@ -0,0 +1,689 @@
+/** 
+* @file filter.c
+* @brief Functions to implement filters 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <filter.h>
+
+//static REAL onepi = 3.141592653589793;
+#ifndef onepi
+#define onepi M_PI
+#endif
+#ifndef twopi
+#define twopi (2*onepi)
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new FIR REAL
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_REAL(int size, char *tag) {
+  RealFIR p = (RealFIRDesc *) safealloc(1, sizeof(RealFIRDesc), tag);
+  FIRcoef(p) = (REAL *) safealloc(size, sizeof(REAL), tag);
+  FIRsize(p) = size;
+  FIRtype(p) = FIR_Undef;
+  FIRiscomplex(p) = FALSE;
+  FIRfqlo(p) = FIRfqhi(p) = -1.0;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new FIR COMPLEX 
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_COMPLEX(int size, char *tag) {
+  ComplexFIR p = (ComplexFIRDesc *) safealloc(1, sizeof(ComplexFIRDesc), tag);
+  FIRcoef(p) = (COMPLEX *) safealloc(size, sizeof(COMPLEX), tag);
+  FIRsize(p) = size;
+  FIRtype(p) = FIR_Undef;
+  FIRiscomplex(p) = TRUE;
+  FIRfqlo(p) = FIRfqhi(p) = -1.0;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete FIR REAL 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delFIR_REAL(RealFIR p) {
+  if (p) {
+    delvec_REAL(FIRcoef(p));
+    safefree((void *) p);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete FIR COMPLEX 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delFIR_COMPLEX(ComplexFIR p) {
+  if (p) {
+    delvec_COMPLEX(FIRcoef(p));
+    safefree((void *) p);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Lowpass REAL FIR
+* 
+* @param cutoff 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_Lowpass_REAL(REAL cutoff, REAL sr, int size) {
+  if ((cutoff < 0.0) || (cutoff > (sr / 2.0)))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    RealFIR p;
+    REAL *h, *w, fc = cutoff / sr;
+    REAL corrector = 0.0;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_REAL(size, "newFIR_Lowpass_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Lowpass_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1] = 2.0f * fc;
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Lowpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Lowpass COMPLEX FIR 
+* 
+* @param cutoff 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_Lowpass_COMPLEX(REAL cutoff, REAL sr, int size) {
+  if ((cutoff < 0.0) || (cutoff > (sr / 2.0)))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    ComplexFIR p;
+    COMPLEX *h;
+    REAL *w, fc = cutoff / sr;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_COMPLEX(size, "newFIR_Lowpass_COMPLEX");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Lowpass_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j].re =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1].re = 2.0f * fc;
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Lowpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Bandpass REAL FIR 
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_Bandpass_REAL(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < 0.0) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    RealFIR p;
+    REAL *h, *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_REAL(size, "newFIR_Bandpass_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Bandpass_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (hi - lo) / 2.0f;
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1] = 2.0f * fc;
+      h[j] *= (REAL) (2.0 * cos(ff * (i - midpoint)));
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Bandpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Bandpass COMPLEX FIR
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_Bandpass_COMPLEX(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < -(sr / 2.0)) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    ComplexFIR p;
+    COMPLEX *h;
+    REAL *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_COMPLEX(size, "newFIR_Bandpass_COMPLEX");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Bandpass_COMPLEX window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (REAL) ((hi - lo) / 2.0);
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1, k = i - midpoint;
+      REAL tmp, phs = ff * k;
+      if (i != midpoint)
+	tmp = (REAL) ((sin(twopi * k * fc) / (onepi * k)) * w[j]);
+      else
+	tmp = (REAL) (2.0 * fc);
+      tmp *= 2.0;
+      h[j].re = (REAL) (tmp * cos(phs));
+      h[j].im = (IMAG) (tmp * sin(phs));
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Bandpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Highpass REAL FIR
+* 
+* @param cutoff 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_Highpass_REAL(REAL cutoff, REAL sr, int size) {
+  if ((cutoff < 0.0) || (cutoff > (sr / 2.0)))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    RealFIR p;
+    REAL *h, *w, fc = cutoff / sr;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_REAL(size, "newFIR_Highpass_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Highpass_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1] = (REAL) (2.0 * fc);
+    }
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] = -h[j];
+      else
+	h[midpoint - 1] = 1.0f - h[midpoint - 1];
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Highpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Highpass COMPLEX FIR 
+* 
+* @param cutoff 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_Highpass_COMPLEX(REAL cutoff, REAL sr, int size) {
+  if ((cutoff < 0.0) || (cutoff > (sr / 2.0)))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    ComplexFIR p;
+    COMPLEX *h;
+    REAL *w, fc = cutoff / sr;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_COMPLEX(size, "newFIR_Highpass_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Highpass_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j].re =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1].re = (REAL) (2.0 * fc);
+    }
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j].re = -h[j].re;
+      else
+	h[midpoint - 1].re = (REAL) (1.0 - h[midpoint - 1].re);
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Highpass;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Hilbert REAL FIR 
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_Hilbert_REAL(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < 0.0) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    RealFIR p;
+    REAL *h, *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_REAL(size, "newFIR_Hilbert_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Hilbert_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (REAL) ((hi - lo) / 2.0);
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1] = (REAL) (2.0 * fc);
+      h[j] *= (REAL) (2.0 * sin(ff * (i - midpoint)));
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Hilbert;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Hilbert COMPLEX FIR 
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_Hilbert_COMPLEX(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < 0.0) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    ComplexFIR p;
+    COMPLEX *h;
+    REAL *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_COMPLEX(size, "newFIR_Hilbert_COMPLEX");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Hilbert_COMPLEX window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (REAL) ((hi - lo) / 2.0);
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      REAL tmp, phs = ff * (i - midpoint);
+      if (i != midpoint)
+	tmp =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	tmp = (REAL) (2.0 * fc);
+      tmp *= 2.0f;
+      /* h[j].re *= tmp * cos(phs); */
+      h[j].im *= (REAL) (tmp * sin(phs));
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Hilbert;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Bandstop REAL FIR 
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+RealFIR
+newFIR_Bandstop_REAL(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < 0.0) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    RealFIR p;
+    REAL *h, *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_REAL(size, "newFIR_Bandstop_REAL");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Bandstop_REAL window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (REAL) ((hi - lo) / 2.0);
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	h[midpoint - 1] = (REAL) (2.0 * fc);
+      h[j] *= (REAL) (2.0 * cos(ff * (i - midpoint)));
+    }
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] = -h[j];
+      else
+	h[midpoint - 1] = (REAL) (1.0 - h[midpoint - 1]);
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Bandstop;
+    return p;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Bandstop COMPLEX FIR 
+* 
+* @param lo 
+* @param hi 
+* @param sr 
+* @param size 
+*/
+/* ---------------------------------------------------------------------------- */
+ComplexFIR
+newFIR_Bandstop_COMPLEX(REAL lo, REAL hi, REAL sr, int size) {
+  if ((lo < 0.0) || (hi > (sr / 2.0)) || (hi <= lo))
+    return 0;
+  else if (size < 1)
+    return 0;
+  else {
+    ComplexFIR p;
+    COMPLEX *h;
+    REAL *w, fc, ff;
+    int i, midpoint;
+
+    if (!(size & 01))
+      size++;
+    midpoint = (size >> 01) | 01;
+    p = newFIR_COMPLEX(size, "newFIR_Bandstop_COMPLEX");
+    h = FIRcoef(p);
+    w = newvec_REAL(size, "newFIR_Bandstop_COMPLEX window");
+    (void) makewindow(BLACKMANHARRIS_WINDOW, size, w);
+
+    lo /= sr, hi /= sr;
+    fc = (REAL) ((hi - lo) / 2.0);
+    ff = (REAL) ((lo + hi) * onepi);
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      REAL tmp, phs = ff * (i - midpoint);
+      if (i != midpoint)
+	tmp =
+	  (REAL) ((sin(twopi * (i - midpoint) * fc) /
+		   (onepi * (i - midpoint))) * w[j]);
+      else
+	tmp = (REAL) (2.0 * fc);
+      tmp *= 2.0;
+      h[j].re = (REAL) (tmp * cos(phs));
+      h[j].im = (REAL) (tmp * sin(phs));
+    }
+
+    for (i = 1; i <= size; i++) {
+      int j = i - 1;
+      if (i != midpoint)
+	h[j] = Cmul(h[j], cxminusone);
+      else
+	h[midpoint - 1] = Csub(cxone, h[midpoint - 1]);
+    }
+
+    delvec_REAL(w);
+    FIRtype(p) = FIR_Bandstop;
+    return p;
+  }
+}
+
+#ifdef notdef
+int
+/* -------------------------------------------------------------------------- */
+/** @brief main
+* 
+* @param argc 
+* @param *argv 
+*/
+/* ---------------------------------------------------------------------------- */
+main(int argc, char **argv) {
+  int i, size = 101;
+  RealFIR filt;
+#ifdef notdef
+  filt = newFIR_Lowpass_REAL(1000.0, 48000.0, size);
+  for (i = 0; i < FIRsize(filt); i++)
+    printf("%d %f\n", i, FIRtap(filt, i));
+  delFIR_REAL(filt);
+#endif
+
+#ifdef notdef
+  filt = newFIR_Bandstop_REAL(1000.0, 2000.0, 48000.0, size);
+  for (i = 0; i < FIRsize(filt); i++)
+    printf("%d %f\n", i, FIRtap(filt, i));
+  delFIR_REAL(filt);
+#endif
+
+  filt = newFIR_Bandpass_REAL(1000.0, 2000.0, 48000.0, size);
+  for (i = 0; i < FIRsize(filt); i++)
+    printf("%d %f\n", i, FIRtap(filt, i));
+  delFIR_REAL(filt);
+
+#ifdef notdef
+  filt = newFIR_Highpass_REAL(1000.0, 48000.0, size);
+  for (i = 0; i < FIRsize(filt); i++)
+    printf("%d %f\n", i, FIRtap(filt, i));
+  delFIR_REAL(filt);
+#endif
+
+#ifdef notdef
+  filt = newFIR_Hilbert_REAL(1000.0, 2000.0, 48000.0, size);
+  for (i = 0; i < FIRsize(filt); i++)
+    printf("%d %f\n", i, FIRtap(filt, i));
+  delFIR_REAL(filt);
+#endif
+
+#ifdef notdef
+  {
+    COMPLEX *z;
+    REAL *ttbl;
+    int fftlen;
+    fftlen = nblock2(size) * 2;
+    z = newvec_COMPLEX(fftlen, "z");
+    ttbl = newvec_REAL(fftlen, "ttbl");
+    cfftm(FFT_INIT, fftlen, (float *) z, (float *) z, ttbl);
+    for (i = 0; i < FIRsize(filt); i++)
+      z[i].re = FIRtap(filt, i);
+    cfftm(FFT_FORWARD, fftlen, (float *) z, (float *) z, ttbl);
+    for (i = 0; i < size; i++) {
+      printf("%d %f\n", i, Cabs(z[i]));
+      delvec_COMPLEX(z);
+      delvec_REAL(ttbl);
+    }
+  }
+#endif
+  exit(0);
+}
+#endif
--- /dev/null
+++ dttsp-0~svn675/complex.h
@@ -0,0 +1,46 @@
+/* complex.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _complex_h
+#define _complex_h
+
+#include <datatypes.h>
+
+typedef struct _COMPLEX {
+  REAL re, im;
+} COMPLEX;
+
+#define c_re(x) ((x).re)
+#define c_im(x) ((x).im)
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/meter.h
@@ -0,0 +1,125 @@
+/* meter.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _meter_h
+#define _meter_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <ringb.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <oscillator.h>
+#include <dttspagc.h>
+#include <am_demod.h>
+#include <fm_demod.h>
+#include <noiseblanker.h>
+#include <correctIQ.h>
+#include <speechproc.h>
+#include <spottone.h>
+#include <update.h>
+
+typedef enum {
+  SIGNAL_STRENGTH,
+  AVG_SIGNAL_STRENGTH,
+  ADC_REAL,
+  ADC_IMAG,
+  AGC_GAIN,
+  MIC,
+  PWR,
+  EQtap,
+  LEVELER,
+  COMP,
+  CPDR,
+  LVL_G
+} METERTYPE;
+
+#define RXMETERPTS (5)
+#define RXMETER_PRE_CONV (0)
+#define RXMETER_POST_FILT (1)
+#define RXMETER_POST_AGC (2)
+
+//#define TXMETERPTS (9)
+#define TXMETERPTS (10)
+
+typedef enum {
+  RX_SIGNAL_STRENGTH,
+  RX_AVG_SIGNAL_STRENGTH,
+  RX_ADC_REAL,
+  RX_ADC_IMAG,
+  RX_AGC_GAIN
+} RXMETERTYPE;
+
+typedef enum {
+  TX_MIC,
+  TX_PWR,
+  TX_EQtap,
+  TX_LEVELER,
+  TX_COMP,
+  TX_CPDR,
+
+  TX_WAVS,
+  
+  TX_LVL_G
+} TXMETERTYPE;
+
+typedef struct _meter_block {
+  BOOLEAN flag;
+  int label, last;
+  struct {
+    REAL val[MAXRX][RXMETERPTS];
+    RXMETERTYPE mode[MAXRX];
+  } rx;
+  struct {
+    REAL val[TXMETERPTS];
+    TXMETERTYPE mode;
+  } tx;
+  struct {
+    REAL rx[MAXRX][RXMETERPTS], tx[TXMETERPTS];
+  } snap;
+} METERBlock;
+
+#define METER_LAST_RX (0)
+#define METER_LAST_TX (1)
+
+extern void snap_meter_rx(METERBlock *, int);
+extern void snap_meter_tx(METERBlock *, int);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/wscompand.h
@@ -0,0 +1,61 @@
+/*
+* wscompand.h
+*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _wscompand_h
+#define _wscompand_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+typedef struct _wscompander {
+  int npts, nend;
+  REAL fac, *tbl;
+  CXB buff;
+} WSCompanderInfo, *WSCompander;
+
+extern void WSCompand(WSCompander wsc);
+
+// fac < 0: compression
+// fac > 0: expansion
+
+extern void WSCReset(WSCompander wsc, REAL fac);
+extern WSCompander newWSCompander(int npts, REAL fac, CXB buff);
+extern void delWSCompander(WSCompander wsc);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/window.c
@@ -0,0 +1,196 @@
+/** 
+* @file window.c
+* @brief Functions to allow windowing on the signal 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006,2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Implemented from code by Bill Schottstaedt of Snd Editor at CCRMA
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 7 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <window.h>
+
+/** shamelessly stolen from Bill Schottstaedt's clm.c 
+* made worse in the process, but enough for our purposes here 
+*/
+
+//static REAL
+//sqr(REAL x) { return (x * x); }
+
+/** mostly taken from
+ *    Fredric J. Harris, "On the Use of Windows for Harmonic Analysis with the
+ *    Discrete Fourier Transform," Proceedings of the IEEE, Vol. 66, No. 1,
+ *    January 1978.
+ *    Albert H. Nuttall, "Some Windows with Very Good Sidelobe Behaviour", 
+ *    IEEE Transactions of Acoustics, Speech, and Signal Processing, Vol. ASSP-29,
+ *    No. 1, February 1981, pp 84-91
+ *
+ * JOS had slightly different numbers for the Blackman-Harris windows.
+ */
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to make the window 
+* 
+* @param type -- uses Windowtypes 
+* @param size -- size of window 
+* @param window -- data 
+* @return *REAL  
+*/
+/* ---------------------------------------------------------------------------- */
+REAL *
+makewindow(Windowtype type, int size, REAL *window) {
+  int i, j, midn, midp1, midm1;
+  REAL freq, rate, sr1, angle, expn, expsum, cx, two_pi;
+
+  midn = size >> 1;
+  midp1 = (size + 1) / 2;
+  midm1 = (size - 1) / 2;
+  two_pi = (REAL) (8.0 * atan(1.0));
+  freq = two_pi / (REAL) size;
+  rate = (REAL) (1.0 / (REAL) midn);
+  angle = 0.0;
+  expn = (REAL) (log(2.0) / (REAL) midn + 1.0);
+  expsum = 1.0;
+
+  switch (type) {
+  case RECTANGULAR_WINDOW:
+    for (i = 0; i < size; i++)
+      window[i] = 1.0;
+    break;
+  case HANNING_WINDOW:		/* Hann would be more accurate */
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += freq)
+      window[j] = (window[i] = (REAL) (0.5 - 0.5 * cos(angle)));
+    break;
+  case WELCH_WINDOW:
+    for (i = 0, j = size - 1; i <= midn; i++, j--)
+      window[j] =
+	(window[i] = (REAL) (1.0 - sqr((REAL) (i - midm1) / (REAL) midp1)));
+    break;
+  case PARZEN_WINDOW:
+    for (i = 0, j = size - 1; i <= midn; i++, j--)
+      window[j] =
+	(window[i] = (REAL) (1.0 - fabs((REAL) (i - midm1) / (REAL) midp1)));
+    break;
+  case BARTLETT_WINDOW:
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += rate)
+      window[j] = (window[i] = angle);
+    break;
+  case HAMMING_WINDOW:
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += freq)
+      window[j] = (window[i] = (REAL) (0.54 - 0.46 * cos(angle)));
+    break;
+  case BLACKMAN2_WINDOW:	/* using Chebyshev polynomial equivalents here */
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += freq) {
+      cx = (REAL) cos(angle);
+      window[j] = (window[i] =
+		   (REAL) (.34401 + (cx * (-.49755 + (cx * .15844)))));
+    }
+    break;
+  case BLACKMAN3_WINDOW:
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += freq) {
+      cx = (REAL) cos(angle);
+      window[j] =
+	(window[i] =
+	 (REAL) (.21747 +
+		 (cx * (-.45325 + (cx * (.28256 - (cx * .04672)))))));
+    }
+    break;
+  case BLACKMAN4_WINDOW:
+    for (i = 0, j = size - 1, angle = 0.0; i <= midn; i++, j--, angle += freq) {
+      cx = (REAL) cos(angle);
+      window[j] = (window[i] = (REAL)
+		   (.084037 +
+		    (cx *
+		     (-.29145 +
+		      (cx *
+		       (.375696 + (cx * (-.20762 + (cx * .041194)))))))));
+    }
+    break;
+  case EXPONENTIAL_WINDOW:
+    for (i = 0, j = size - 1; i <= midn; i++, j--) {
+      window[j] = (window[i] = (REAL) (expsum - 1.0));
+      expsum *= expn;
+    }
+    break;
+  case RIEMANN_WINDOW:
+    sr1 = two_pi / (REAL) size;
+    for (i = 0, j = size - 1; i <= midn; i++, j--) {
+      if (i == midn)
+	window[j] = (window[i] = 1.0);
+      else {
+	/* split out because NeXT C compiler can't handle the full expression */
+	cx = sr1 * (midn - i);
+	window[i] = (REAL) (sin(cx) / cx);
+	window[j] = window[i];
+      }
+    }
+    break;
+  case BLACKMANHARRIS_WINDOW:
+    {
+      REAL a0 = 0.35875f, a1 = 0.48829f, a2 = 0.14128f, a3 = 0.01168f;
+
+
+      for (i = 0; i < size; i++) {
+	window[i] =
+	  (REAL) (a0 -
+		  a1 * cos(two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)) +
+		  a2 * cos(2.0 * two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)) -
+		  a3 * cos(3.0 * two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)));
+      }
+    }
+    break;
+  case NUTTALL_WINDOW:
+    {
+      REAL a0 = 0.3635819f, a1 = 0.4891775f, a2 = 0.1365995f, a3 = 0.0106411f;
+
+
+      for (i = 0; i < size; i++) {
+	window[i] =
+	  (REAL) (a0 -
+		  a1 * cos(two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)) +
+		  a2 * cos(2.0 * two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)) -
+		  a3 * cos(3.0 * two_pi * (REAL) (i + 0.5) /
+			   (REAL) (size - 1)));
+      }
+    }
+    break;
+  default:
+    return 0;
+    break;
+  }
+
+  return window;
+}
--- /dev/null
+++ dttsp-0~svn675/thunk.h
@@ -0,0 +1,46 @@
+/* thunk.c
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
+
+This program is free software; you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _thunk_h
+#define _thunk_h
+
+typedef int (*Thunk)(int n, char **p);
+
+typedef struct _cmd_tbl_entry {
+  char *key;
+  Thunk thk;
+} CTE, *CTB;
+
+extern Thunk Thunk_lookup(CTB ctb, char *key);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/correctIQ.h
@@ -0,0 +1,52 @@
+/* correctIQ.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _correctIQ_h
+#define _correctIQ_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+
+typedef struct _iqstate {
+  REAL phase, gain;
+} *IQ, iqstate;
+
+extern IQ newCorrectIQ(REAL phase, REAL gain);
+extern void delCorrectIQ(IQ iq);
+extern void correctIQ(CXB sigbuf, IQ iq);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/window.h
@@ -0,0 +1,75 @@
+/* window.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Implemented from code by Bill Schottstaedt of Snd Editor at CCRMA
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _window_h
+#define _window_h
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <math.h>
+#include <datatypes.h>
+
+/* #define RECTANGULAR_WINDOW 	 1
+#define HANNING_WINDOW 		 2
+#define WELCH_WINDOW 		 3
+#define PARZEN_WINDOW 		 4
+#define BARTLETT_WINDOW 	 5
+#define HAMMING_WINDOW 		 6
+#define BLACKMAN2_WINDOW	 7
+#define BLACKMAN3_WINDOW 	 8
+#define BLACKMAN4_WINDOW 	 9
+#define EXPONENTIAL_WINDOW 	10
+#define RIEMANN_WINDOW 		11 */
+
+typedef enum _windowtype {
+  RECTANGULAR_WINDOW,
+  HANNING_WINDOW,
+  WELCH_WINDOW,
+  PARZEN_WINDOW,
+  BARTLETT_WINDOW,
+  HAMMING_WINDOW,
+  BLACKMAN2_WINDOW,
+  BLACKMAN3_WINDOW,
+  BLACKMAN4_WINDOW,
+  EXPONENTIAL_WINDOW,
+  RIEMANN_WINDOW,
+  BLACKMANHARRIS_WINDOW,
+  NUTTALL_WINDOW,
+} Windowtype;
+
+extern REAL *makewindow(Windowtype type, int size, REAL *window);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/filterbank.h
@@ -0,0 +1,81 @@
+// filterbank.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+or
+
+The DTTS Microwave Society
+3125 Capilano Crescent #201
+North Vancouver, BC V7R 4X5
+Canada
+*/			   
+
+#ifndef _Filter_Bank_H
+#define _Filter_Bank_H
+#include <ovsv.h>
+#include <gsl/gsl_blas.h>
+#include <filter.h>
+#include <fftw3.h>
+
+typedef struct _FilterBank {
+  RealFIR fbfil; 
+  fftwf_plan fb_fft;
+  BOOLEAN Analysis,Complex,MyFilt;
+  int Partitions,Columns;
+  gsl_complex_float *in,*out,*databuf;
+  gsl_vector_complex_float gvcf;
+  gsl_matrix_float *filter_partition;
+  gsl_matrix_complex_float *data_partition;
+  gsl_matrix_complex_float_view old,new;
+  
+} FilterBankDesc, *FilterBank;
+
+typedef struct _FilterBankOvSv {
+  FilterBank fb;
+  FiltOvSv fbFilterPartion;
+} FilterBankOVSVDesc, *FilterBankOVSV;
+
+extern FilterBank newFilterBank(REAL SampleRate, int ChangeRatio, BOOLEAN Analysis,
+				REAL StopbandAttenuation, REAL TransitionBandwidth,
+				COMPLEX *databuf, RealFIR lp, int wisdombits);
+
+extern FilterBankOVSV newFilterBankOVSV(REAL SampleRate, int ChangeRatio,
+					BOOLEAN Analysis, REAL StopbandAttenuation,
+					REAL TransitionBandwidth, COMPLEX *databuf,
+					RealFIR lp, int wisdombits);
+
+extern void delFilterBank(FilterBank fb);
+extern void delFilterBankOVSV(FilterBankOVSV fb);
+extern void runAnalysisFilterBank(FilterBank p);
+extern void runAnalysisFilterBankOVSV(FilterBank p);
+extern void runSynthesisFilterBank(FilterBank p);
+extern void runSynthesisFilterBankOVSV(FilterBank p);
+#endif
--- /dev/null
+++ dttsp-0~svn675/install-sh
@@ -0,0 +1,520 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2009-04-28.21; # UTC
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  trap '(exit $?); exit' 1 2 13 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dst_arg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writeable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	-*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test -z "$d" && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
--- /dev/null
+++ dttsp-0~svn675/dcblock.c
@@ -0,0 +1,97 @@
+/** 
+* @file dcblock.c
+* @brief Function to implement dc blocks 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <dcblock.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief DCBlock 
+* 
+* @param dcb 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+DCBlock(DCBlocker dcb) {
+  int i;
+
+  for (i = 0; i < CXBhave(dcb->buf); i++) {
+    REAL x = CXBreal(dcb->buf, i),
+         y = x - dcb->xm1 + 0.995 * dcb->ym1;
+    dcb->xm1 = x;
+    dcb->ym1 = y;
+    CXBdata(dcb->buf, i) = Cmplx(y, 0.0);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief resetDCBlocker
+*
+* @param dcb 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+resetDCBlocker(DCBlocker dcb) {
+  dcb->xm1 = dcb->ym1 = 0.0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief newDCBlocker 
+* 
+* @param buf 
+*/
+/* ---------------------------------------------------------------------------- */
+DCBlocker
+newDCBlocker(CXB buf) {
+  DCBlocker dcb =
+    (DCBlocker) safealloc(1, sizeof(DCBlockerInfo), "DCBlocker");
+  dcb->buf = newCXB(CXBsize(buf), CXBbase(buf), "DCBlocker");
+  resetDCBlocker(dcb);
+  return dcb;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief delDCBlocker 
+* 
+* @param dcb 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delDCBlocker(DCBlocker dcb) {
+  if (dcb) {
+    delCXB(dcb->buf);
+    safefree((char *) dcb);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/DoxyFile
@@ -0,0 +1,1462 @@
+# Doxyfile 1.5.7
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = DttSP 
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 234 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ../doc
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Farsi, Finnish, French, German, Greek, 
+# Hungarian, Italian, Japanese, Japanese-en (Japanese with English messages), 
+# Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, Polish, 
+# Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, Slovene, 
+# Spanish, Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen to replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk.
+# When the cache is full, less often used symbols will be written to disk.
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penality. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will rougly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
+# This will remove the Files entry from the Quick Index and from the 
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page.  This will remove the Namespaces entry from the Quick Index
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by 
+# doxygen. The layout file controls the global structure of the generated output files 
+# in an output format independent way. The create the layout file that represents 
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a 
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name 
+# of the layout file.
+
+LAYOUT_FILE            = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = 
+
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.  Otherwise they will link to the documentstion.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# content.
+
+CHM_INDEX_ENCODING     = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER 
+# are set, an additional index file will be generated that can be used as input for 
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated 
+# HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#namespace">Qt Help Project / Namespace</a>.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#virtual-folders">Qt Help Project / Virtual Folders</a>.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
+# .qhp file .
+
+QHG_LOCATION           = 
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information.
+# If the tag value is set to FRAME, a side panel will be generated
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature. Other possible values 
+# for this tag are: HIERARCHIES, which will generate the Groups, Directories,
+# and Class Hierarchy pages using a tree view instead of an ordered list;
+# ALL, which combines the behavior of FRAME and HIERARCHIES; and NONE, which
+# disables this behavior completely. For backwards compatibility with previous
+# releases of Doxygen, the values YES and NO are equivalent to FRAME and NONE
+# respectively.
+
+GENERATE_TREEVIEW      = NONE
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
+# default search path.
+
+MSCGEN_PATH            = 
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# By default doxygen will write a font called FreeSans.ttf to the output 
+# directory and reference it in all dot files that doxygen generates. This 
+# font does not include all possible unicode characters however, so when you need 
+# these (or just want a differently looking font) you can specify the font name 
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
+# can find it using this tag.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
--- /dev/null
+++ dttsp-0~svn675/bufvec.c
@@ -0,0 +1,429 @@
+/** 
+* @file bufvec.c
+* @brief Creation, deletion, management for vectors and buffers 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+//------------------------------------------------------------------------
+
+#include <bufvec.h>
+#include <fftw3.h>
+
+/// ------------------------------------------------------------------------
+/// wrapper around calloc
+
+PRIVATE size_t _safemem_currcount = 0;
+
+/* -------------------------------------------------------------------------- */
+/** @brief safealloc
+* 
+* @param count 
+* @param nbytes 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+char *
+safealloc(int count, int nbytes, char *tag) {
+  //  char *p = calloc(count, nbytes);
+  char *p = (char *) fftwf_malloc(nbytes * count);
+  memset((void *)p,0,nbytes*count);
+  if (!p) {
+    if (tag && *tag)
+      fprintf(stderr, "safealloc: %s\n", tag);
+    else
+      perror("safealloc");
+    exit(1);
+  }
+  _safemem_currcount += count * nbytes;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief safefree 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+safefree(char *p) {
+  if (p)
+    fftwf_free((void *) p);
+}
+
+size_t
+safememcurrcount(void) { return _safemem_currcount; }
+
+void
+safememreset(void) { _safemem_currcount = 0; }
+
+//------------------------------------------------------------------------
+// allocate/free just vectors
+
+/* -------------------------------------------------------------------------- */
+/** @brief New vector Real
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL *
+newvec_REAL(int size, char *tag) {
+  return (REAL *) safealloc(size, sizeof(REAL), tag);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete vector REAL 
+* 
+* @param vec 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delvec_REAL(REAL *vec) {
+  safefree((char *) vec);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief New vector IMAG 
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+IMAG *
+newvec_IMAG(int size, char *tag) {
+  return (IMAG *) safealloc(size, sizeof(IMAG), tag);
+}
+
+void
+delvec_IMAG(IMAG *vec) {
+  safefree((char *) vec);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief New vector COMPLEX 
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+newvec_COMPLEX(int size, char *tag) {
+  return (COMPLEX *) safealloc(size, sizeof(COMPLEX), tag);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete vector COMPLEX
+* 
+* @param vec 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delvec_COMPLEX(COMPLEX *vec) {
+  safefree((char *) vec);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief New vector COMPLEX fttw 
+* 
+* @param size 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+newvec_COMPLEX_fftw(int size, char *tag) {
+  COMPLEX *p = (COMPLEX *)safealloc(size,sizeof(COMPLEX), tag);
+  if (!p) {
+    if (tag && *tag)
+      fprintf(stderr, "safealloc: %s\n", tag);
+    else
+      perror("safealloc");
+    exit(1);
+  }
+    
+  return p;
+
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete vector COMPLEX fftw 
+* 
+* @param vec 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delvec_COMPLEX_fftw(COMPLEX *vec) {
+  safefree((char *) vec);
+}
+
+/// ------------------------------------------------------------------------
+///  buffers (mainly i/o)
+/// ------------------------------------------------------------------------
+///  complex
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new CXB 
+* 
+* @param size 
+* @param base 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+CXB
+newCXB(int size, COMPLEX *base, char *tag) {
+  CXB p = (CXB) safealloc(1, sizeof(CXBuffer), tag);
+  if (base) {
+    CXBbase(p) = base;
+    CXBmine(p) = FALSE;
+  } else {
+    CXBbase(p) = newvec_COMPLEX(size, "newCXB");
+    CXBmine(p) = TRUE;
+  }
+  CXBsize(p) = CXBwant(p) = size;
+  CXBovlp(p) = CXBhave(p) = CXBdone(p) = 0;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a CXB object 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delCXB(CXB p) {
+  if (p) {
+    if (CXBmine(p))
+      delvec_COMPLEX(CXBbase(p));
+    safefree((char *) p);
+  }
+}
+
+/// ------------------------------------------------------------------------
+/// real
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new RLB object 
+* 
+* @param size 
+* @param base 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+RLB
+newRLB(int size, REAL *base, char *tag) {
+  RLB p = (RLB) safealloc(1, sizeof(RLBuffer), tag);
+  if (base) {
+    RLBbase(p) = base;
+    RLBmine(p) = FALSE;
+  } else {
+    RLBbase(p) = newvec_REAL(size, "newRLB");
+    RLBmine(p) = TRUE;
+  }
+  RLBsize(p) = RLBwant(p) = size;
+  RLBovlp(p) = RLBhave(p) = RLBdone(p) = 0;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a RLB object  
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delRLB(RLB p) {
+  if (p) {
+    if (p->mine)
+      delvec_REAL(RLBbase(p));
+    safefree((char *) p);
+  }
+}
+
+/// ========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief normalize vector_REAL 
+* 
+* return normalization constant
+*
+* @param v 
+* @param n 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+normalize_vec_REAL(REAL *v, int n) {
+  if (v && (n > 0)) {
+    int i;
+    REAL big = -(REAL) MONDO;
+    for (i = 0; i < n; i++) {
+      REAL a = abs(v[i]);
+      big = max(big, a);
+    }
+    if (big > 0.0) {
+      REAL scl = (REAL) (1.0 / big);
+      for (i = 0; i < n; i++)
+	v[i] *= scl;
+      return scl;
+    } else
+      return 0.0;
+  } else
+    return 0.0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief normalize vector COMPLEX 
+* 
+* return normalization constant
+*
+* @param z 
+* @param n 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+normalize_vec_COMPLEX(COMPLEX *z, int n) {
+  if (z && (n > 0)) {
+    int i;
+    REAL big = -(REAL) MONDO;
+    for (i = 0; i < n; i++) {
+      REAL a = Cabs(z[i]);
+      big = max(big, a);
+    }
+    if (big > 0.0) {
+      REAL scl = (REAL) (1.0 / big);
+      for (i = 0; i < n; i++)
+	z[i] = Cscl(z[i], scl);
+      return scl;
+    } else
+      return 0.0;
+  } else
+    return 0.0;
+}
+
+/// ----------------------------------------------------------------------
+/// ----------------------------------------------------------------------
+///  mostly for debugging when necessary
+
+/* -------------------------------------------------------------------------- */
+/** @brief dump REAL
+* 
+* @param fp 
+* @param head 
+* @param ptr 
+* @param beg 
+* @param fin 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+dump_REAL(FILE * fp, char *head, REAL *ptr, int beg, int fin) {
+  int i;
+  FILE *iop = fp ? fp : stderr;
+  if (head && *head)
+    fprintf(iop, "dump_REAL: %s\n", head);
+  for (i = beg; i < fin; i++)
+    fprintf(iop, "%5d %g\n", i, ptr[i]);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief dump IMAG 
+* 
+* @param fp 
+* @param head 
+* @param ptr 
+* @param beg 
+* @param fin 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+dump_IMAG(FILE * fp, char *head, IMAG *ptr, int beg, int fin) {
+  int i;
+  FILE *iop = fp ? fp : stderr;
+  if (head && *head)
+    fprintf(iop, "dump_REAL: %s\n", head);
+  for (i = beg; i < fin; i++)
+    fprintf(iop, "%5d %g\n", i, ptr[i]);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief dump CX 
+* 
+* @param fp 
+* @param head 
+* @param ptr 
+* @param beg 
+* @param fin 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+dump_CX(FILE * fp, char *head, COMPLEX *ptr, int beg, int fin) {
+  int i;
+  FILE *iop = fp ? fp : stderr;
+  if (head && *head)
+    fprintf(iop, "dump_CX: %s\n", head);
+  for (i = beg; i < fin; i++)
+    fprintf(iop, "%5d %g %g\n", i, ptr[i].re, ptr[i].im);
+}
+
+//==================================================================
+// Simple Vector stuff
+
+SV
+newSV(int size, REAL *base, char *tag) {
+  SV p = (SV) safealloc(1, sizeof(SimpleVector), tag);
+  if (base) {
+    SVbase(p) = base;
+    SVmine(p) = FALSE;
+  } else {
+    SVbase(p) = newvec_REAL(size, tag);
+    SVmine(p) = TRUE;
+  }
+  SVsize(p) = size;
+  return p;
+}
+
+void
+delSV(SV sv) {
+  if (sv) {
+    if (SVmine(sv))
+      delvec_REAL(SVbase(sv));
+    safefree((char *) sv);
+  }
+}
+
+void
+SVfill(SV sv, REAL val) {
+  int i;
+  for (i = 0; i < SVsize(sv); i++)
+    SVdata(sv, i) = val;
+}
--- /dev/null
+++ dttsp-0~svn675/delay.c
@@ -0,0 +1,46 @@
+// delay.c
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+or
+
+The DTTS Microwave Society
+3125 Capilano Crescent #201
+North Vancouver, BC V7R 4X5
+Canada
+*/			   
+
+#include <delay.h>
+
+void
+Delayer(DelayLine d) {
+  
+}
--- /dev/null
+++ dttsp-0~svn675/mkpipes.sh
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+CMDPIPE=${SDR_PARMPATH:-/dev/shm/SDRcommands}
+if [ ! -p $CMDPIPE ]; then
+    mkfifo $CMDPIPE
+fi
+
+SPECPIPE=${SDR_SPECPATH:-/dev/shm/SDRspectrum}
+if [ ! -p $SPECPIPE ]; then
+    mkfifo $SPECPIPE
+fi
+
+METERPIPE=${SDR_METERPATH:-/dev/shm/SDRmeter}
+if [ ! -p $METERPIPE ]; then
+    mkfifo $METERPIPE
+fi
--- /dev/null
+++ dttsp-0~svn675/datatypes.h
@@ -0,0 +1,56 @@
+/* datatypes.h
+   local definitions and aliases for our data
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _datatypes_h
+#define _datatypes_h
+
+#include <fromsys.h>
+
+typedef unsigned int BOOLEAN;
+typedef float REAL;
+typedef float IMAG;
+typedef short SAMPLE_16t;
+
+#include <complex.h>
+
+#ifndef PRIVATE
+#define PRIVATE static
+#endif
+#ifndef INLINE
+#define INLINE inline
+#endif
+
+#include <thunk.h>
+
+#include <banal.h>
+#endif
--- /dev/null
+++ dttsp-0~svn675/bootstrap
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+aclocal
+autoconf
+touch NEWS README AUTHORS ChangeLog
+automake -a
--- /dev/null
+++ dttsp-0~svn675/filter.h
@@ -0,0 +1,113 @@
+/* filter.h
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _filter_h
+
+#define _filter_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <fastrig.h>
+#include <update.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <window.h>
+#include <math.h>
+
+typedef enum {
+  FIR_Undef,
+  FIR_Lowpass,
+  FIR_Bandpass,
+  FIR_Highpass,
+  FIR_Hilbert,
+  FIR_Bandstop
+} FIR_response_type;
+
+typedef enum { FIR_Even, FIR_Odd } FIR_parity_type;
+
+typedef struct _real_FIR {
+  REAL *coef;
+  int size;
+  FIR_response_type type;
+  BOOLEAN cplx;
+  struct { REAL lo, hi; } freq;
+} RealFIRDesc, *RealFIR;
+
+typedef struct _complex_FIR {
+  COMPLEX *coef;
+  int size;
+  FIR_response_type type;
+  BOOLEAN cplx;
+  struct { REAL lo, hi; } freq;
+} ComplexFIRDesc, *ComplexFIR;
+
+#define FIRcoef(p) ((p)->coef)
+#define FIRtap(p, i) (FIRcoef(p)[(i)])
+#define FIRsize(p) ((p)->size)
+#define FIRtype(p) ((p)->type)
+#define FIRiscomplex(p) ((p)->cplx)
+#define FIRisreal(p) (!FIRiscomplex(p))
+#define FIRfqlo(p) ((p)->freq.lo)
+#define FIRfqhi(p) ((p)->freq.hi)
+
+#define delFIR_Lowpass_REAL(p) delFIR_REAL(p)
+#define delFIR_Lowpass_COMPLEX(p) delFIR_COMPLEX(p)
+#define delFIR_Bandpass_REAL(p) delFIR_REAL(p)
+#define delFIR_Bandpass_COMPLEX(p) delFIR_COMPLEX(p)
+#define delFIR_Highpass_REAL(p) delFIR_REAL(p)
+#define delFIR_Highpass_COMPLEX(p) delFIR_COMPLEX(p)
+#define delFIR_Hilbert_REAL(p) delFIR_REAL(p)
+#define delFIR_Hilbert_COMPLEX(p) delFIR_COMPLEX(p)
+#define delFIR_Bandstop_REAL(p) delFIR_REAL(p)
+#define delFIR_Bandstop_COMPLEX(p) delFIR_COMPLEX(p)
+
+extern RealFIR newFIR_REAL(int size, char *tag);
+extern ComplexFIR newFIR_COMPLEX(int size, char *tag);
+extern void delFIR_REAL(RealFIR p);
+extern void delFIR_COMPLEX(ComplexFIR p);
+extern RealFIR newFIR_Lowpass_REAL(REAL cutoff, REAL sr, int size);
+extern ComplexFIR newFIR_Lowpass_COMPLEX(REAL cutoff, REAL sr, int size);
+extern RealFIR newFIR_Bandpass_REAL(REAL lo, REAL hi, REAL sr, int size);
+extern ComplexFIR newFIR_Bandpass_COMPLEX(REAL lo, REAL hi, REAL sr,
+					  int size);
+extern RealFIR newFIR_Highpass_REAL(REAL cutoff, REAL sr, int size);
+extern ComplexFIR newFIR_Highpass_COMPLEX(REAL cutoff, REAL sr, int size);
+extern RealFIR newFIR_Hilbert_REAL(REAL lo, REAL hi, REAL sr, int size);
+extern ComplexFIR newFIR_Hilbert_COMPLEX(REAL lo, REAL hi, REAL sr, int size);
+extern RealFIR newFIR_Bandstop_REAL(REAL lo, REAL hi, REAL sr, int size);
+extern ComplexFIR newFIR_Bandstop_COMPLEX(REAL lo, REAL hi, REAL sr, int size);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/wav2z.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python
+
+import sys
+import wave
+import math as M
+import numpy as N
+import hilbert as H
+
+if len(sys.argv) <> 3:
+    print >>sys.stderr, "usage:"
+    print >>sys.stderr, "wav2z infile outfile"
+    sys.exit(1)
+
+try:
+    iwav = wave.open(sys.argv[1], 'rb')
+except:
+    print >>sys.stderr, "Can't open ", sys.argv[1], " for reading."
+    sys.exit(1)
+
+(nchannels,
+ sampwidth,
+ framerate,
+ nframes,
+ comptype,
+ compname) = iwav.getparams()
+
+if nchannels <> 1:
+    print >>sys.stderr, sys.argv[1], " is not a mono file."
+    sys.exit(1)
+if sampwidth <> 2:
+    print >>sys.stderr, sys.argv[1], " is not 16t."
+    sys.exit(1)
+
+try:
+    owav = wave.open(sys.argv[2], 'wb')
+except:
+    print >>sys.stderr, "Can't open ", sys.argv[2], " for writing."
+    sys.exit(1)
+
+nchannels = 2
+owav.setparams((nchannels,
+                sampwidth,
+                framerate,
+                nframes,
+                comptype,
+                compname))
+
+filt = H.HilbertTransformer()
+nbuf = 1024
+
+while nframes > 0:
+    iraw = iwav.readframes(nbuf)
+    ngot = len(iraw)
+    ibuf = N.fromstring(iraw, dtype=N.int16).astype(float)
+    ibuf /= 32768.0
+
+    ocpx = filt.run(ibuf)
+
+    obuf = N.array([ocpx.real, ocpx.imag])
+    obuf = obuf.clip(-1, 0.999999)
+    obuf *= 32768.0
+    obuf = obuf.transpose()
+    obuf = obuf.astype(N.int16)
+    oraw = obuf.tostring()
+
+    owav.writeframes(oraw)
+    nframes -= ngot
+
+iwav.close()
+owav.close()
+
--- /dev/null
+++ dttsp-0~svn675/wvnr.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python
+
+import sys
+import pygsl as gsl
+import pygsl.fft as fft
+import pygsl.spline as spline
+import pygsl.wavelet as wvlt
+import math as M
+import numpy as N
+import scipy as S
+
+import aux as A
+import hilbert as H
+
+class WavOla():
+    def __init__(self,
+                 order = 20,
+                 size  = 1024):
+        self.size = size
+        self.half = A.nblock2(size)
+        self.wlen = self.half*2
+
+        self.wvlt_i = wvlt.daubechies(order)
+        self.wwrk_i = wvlt.workspace(self.wlen)
+        self.tail_i = N.zeros(self.half)
+
+        self.wvlt_q = wvlt.daubechies(order)
+        self.wwrk_q = wvlt.workspace(self.wlen)
+        self.tail_q = N.zeros(self.half)
+
+#       self.hilb = H.HilbertTransformer()
+
+    def run(self, x, mask):
+        self.xdat_i = N.concatenate((x[0], N.zeros(self.half)))
+        self.wdat_i = self.wvlt_i.transform_forward(self.xdat_i, self.wwrk_i)
+        self.wdat_i *= mask
+        self.ydat_i = self.wvlt_i.transform_inverse(self.wdat_i, self.wwrk_i)
+        self.odat_i = self.ydat_i[         :self.half] + self.tail_i
+        self.tail_i = self.ydat_i[self.half:         ].copy()
+
+        self.xdat_q = N.concatenate((x[1], N.zeros(self.half)))
+        self.wdat_q = self.wvlt_q.transform_forward(self.xdat_q, self.wwrk_q)
+        self.wdat_q *= mask
+        self.ydat_q = self.wvlt_q.transform_inverse(self.wdat_q, self.wwrk_q)
+        self.odat_q = self.ydat_q[         :self.half] + self.tail_q
+        self.tail_q = self.ydat_q[self.half:         ].copy()
+
+        return array([self.odat_i, self.odat_q])
--- /dev/null
+++ dttsp-0~svn675/dttspagc.h
@@ -0,0 +1,107 @@
+/* dttspagc.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _dttspagc_h
+#define _dttspagc_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+
+#define FASTLEAD 72
+
+typedef enum _agcmode {
+  agcOFF,
+  agcLONG,
+  agcSLOW,
+  agcMED,
+  agcFAST
+} AGCMODE;
+
+typedef
+struct _dttspagc {
+  struct {
+    REAL bottom,
+         fastnow,
+         fix,
+         limit,
+         now,
+         old,
+         raw,
+         top;
+  } gain, fastgain;
+  int fasthang,
+      fastindx,
+      hangindex,
+      indx,
+      mask,
+      mode,
+      sndx;
+  REAL attack,
+       decay,
+       fastattack,
+       fastdecay,
+       fasthangtime,
+       hangthresh,
+       hangtime,
+       one_m_attack,
+       one_m_decay,
+       one_m_fastattack,
+       one_m_fastdecay,
+       samprate,
+       slope;
+  COMPLEX *circ;
+  CXB buff;
+  char tag[4];
+} dttspagc, *DTTSPAGC;
+
+extern void DttSPAgc(DTTSPAGC a, int tick);
+extern DTTSPAGC newDttSPAgc(AGCMODE mode,
+			    COMPLEX *Vec,
+			    int BufSize,
+			    REAL Limit,
+			    REAL attack,
+			    REAL decay,
+			    REAL slope,
+			    REAL hangtime,
+			    REAL samprate,
+			    REAL MaxGain,
+			    REAL MinGain,
+			    REAL Curgain,
+			    char *tag);
+extern void delDttSPAgc(DTTSPAGC a);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/keyer.mk
@@ -0,0 +1,17 @@
+CFLAGS = -O3 -I.
+#CFLAGS = -g -O -I.
+LIBS = ./libDttSP.a -ljack -lpthread -lfftw3f -lm
+
+iambic-keyer:	iambic-keyer.o
+	$(CC) -O3 -o iambic-keyer iambic-keyer.o $(LIBS)
+
+keyboard-keyer:	keyboard-keyer.o
+	$(CC) -o keyboard-keyer keyboard-keyer.o $(LIBS)
+
+install:	iambic-keyer keyboard-keyer
+	mv iambic-keyer keyboard-keyer ../bin
+
+clean:
+	/bin/rm -f *.o iambic-keyer keyboard-keyer\
+			 ../bin/iambic-keyer ../bin/keyboard-keyer 
+
--- /dev/null
+++ dttsp-0~svn675/Makefile.am
@@ -0,0 +1,77 @@
+bin_PROGRAMS = sdr-core
+sdr_core_SOURCES = 	sdr-main.c sdrexport.c
+sdr_core_LDADD = libDttSP.a
+
+noinst_LIBRARIES = libDttSP.a
+libDttSP_a_SOURCES = \
+	am_demod.c\
+	am_demod.h \
+	banal.c\
+	banal.h\
+	bufvec.c\
+	bufvec.h\
+	correctIQ.c\
+	correctIQ.h\
+	cwtones.c\
+	cwtones.h\
+	cxops.c\
+	cxops.h\
+	dcblock.c\
+	dcblock.h\
+	dttspagc.c\
+	dttspagc.h\
+	fastrig.c\
+	fastrig.h\
+	filter.c\
+	filter.h\
+	fm_demod.c\
+	fm_demod.h\
+	graphiceq.c\
+	graphiceq.h\
+	halfband.c\
+	halfband.h\
+	hilbert.c\
+	hilbert.h\
+	isoband.c\
+	isoband.h\
+	lmadf.c\
+	lmadf.h\
+	meter.c\
+	meter.h\
+	noiseblanker.c\
+	noiseblanker.h\
+	oscillator.c\
+	oscillator.h\
+	ovsv.c\
+	ovsv.h\
+	resample.c\
+	resample.h\
+	ringb.c\
+	ringb.h\
+	sdr.c\
+	sdrexport.h\
+	spectrum.c\
+	spectrum.h\
+	speechproc.c\
+	speechproc.h\
+	splitfields.c\
+	splitfields.h\
+	spottone.c\
+	spottone.h\
+	thunk.c\
+	thunk.h\
+	window.c\
+	window.h\
+	waveshape.c\
+	waveshape.h\
+	wscompand.c\
+	wscompand.h\
+	update.c \
+	update.h\
+	common.h\
+	complex.h\
+	datatypes.h\
+	defs.h\
+	fromsys.h\
+	keyer.h\
+	local.h
--- /dev/null
+++ dttsp-0~svn675/aclocal.m4
@@ -0,0 +1,951 @@
+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.67],,
+[m4_warning([this file was generated for autoconf 2.67.
+You have another version of autoconf.  It may work, but is not guaranteed to.
+If you have problems, you may need to regenerate the build system entirely.
+To do so, use the procedure documented by the package, typically `autoreconf'.])])
+
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+# (This private macro should not be called outside this file.)
+AC_DEFUN([AM_AUTOMAKE_VERSION],
+[am__api_version='1.11'
+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
+dnl require some minimum version.  Point them to the right macro.
+m4_if([$1], [1.11.1], [],
+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
+])
+
+# _AM_AUTOCONF_VERSION(VERSION)
+# -----------------------------
+# aclocal traces this macro to find the Autoconf version.
+# This is a private macro too.  Using m4_define simplifies
+# the logic in aclocal, which can simply ignore this definition.
+m4_define([_AM_AUTOCONF_VERSION], [])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+[AM_AUTOMAKE_VERSION([1.11.1])dnl
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 9
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])dnl
+AC_SUBST([$1_FALSE])dnl
+_AM_SUBST_NOTMAKE([$1_TRUE])dnl
+_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+m4_define([_AM_COND_VALUE_$1], [$2])dnl
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 10
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  am__universal=false
+  m4_case([$1], [CC],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac],
+    [CXX],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac])
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 5
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[{
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`AS_DIRNAME("$mf")`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`AS_DIRNAME(["$file"])`
+      AS_MKDIR_P([$dirpart/$fdir])
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 16
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.62])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+			     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+		  [_AM_DEPENDENCIES(CC)],
+		  [define([AC_PROG_CC],
+			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+		  [_AM_DEPENDENCIES(CXX)],
+		  [define([AC_PROG_CXX],
+			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJC],
+		  [_AM_DEPENDENCIES(OBJC)],
+		  [define([AC_PROG_OBJC],
+			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+])
+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
+AC_CONFIG_COMMANDS_PRE(dnl
+[m4_provide_if([_AM_COMPILER_EXEEXT],
+  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
+])
+
+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
+dnl mangled by Autoconf and run in a shell conditional statement.
+m4_define([_AC_COMPILER_EXEEXT],
+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_arg=$1
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+AC_SUBST(install_sh)])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 6
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([missing])dnl
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check for `mkdir -p'.
+AC_DEFUN([AM_PROG_MKDIR_P],
+[AC_PREREQ([2.60])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
+dnl while keeping a definition of mkdir_p for backward compatibility.
+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
+dnl Makefile.ins that do not define MKDIR_P, so we do our own
+dnl adjustment using top_builddir (which is defined more often than
+dnl MKDIR_P).
+AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
+case $mkdir_p in
+  [[\\/$]]* | ?:[[\\/]]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[[\\\"\#\$\&\'\`$am_lf]]*)
+    AC_MSG_ERROR([unsafe absolute working directory name]);;
+esac
+case $srcdir in
+  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# This macro is traced by Automake.
+AC_DEFUN([_AM_SUBST_NOTMAKE])
+
+# AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Public sister of _AM_SUBST_NOTMAKE.
+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
--- /dev/null
+++ dttsp-0~svn675/depcomp
@@ -0,0 +1,630 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2009-04-28.21; # UTC
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2009 Free
+# Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+cygpath_u="cygpath -u -f -"
+if test "$depmode" = msvcmsys; then
+   # This is just like msvisualcpp but w/o cygpath translation.
+   # Just convert the backslash-escaped backslashes to single forward
+   # slashes to satisfy depend.m4
+   cygpath_u="sed s,\\\\\\\\,/,g"
+   depmode=msvisualcpp
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+## Unfortunately, FreeBSD c89 acceptance of flags depends upon
+## the command line argument order; so add the flags where they
+## appear in depend2.am.  Note that the slowdown incurred here
+## affects only configure: in makefiles, %FASTDEP% shortcuts this.
+  for arg
+  do
+    case $arg in
+    -c) set fnord "$@" -MT "$object" -MD -MP -MF "$tmpdepfile" "$arg" ;;
+    *)  set fnord "$@" "$arg" ;;
+    esac
+    shift # fnord
+    shift # $arg
+  done
+  "$@"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' < "$tmpdepfile" |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' < "$tmpdepfile" \
+    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' >> "$depfile"
+    echo >> "$depfile"
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' < "$tmpdepfile" \
+   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$base.u
+    tmpdepfile3=$dir.libs/$base.u
+    "$@" -Wc,-M
+  else
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$dir$base.u
+    tmpdepfile3=$dir$base.u
+    "$@" -M
+  fi
+  stat=$?
+
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+    # That's a tab and a space in the [].
+    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
+    sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp2)
+  # The "hp" stanza above does not work with aCC (C++) and HP's ia64
+  # compilers, which have integrated preprocessors.  The correct option
+  # to use with these is +Maked; it writes dependencies to a file named
+  # 'foo.d', which lands next to the object file, wherever that
+  # happens to be.
+  # Much of this is similar to the tru64 case; see comments there.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir.libs/$base.d
+    "$@" -Wc,+Maked
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    "$@" +Maked
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+     rm -f "$tmpdepfile1" "$tmpdepfile2"
+     exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    sed -e "s,^.*\.[a-z]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add `dependent.h:' lines.
+    sed -ne '2,${
+	       s/^ *//
+	       s/ \\*$//
+	       s/$/:/
+	       p
+	     }' "$tmpdepfile" >> "$depfile"
+  else
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile" "$tmpdepfile2"
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+   test "x$dir" = "x$object" && dir=
+   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test "$libtool" = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mechanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      "$@" -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      "$@" -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+      exit $stat
+   fi
+
+   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+   do
+     test -f "$tmpdepfile" && break
+   done
+   if test -f "$tmpdepfile"; then
+      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+   else
+      echo "#dummy" > "$depfile"
+   fi
+   rm -f "$tmpdepfile"
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  "$@" $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  tr ' ' '
+' < "$tmpdepfile" | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no eat=no
+  for arg
+  do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    if test $eat = yes; then
+      eat=no
+      continue
+    fi
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -arch)
+      eat=yes ;;
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix=`echo "$object" | sed 's/^.*\././'`
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  sed '1,2d' "$tmpdepfile" | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E |
+    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+	set fnord "$@"
+	shift
+	shift
+	;;
+    *)
+	set fnord "$@" "$arg"
+	shift
+	shift
+	;;
+    esac
+  done
+  "$@" -E 2>/dev/null |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::\1:p' | $cygpath_u | sort -u > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
+  echo "	" >> "$depfile"
+  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvcmsys)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
--- /dev/null
+++ dttsp-0~svn675/shared.mk
@@ -0,0 +1,55 @@
+CFLAGS = -fPIC -O3 -g -I.
+SHAREDLIBS = -L ../lib -lDttSP -ljack -lpthread -lfftw3f -lm
+
+sharedlibname = libDttSP.so
+
+OBJ =	am_demod.o\
+	banal.o\
+	bufvec.o\
+	correctIQ.o\
+	cwtones.o\
+	cxops.o\
+	dcblock.o\
+	dttspagc.o\
+	fastrig.o\
+	filter.o\
+	graphiceq.o\
+	isoband.o\
+	fm_demod.o\
+	lmadf.o\
+	meter.o\
+	noiseblanker.o\
+	oscillator.o\
+	ovsv.o\
+	resample.o\
+	ringb.o\
+	sdr.o\
+	sdrexport.o\
+	spectrum.o\
+	speechproc.o\
+	splitfields.o\
+	spottone.o\
+	thunk.o\
+	window.o\
+	wscompand.o\
+	update.o
+
+all:	obj sharedlib sdr-core-shared
+
+sdr-core-shared:	sdr-main.o
+	$(CC) -o sdr-core sdr-main.o $(SHAREDLIBS)
+
+
+$(OBJ): sdrexport.h
+
+obj:	$(OBJ)
+
+clean:
+	/bin/rm -f *.o ../bin/sdr-core $(staticlibname)
+
+sharedlib:	$(OBJ)
+	$(CC) -shared -o $(sharedlibname) $(OBJ)
+	mv libDttSP.so ../lib
+
+install:	sdr-core-shared
+	mv sdr-core ../bin
--- /dev/null
+++ dttsp-0~svn675/cwtones.h
@@ -0,0 +1,79 @@
+/* spottone.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2005, 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _cwtone_h
+#define _cwtone_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <oscillator.h>
+#include <math.h>
+
+#define CWTone_IDLE (0)
+#define CWTone_WAIT (1)
+#define CWTone_RISE (2)
+#define CWTone_STDY (3)
+#define CWTone_FALL (4)
+#define CWTone_HOLD (5)
+
+typedef struct _cw_tone_gen {
+  REAL curr, gain, mul, scl, sr;
+  struct {
+    REAL freq;
+    OSC gen;
+  } osc;
+  struct {
+    REAL dur, incr;
+    int want, have;
+  } rise, fall;
+  int size, stage;
+  CXB buf;
+} CWToneGenDesc, *CWToneGen;
+
+extern CWToneGen newCWToneGen(REAL gain,	// dB
+			      REAL freq,	// Hz
+			      REAL rise,	// msec
+			      REAL fall,	// msec
+			      int size,	// buflen
+			      REAL samplerate);
+extern void delCWToneGen(CWToneGen gen);
+extern void setCWToneGenVals(CWToneGen gen,
+			     REAL gain, REAL freq, REAL rise, REAL fall);
+extern void CWToneOn(CWToneGen gen);
+extern void CWToneOff(CWToneGen gen);
+extern BOOLEAN CWTone(CWToneGen gen);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/config.sub
@@ -0,0 +1,1714 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+#   Free Software Foundation, Inc.
+
+timestamp='2010-01-22'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted GNU ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
+Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray | -microblaze)
+		os=
+		basic_machine=$1
+		;;
+        -bluegene*)
+	        os=-cnk
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fido | fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| lm32 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | mcore | mep | metag \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64octeon | mips64octeonel \
+	| mips64orion | mips64orionel \
+	| mips64r5900 | mips64r5900el \
+	| mips64vr | mips64vrel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| moxie \
+	| mt \
+	| msp430 \
+	| nios | nios2 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| rx \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu | strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k | z80)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* | avr32-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| lm32-* \
+	| m32c-* | m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64octeon-* | mips64octeonel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64r5900-* | mips64r5900el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
+	| msp430-* \
+	| nios-* | nios2-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* | rx-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile-* | tilegx-* \
+	| tron-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa*-* \
+	| ymp-* \
+	| z8k-* | z80-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+        cegcc)
+		basic_machine=arm-unknown
+		os=-cegcc
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dicos)
+		basic_machine=i686-pc
+		os=-dicos
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+        microblaze)
+		basic_machine=microblaze-xilinx
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+        # This must be matched before tile*.
+        tilegx*)
+		basic_machine=tilegx-unknown
+		os=-linux-gnu
+		;;
+	tile*)
+		basic_machine=tile-unknown
+		os=-linux-gnu
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	z80-*-coff)
+		basic_machine=z80-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+        -auroraux)
+	        os=-auroraux
+		;;
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* | -aros* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+        -tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-dicos*)
+		os=-dicos
+		;;
+        -nacl*)
+	        ;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+        score-*)
+		os=-elf
+		;;
+        spu-*)
+		os=-elf
+		;;
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+        c4x-* | tic4x-*)
+        	os=-coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+        mep-*)
+		os=-elf
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-cnk*|-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
--- /dev/null
+++ dttsp-0~svn675/am_demod.h
@@ -0,0 +1,86 @@
+/* am_demod.h */
+   
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _am_demod_h
+#define _am_demod_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <cxops.h>
+#include <bufvec.h>
+#include <fastrig.h>
+#include <update.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <oscillator.h>
+
+typedef enum _ammode { AMdet, SAMdet } AMMode;
+
+typedef struct _am_demod {
+  int size;
+  CXB ibuf, obuf;
+
+  struct {
+    REAL alpha, beta, fast_alpha;
+    struct { REAL f, l, h; } freq;
+    REAL phs;
+    struct { REAL alpha; } iir;
+    COMPLEX delay;
+  } pll;
+
+  struct { REAL curr, prev; } lock;
+
+  REAL dc, smooth;
+  AMMode mode;
+} AMDDesc, *AMD;
+
+extern void AMDemod(AMD am);
+extern AMD newAMD(REAL samprate,
+		  REAL f_initial,
+		  REAL f_lobound,
+		  REAL f_hibound,
+		  REAL f_bandwid,
+		  int size,
+		  COMPLEX * ivec, COMPLEX * ovec, AMMode mode, char *tag);
+extern void delAMD(AMD am);
+
+#ifndef TWOPI
+#define TWOPI (2.0*M_PI)
+#endif
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/isoband.h
@@ -0,0 +1,47 @@
+// isoband.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _isoband_h
+#define _isoband_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <datatypes.h>
+#include <banal.h>
+
+extern REAL ISOband_get_nominal(int band),
+            ISOband_get_exact(int band),
+            ISOband_get_low(int band),
+            ISOband_get_high(int band);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/correctIQ.c
@@ -0,0 +1,83 @@
+/** 
+* @file correctIQ.c
+* @brief Functions to correct IQ values 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This routine restores quadrature between arms of an analytic signal
+possibly distorted by ADC hardware.
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <correctIQ.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief new Correct IQ object
+* 
+* @param phase 
+* @param gain 
+*/
+/* ---------------------------------------------------------------------------- */
+IQ
+newCorrectIQ(REAL phase, REAL gain) {
+  IQ iq = (IQ) safealloc(1, sizeof(iqstate), "IQ state");
+  iq->phase = phase;
+  iq->gain = gain;
+  return iq;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief destroy a correct IQ object 
+* 
+* @param iq 
+* @param  
+* @param iq 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delCorrectIQ(IQ iq) { safefree((char *) iq); }
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a correctIQ 
+* 
+* @param sigbuf 
+* @param iq 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+correctIQ(CXB sigbuf, IQ iq) {
+  int i;
+  for (i = 0; i < CXBhave(sigbuf); i++) {
+    CXBimag(sigbuf, i) += iq->phase * CXBreal(sigbuf, i);
+    CXBreal(sigbuf, i) *= iq->gain;
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/sdrexport.h
@@ -0,0 +1,434 @@
+/* sdrexport.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _sdrexport_h
+#define _sdrexport_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <ringb.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <oscillator.h>
+#include <dttspagc.h>
+#include <am_demod.h>
+#include <fm_demod.h>
+#include <noiseblanker.h>
+#include <correctIQ.h>
+#include <speechproc.h>
+#include <spottone.h>
+#include <update.h>
+#include <local.h>
+#include <meter.h>
+#include <spectrum.h>
+#include <resample.h>
+//------------------------------------------------------------------------
+// max no. simultaneous receivers
+#ifndef MAXRX
+#define MAXRX (4)
+#endif
+//------------------------------------------------------------------------
+/* modulation types, modes */
+
+//========================================================================
+/* RX/TX both */
+//------------------------------------------------------------------------
+extern
+struct _uni {
+  struct {
+    REAL sample;
+  } rate;
+  int buflen;
+
+  struct {
+    SDRMODE sdr;
+    TRXMODE trx;
+  } mode;
+
+  METERBlock meter;
+  SpecBlock spec;
+
+  struct {
+    BOOLEAN flag;
+    char *path;
+    FILE *fp;
+    splitfld splt;
+  } update;
+
+  struct {
+    char *path;
+    int bits;
+  } wisdom;
+
+  struct {
+    BOOLEAN act[MAXRX];
+    int lis, nac, nrx;
+  } multirx;
+
+  int cpdlen;
+  long tick;
+
+} *uni;
+
+//------------------------------------------------------------------------
+/* RX */
+//------------------------------------------------------------------------
+
+extern
+struct _rx {
+
+  int len;
+
+  struct {
+    CXB i, o;
+  } buf;
+
+  IQ iqfix;
+
+  struct {
+    double freq, phase;
+    OSC gen;
+  } osc;
+
+  struct {
+    ComplexFIR coef;
+    FiltOvSv ovsv;
+    COMPLEX *save;
+  } filt;
+
+  struct {
+    REAL thresh;
+    NB gen;
+    BOOLEAN flag;
+  } nb;
+
+  struct {
+    REAL thresh;
+    NB gen;
+    BOOLEAN flag;
+  } nb_sdrom;
+
+  struct {
+    LMSR gen;
+    BOOLEAN flag;
+  } anr, anf;
+
+  struct {
+    BLMS gen;
+    BOOLEAN flag;
+  } banr, banf;
+
+  struct {
+    DTTSPAGC gen;
+    BOOLEAN flag;
+  } dttspagc;
+
+  struct {
+    AMD gen;
+  } am;
+
+  struct {
+    FMD gen;
+  } fm;
+
+  struct {
+    BOOLEAN flag;
+    SpotToneGen gen;
+  } spot;
+
+  struct {
+    REAL thresh, power;
+    BOOLEAN flag, running, set;
+    int num;
+  } squelch;
+
+  struct {
+    BOOLEAN flag;
+    WSCompander gen;
+  } cpd;
+
+  struct {
+    EQ gen;
+    BOOLEAN flag;
+  } grapheq;
+
+  SDRMODE mode;
+  
+  struct {
+    BOOLEAN flag;
+  } bin;
+
+  REAL norm;
+
+  struct {
+    REAL i, o;
+  } gain;
+  COMPLEX azim;
+
+  long tick;
+} *rx[MAXRX];
+
+//------------------------------------------------------------------------
+/* TX */
+//------------------------------------------------------------------------
+extern
+struct _tx {
+
+  int len;
+
+  struct {
+    CXB i, o;
+  } buf;
+
+  IQ iqfix;
+
+  struct {
+    BOOLEAN flag;
+    DCBlocker gen;
+  } dcb;
+
+  struct {
+    double freq, phase;
+    OSC gen;
+  } osc;
+
+  struct {
+    ComplexFIR coef;
+    FiltOvSv ovsv;
+    COMPLEX *save;
+  } filt;
+
+  struct {
+    REAL carrier_level;
+  } am;
+
+  struct {
+    REAL cvtmod2freq;
+  } fm;
+
+  struct {
+    REAL thresh, power;
+    BOOLEAN flag, running, set;
+    int num;
+  } squelch;
+
+  struct {
+    DTTSPAGC gen;
+    BOOLEAN flag;
+  } leveler;
+
+  struct {
+    EQ gen;
+    BOOLEAN flag;
+  } grapheq;
+
+
+  struct {
+    SpeechProc gen;
+    BOOLEAN flag;
+  } spr;
+
+  /***/
+
+  struct {
+    BOOLEAN flag;
+    WaveShaper gen;
+  } wvs;
+
+  /***/
+
+  struct {
+    BOOLEAN flag;
+    WSCompander gen;
+  } cpd;
+
+  struct {
+    REAL comp, cpdr, eqtap, lvlr, mic, pwr;
+  } sav;
+
+  struct {
+    REAL i, o;
+  } gain;
+
+  SDRMODE mode;
+
+  long tick;
+  REAL norm;
+
+} *tx;
+
+//------------------------------------------------------------------------
+
+typedef
+enum _runmode {
+  RUN_MUTE, RUN_PASS, RUN_PLAY, RUN_SWCH, RUN_TEST
+} RUNMODE;
+
+typedef
+enum _testmode {
+  TEST_TONE, TEST_2TONE, TEST_CHIRP, TEST_NOISE
+} TESTMODE;
+
+extern
+struct _top {
+  int pid;
+  uid_t uid;
+
+  struct timeval start_tv;
+
+  BOOLEAN running, verbose;
+  RUNMODE state;
+
+  // audio io
+  struct {
+    struct {
+      float *l, *r;
+    } buf;
+    struct {
+      unsigned int frames, bytes;
+    } size;
+  } hold;
+
+  struct {
+    char *path;
+    int fd;
+    FILE *fp;
+    char buff[4096];
+  } echo, parm;
+
+  struct {
+    struct {
+      char *path;
+      FILE *fp;
+    } mtr, spec;
+  } meas;
+
+  int offs;	// to compensate for L/R ADC lags
+
+  struct {
+    char name[256];
+
+    BOOLEAN doin;
+    size_t size, rsiz;
+    jack_client_t *client;
+
+    struct {
+      struct {
+	jack_port_t *l, *r;
+      } i, o;
+    } port;
+
+    struct {
+      struct {
+	ringb_float_t *l, *r;
+      } i, o;
+    } ring;
+
+  } snds;
+
+  // update io
+  // multiprocessing & synchronization
+  struct {
+    struct {
+      pthread_t id;
+    } mtr, pws, trx, upd;
+  } thrd;
+
+  struct {
+    struct {
+      sem_t *sem;
+      char name[512];
+    } buf, mtr, pws, upd;
+  } sync;
+
+  // TRX switching
+  struct {
+    struct {
+      struct {
+	SWCHSTATE type;
+	int cnt;
+	REAL val;
+      } curr;
+      struct {
+	int size;
+	REAL incr;
+      } fall, rise, stdy;
+    } env;
+    struct {
+      TRXMODE next;
+    } trx;
+    struct {
+      RUNMODE last;
+    } run;
+  } swch;
+
+  BOOLEAN susp;
+
+  // test signals
+  struct {
+
+    struct {
+      OSC gen;
+      REAL amp, freq;
+    } tone;
+
+    struct {
+      struct {
+	OSC gen;
+	REAL amp, freq;
+      } a, b;
+    } twotone;
+
+#ifdef notdef
+    struct {
+    } chirp;
+#endif
+
+    struct {
+      REAL amp;
+    } noise;
+
+    TESTMODE mode;
+    BOOLEAN thru;
+  } test;
+
+} *top;
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/keyboard-keyer.c
@@ -0,0 +1,676 @@
+/** 
+* @file keyboard-keyer.c
+* @brief Functions to implement a keyboard keyer
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/  
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+#define SAMP_RATE (48000)
+#define HUGE_PHASE (1256637061.43593)
+
+#define RING_SIZE (01 << 022)
+
+pthread_t input, play;
+sem_t ready, reader, writer;
+
+jack_client_t *client;
+jack_port_t *lport, *rport;
+jack_ringbuffer_t *lring, *rring;
+jack_nframes_t size;
+
+BOOLEAN playing = FALSE;
+double wpm = 18.0, freq = 750.0, gain = -6.0, ramp = 5.0;
+
+COMPLEX *zout = 0;
+
+/// basic mapping, chars -> morse strings
+char *morse_table[128];
+
+// CW tone segments
+#define ME_EOF (-1)
+#define ME_ZERO (0)
+#define ME_RAMP (1)
+#define ME_STDY (2)
+
+struct {
+  double wpm, rise, fall, curr, incr, rate;
+  int type, size;
+} morsel;
+
+int ditspacesize, dahspacesize,
+    ditstdysize, dahstdysize,
+    charspacesize, wordspacesize,
+    risesize, fallsize;
+double riseincr, fallincr;
+
+#define MAX_ESC (512)
+#define ESC_L '<'
+#define ESC_R '>'
+
+void inlinecmd(char *, int);
+
+void jack_ringbuffer_clear(jack_ringbuffer_t *, int);
+void jack_ringbuffer_restart(jack_ringbuffer_t *, int);
+void send_sound(COMPLEX *, int);
+
+//------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get morse from hash table
+* 
+* try to map char -> morse string
+*
+* @param c 
+* @return *char
+*/
+/* ---------------------------------------------------------------------------- */
+char *
+get_morse(int c) {
+  return morse_table[c & 0x7F];
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run reader thread
+*
+* translate text input to timed, sub-morse-element
+* audio segment specs; parcel the segments out
+* one at a time to the sound player
+*
+* @return void
+*
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reader_thread(void) {
+  BOOLEAN b = TRUE; // we're coming from silence
+  int c, e;
+  char *m;
+  
+  // keep reading 1 char at a time
+  while ((c = getchar()) != EOF) {
+    
+    // inline command?
+    if (c == ESC_L) {
+      int i = 0;
+      char buf[MAX_ESC];
+      while ((c = getchar()) != EOF) {
+	if (c == ESC_R) break;
+	buf[i] = c;
+	if (++i >= (MAX_ESC - 1)) break;
+      }
+      if (c == EOF) goto finish;
+      buf[i] = 0;
+      inlinecmd(buf, i);
+      continue;
+    }
+
+    /// is char mapped to morse?
+    if (m = get_morse(c)) {
+      
+      // yup
+      /// for each element in morse string
+      // (dit/dah, doesn't matter)
+      while (e = *m++) {
+	// first segment is ramp up...
+	sem_wait(&reader);
+	morsel.type = ME_RAMP, morsel.size = risesize;
+	morsel.curr = 0.0, morsel.incr = riseincr;
+	sem_post(&writer);
+	
+	// ...then steady state...
+	// (choose dit/dah here)
+	sem_wait(&reader);
+	morsel.type = ME_STDY;
+	morsel.size = e == '.' ? ditstdysize : dahstdysize;
+	sem_post(&writer);
+	
+	// ...then ramp down...
+	sem_wait(&reader);
+	morsel.type = ME_RAMP, morsel.size = fallsize;
+	morsel.curr = 1.0, morsel.incr = fallincr;
+	sem_post(&writer);
+	
+	// ...finally, post-element pause
+	sem_wait(&reader);
+	morsel.type = ME_ZERO;
+	morsel.size = ditspacesize;
+	sem_post(&writer);
+      }
+      
+      // post-character pause
+      sem_wait(&reader);
+      morsel.type = ME_ZERO;
+      // (we already emitted a dit-sized space)
+      morsel.size = charspacesize - ditspacesize;
+      sem_post(&writer);
+      
+      // wherever we go next, it won't have been from silence
+      b = FALSE;
+
+    } else {
+      /// anything else treated as interword space,
+      /// which has only one segment (silence)
+      sem_wait(&reader);
+      morsel.type = ME_ZERO;
+      ///  was previous output also interword space?
+      if (b)
+	// yes, use full duration
+	morsel.size = wordspacesize;
+      else
+	// no, part of duration already played
+	morsel.size = wordspacesize - charspacesize;
+      b = TRUE;
+      sem_post(&writer);
+    }
+  }
+  
+ finish:
+  // indicate EOF on input
+  sem_wait(&reader);
+  morsel.type = ME_EOF;
+  sem_post(&writer);
+  pthread_exit(0);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run sound thread 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+sound_thread(void) {
+  int i, k = 0;
+  double ofreq, scale, phase = 0.0;
+  COMPLEX z, delta_z;
+
+  // keep looking for sub-element segments, one at a time
+  for (;;) {
+
+    // pause for next sub-element segment
+    sem_post(&reader);
+    sem_wait(&writer);
+
+    // no more data?
+    if (morsel.type == ME_EOF)
+      break;
+
+    // requires playing some tone?
+    if (morsel.type != ME_ZERO) {
+      // yes, reset params and
+      // set up CORDIC tone generation
+      ofreq = freq * 2.0 * M_PI / SAMP_RATE;
+      scale = pow(10.0, gain / 20.0);
+      if (phase > HUGE_PHASE)
+	phase -= HUGE_PHASE;
+      z = Cmplx(cos(phase), sin(phase));
+      delta_z = Cmplx(cos(ofreq), sin(ofreq));
+    }
+
+    // play out this segment
+    for (i = 0; i < morsel.size; i++) {
+
+      // make silence
+      if (morsel.type == ME_ZERO)
+	zout[k] = cxzero;
+      
+      // make tone
+      else {
+	z = Cmul(z, delta_z);
+	phase += ofreq;
+	// is this a ramping segment?
+	if (morsel.type == ME_RAMP) {
+	  morsel.curr += morsel.incr;
+	  zout[k] = Cscl(z, scale * sin(morsel.curr * M_PI / 2.0));
+	} else
+	  zout[k] = Cscl(z, scale);
+      }
+
+      // have we played enough to fill a jack buffer?
+      if (++k >= size) {
+	// yes, send to output
+	send_sound(zout, k);
+	// wait until some audio has been drained
+	sem_wait(&ready);
+	k = 0;
+	if (morsel.type != ME_ZERO) {
+	  // reset CORDIC
+	  if (phase > HUGE_PHASE)
+	    phase -= HUGE_PHASE;
+	  z = Cmplx(cos(phase), sin(phase));
+	  delta_z = Cmplx(cos(ofreq), sin(ofreq));
+	}
+      }
+    }
+  }
+
+  // anything left unsent?
+  if (k > 0)
+    send_sound(zout, k);
+
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief  Clear jack ring bufferr 
+* 
+* @param ring 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+jack_ringbuffer_clear(jack_ringbuffer_t *ring, int nbytes) {
+  int i;
+  char zero = 0;
+  for (i = 0; i < nbytes; i++)
+    jack_ringbuffer_write(ring, &zero, 1);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Restart jack ring buffer 
+* 
+* @param ring 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+jack_ringbuffer_restart(jack_ringbuffer_t *ring, int nbytes) {
+  jack_ringbuffer_reset(ring);
+  jack_ringbuffer_clear(ring, nbytes);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Send sound jack buffer 
+* 
+* @param buff 
+* @param len 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+send_sound(COMPLEX *buff, int len) {
+  if (jack_ringbuffer_write_space(lring) < len * sizeof(float)) {
+    write(2, "overrun\n", 8);
+    jack_ringbuffer_restart(lring, size * sizeof(float));
+    jack_ringbuffer_restart(rring, size * sizeof(float));
+  } else {
+    int i;
+    for (i = 0; i < len; i++) {
+      float l = buff[i].re, r = buff[i].im;
+      jack_ringbuffer_write(lring, (char *) &l, sizeof(float));
+      jack_ringbuffer_write(rring, (char *) &r, sizeof(float));
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private jack_xrun 
+* 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_xrun(void *arg) {
+  char *str = "xrun!\n";
+  write(2, str, strlen(str));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private jack_shutdown 
+* 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_shutdown(void *arg) {}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private jack_callback 
+* 
+* @param nframes 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_callback(jack_nframes_t nframes, void *arg) {
+  char *lp, *rp;
+  int nwant = nframes * sizeof(float),
+      nhave = jack_ringbuffer_read_space(lring);
+
+  lp = jack_port_get_buffer(lport, nframes);
+  rp = jack_port_get_buffer(rport, nframes);
+  if (nhave >= nwant) {
+    jack_ringbuffer_read(lring, lp, nwant);
+    jack_ringbuffer_read(rring, rp, nwant);
+    sem_post(&ready);
+  } else {
+    memset(lp, 0, nwant);
+    memset(rp, 0, nwant);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset parameter on keyer  
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+resetparam(void) {
+  morsel.wpm = wpm;
+  morsel.rise = morsel.fall = ramp;
+  morsel.rate = SAMP_RATE;
+
+  ditspacesize = SAMP_RATE * 1.2 / morsel.wpm + 0.5;
+  dahspacesize = 3 * ditspacesize;
+  charspacesize = dahspacesize;
+  wordspacesize = 7 * ditspacesize;
+
+  risesize = SAMP_RATE * morsel.rise / 1e3 + 0.5;
+  if (risesize > 1)
+    riseincr = 1.0 / (risesize - 1);
+  else
+    riseincr = 1.0;
+
+  fallsize = SAMP_RATE * morsel.fall / 1e3 + 0.5;
+  if (fallsize > 1)
+    fallincr = -1.0 / (fallsize - 1);
+  else
+    fallincr = -1.0;
+
+  ditstdysize = ditspacesize - risesize - fallsize;
+  dahstdysize = dahspacesize - risesize - fallsize;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief main
+* 
+* @param argc 
+* @param *argv 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+main(int argc, char **argv) {
+  int i;
+
+  for (i = 1; i < argc; i++)
+    if (argv[i][0] == '-')
+      switch (argv[i][1]) {
+      case 'f':
+	freq = atof(argv[++i]);
+	break;
+      case 'w':
+	wpm = atof(argv[++i]);
+	break;
+      case 'g':
+	gain = atof(argv[++i]);
+	break;
+      case 'r':
+	ramp = atof(argv[++i]);
+	break;
+      default:
+	fprintf(stderr, "keyboard-keyer [-w wpm] [-f freq] [-g gain_dB] [-r ramp_ms] [infile]\n");
+	exit(1);
+      }
+    else break;
+
+  if (i < argc) {
+    if (!freopen(argv[i], "r", stdin))
+      perror(argv[i]), exit(1);
+    i++;
+  }
+
+  //------------------------------------------------------------
+
+  resetparam();
+
+  //------------------------------------------------------------
+
+  if (!(client = jack_client_new("kkyr")))
+    fprintf(stderr, "can't make client -- jack not running?\n"), exit(1);
+  jack_set_process_callback(client, (void *) jack_callback, 0);
+  jack_on_shutdown(client, (void *) jack_shutdown, 0);
+  jack_set_xrun_callback(client, (void *) jack_xrun, 0);
+  size = jack_get_buffer_size(client);
+
+  lport = jack_port_register(client,
+			     "ol",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  rport = jack_port_register(client,
+			     "or",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  lring = jack_ringbuffer_create(RING_SIZE);
+  rring = jack_ringbuffer_create(RING_SIZE);
+  jack_ringbuffer_clear(lring, size * sizeof(float));
+  jack_ringbuffer_clear(rring, size * sizeof(float));
+  
+  //------------------------------------------------------------
+
+  zout = newvec_COMPLEX(size, "keyb sample buffer");
+
+  //------------------------------------------------------------
+
+  sem_init(&ready, 0, 0);
+  sem_init(&reader, 0, 0);
+  sem_init(&writer, 0, 0);
+  pthread_create(&input, 0, (void *) reader_thread, 0);
+  pthread_create(&play, 0, (void *) sound_thread, 0);
+
+  //------------------------------------------------------------
+
+  jack_activate(client);
+  {
+    const char **ports;
+    if (!(ports = jack_get_ports(client, 0, 0, JackPortIsPhysical | JackPortIsInput))) {
+      fprintf(stderr, "can't find any physical playback ports\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(lport), ports[0])) {
+      fprintf(stderr, "can't connect left output\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(rport), ports[1])) {
+      fprintf(stderr, "can't connect right output\n");
+      exit(1);
+    }
+    free(ports);
+  }
+
+  pthread_join(input, 0);
+  pthread_join(play, 0);
+  jack_client_close(client);
+
+  //------------------------------------------------------------
+
+  delvec_COMPLEX(zout);
+
+  //------------------------------------------------------------
+
+  jack_ringbuffer_free(lring);
+  jack_ringbuffer_free(rring);
+  sem_destroy(&ready);
+  sem_destroy(&reader);
+  sem_destroy(&writer);
+
+  //------------------------------------------------------------
+
+  exit(0);
+}
+
+char *morse_table[128] = {
+  /* 000 NUL */ 0, /* 001 SOH */ 0, /* 002 STX */ 0, /* 003 ETX */ 0,
+  /* 004 EOT */ 0, /* 005 ENQ */ 0, /* 006 ACK */ 0, /* 007 BEL */ 0,
+  /* 008  BS */ 0, /* 009  HT */ 0, /* 010  LF */ 0, /* 011  VT */ 0,
+  /* 012  FF */ 0, /* 013  CR */ 0, /* 014  SO */ 0, /* 015  SI */ 0,
+  /* 016 DLE */ 0, /* 017 DC1 */ 0, /* 018 DC2 */ 0, /* 019 DC3 */ 0,
+  /* 020 DC4 */ 0, /* 021 NAK */ 0, /* 022 SYN */ 0, /* 023 ETB */ 0,
+  /* 024 CAN */ 0, /* 025  EM */ 0, /* 026 SUB */ 0, /* 027 ESC */ 0,
+  /* 028  FS */ 0, /* 029  GS */ 0, /* 030  RS */ 0, /* 031  US */ 0,
+  /* 032  SP */ 0,
+  /* 033   ! */ "...-.",	// [SN]
+  /* 034   " */ 0,
+  /* 035   # */ 0,
+  /* 036   $ */ 0,
+  /* 037   % */ ".-...",	// [AS]
+  /* 038   & */ 0,
+  /* 039   ' */ 0,
+  /* 040   ( */ "-.--.",	// [KN]
+  /* 041   ) */ 0,
+  /* 042   * */ "...-.-",	// [SK]
+  /* 043   + */ ".-.-.",	// [AR]
+  /* 044   , */ "--..--",
+  /* 045   - */ "-....-",
+  /* 046   . */ ".-.-.-",
+  /* 047   / */ "-..-.",
+  /* 048   0 */ "-----",
+  /* 049   1 */ ".----",
+  /* 050   2 */ "..---",
+  /* 051   3 */ "...--",
+  /* 052   4 */ "....-",
+  /* 053   5 */ ".....",
+  /* 054   6 */ "-....",
+  /* 055   7 */ "--...",
+  /* 056   8 */ "---..",
+  /* 057   9 */ "----.",
+  /* 058   : */ 0,
+  /* 059   ; */ 0,
+  /* 060   < */ 0,
+  /* 061   = */ "-...-",	// [BT]
+  /* 062   > */ 0,
+  /* 063   ? */ "..__..",	// [IMI]
+  /* 064   @ */ ".--.-.",
+  /* 065   A */ ".-",
+  /* 066   B */ "-...",
+  /* 067   C */ "-.-.",
+  /* 068   D */ "-..",
+  /* 069   E */ ".",
+  /* 070   F */ "..-.",
+  /* 071   G */ "--.",
+  /* 072   H */ "....",
+  /* 073   I */ "..",
+  /* 074   J */ ".---",
+  /* 075   K */ "-.-",
+  /* 076   L */ ".-..",
+  /* 077   M */ "--",
+  /* 078   N */ "-.",
+  /* 079   O */ "---",
+  /* 080   P */ ".--.",
+  /* 081   Q */ "--.-",
+  /* 082   R */ ".-.",
+  /* 083   S */ "...",
+  /* 084   T */ "-",
+  /* 085   U */ "..-",
+  /* 086   V */ "...-",
+  /* 087   W */ ".--",
+  /* 088   X */ "-..-",
+  /* 089   Y */ "-.--",
+  /* 090   Z */ "--..",
+  /* 091   [ */ 0,
+  /* 092   \ */ 0,
+  /* 093   ] */ 0,
+  /* 094   ^ */ 0,
+  /* 095   _ */ 0,
+  /* 096   ` */ 0,
+  /* 097   a */ ".-",
+  /* 098   b */ "-...",
+  /* 099   c */ "-.-.",
+  /* 100   d */ "-..",
+  /* 101   e */ ".",
+  /* 102   f */ "..-.",
+  /* 103   g */ "--.",
+  /* 104   h */ "....",
+  /* 105   i */ "..",
+  /* 106   j */ ".---",
+  /* 107   k */ "-.-",
+  /* 108   l */ ".-..",
+  /* 109   m */ "--",
+  /* 110   n */ "-.",
+  /* 111   o */ "---",
+  /* 112   p */ ".--.",
+  /* 113   q */ "--.-",
+  /* 114   r */ ".-.",
+  /* 115   s */ "...",
+  /* 116   t */ "-",
+  /* 117   u */ "..-",
+  /* 118   v */ "...-",
+  /* 119   w */ ".--",
+  /* 120   x */ "-..-",
+  /* 121   y */ "-.--",
+  /* 122   z */ "--..",
+  /* 123   { */ 0,
+  /* 124   | */ 0,
+  /* 125   } */ 0,
+  /* 126   ~ */ 0,
+  /* 127 DEL */ 0
+};
+
+/* -------------------------------------------------------------------------- */
+/** @brief inline command 
+* 
+* @param buf 
+* @param len 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+inlinecmd(char *buf, int len) {
+  if (!buf || len < 1) return;
+  if (!strncmp(buf, "wpm", 3)) {
+    wpm = atof(buf + 3);
+    resetparam();
+  } else if (!strncmp(buf, "ramp", 4)) {
+    ramp = atof(buf + 4);
+    resetparam();
+  } else if (!strncmp(buf, "freq", 4))
+    freq = atof(buf + 4);
+  else if (!strncmp(buf, "gain", 4))
+    gain = atof(buf + 4);
+}
--- /dev/null
+++ dttsp-0~svn675/configure
@@ -0,0 +1,6247 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.67 for dttsp new.
+#
+# Report bugs to <ab2kt@arrl.net> or <rwmcgwier@gmail.com>.
+#
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# Foundation, Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org and ab2kt@arrl.net> or
+$0: <rwmcgwier@gmail.com about your system, including any
+$0: error possibly output before this message. Then install
+$0: a modern shell, or manually run the script under such a
+$0: shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='dttsp'
+PACKAGE_TARNAME='dttsp'
+PACKAGE_VERSION='new'
+PACKAGE_STRING='dttsp new'
+PACKAGE_BUGREPORT='ab2kt@arrl.net> or <rwmcgwier@gmail.com'
+PACKAGE_URL=''
+
+ac_unique_file="am_demod.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='am__EXEEXT_FALSE
+am__EXEEXT_TRUE
+LTLIBOBJS
+LIBOBJS
+EGREP
+GREP
+CPP
+RANLIB
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_dependency_tracking
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used" >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures dttsp new to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/dttsp]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of dttsp new:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <ab2kt@arrl.net> or <rwmcgwier@gmail.com>.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+dttsp configure new
+generated by GNU Autoconf 2.67
+
+Copyright (C) 2010 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if eval "test \"\${$3+set}\"" = set; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+( $as_echo "## ------------------------------------------------------ ##
+## Report this to ab2kt@arrl.net> or <rwmcgwier@gmail.com ##
+## ------------------------------------------------------ ##"
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_mongrel
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
+# -------------------------------------------
+# Tests whether TYPE exists after having included INCLUDES, setting cache
+# variable VAR accordingly.
+ac_fn_c_check_type ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof ($2))
+	 return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof (($2)))
+	    return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  eval "$3=yes"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_type
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_func
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by dttsp $as_me new, which was
+generated by GNU Autoconf 2.67.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5 ; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+#AM_INIT_AUTOMAKE([-Wall -Werror foreign])
+#AM_INIT_AUTOMAKE([-Werror foreign])
+am__api_version='1.11'
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5 ;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5 ;;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error $? "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if test "${ac_cv_path_mkdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  test -d ./--version && rmdir ./--version
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\"" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='dttsp'
+ VERSION='new'
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+
+#AC_CONFIG_HEADER([config.h])
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5 ;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5 ;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+
+# Checks for programs.
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5 ; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+if test -z "$ac_file"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5 ; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5 ; }
+fi
+rm -f conftest conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details" "$LINENO" 5 ; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5 ; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+if test $host_cpu = "powerpc" && test $host_vendor = "apple"; then
+
+		CFLAGS="$CFLAGS -I/sw/include"
+	LDFLAGS="$LDFLAGS -L/sw/lib"
+	CPPFLAGS="$CPPFLAGS -I/sw/include"
+fi
+
+# Checks for libraries.
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_execute in -lfftw3f" >&5
+$as_echo_n "checking for fftwf_execute in -lfftw3f... " >&6; }
+if test "${ac_cv_lib_fftw3f_fftwf_execute+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfftw3f  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fftwf_execute ();
+int
+main ()
+{
+return fftwf_execute ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_fftw3f_fftwf_execute=yes
+else
+  ac_cv_lib_fftw3f_fftwf_execute=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_execute" >&5
+$as_echo "$ac_cv_lib_fftw3f_fftwf_execute" >&6; }
+if test "x$ac_cv_lib_fftw3f_fftwf_execute" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBFFTW3F 1
+_ACEOF
+
+  LIBS="-lfftw3f $LIBS"
+
+else
+  as_fn_error $? "\"Could not find library fftw3f.\"" "$LINENO" 5
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for jack_connect in -ljack" >&5
+$as_echo_n "checking for jack_connect in -ljack... " >&6; }
+if test "${ac_cv_lib_jack_jack_connect+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ljack  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char jack_connect ();
+int
+main ()
+{
+return jack_connect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_jack_jack_connect=yes
+else
+  ac_cv_lib_jack_jack_connect=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jack_jack_connect" >&5
+$as_echo "$ac_cv_lib_jack_jack_connect" >&6; }
+if test "x$ac_cv_lib_jack_jack_connect" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBJACK 1
+_ACEOF
+
+  LIBS="-ljack $LIBS"
+
+else
+  as_fn_error $? "\"Could not find library jack.\"" "$LINENO" 5
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pow in -lm" >&5
+$as_echo_n "checking for pow in -lm... " >&6; }
+if test "${ac_cv_lib_m_pow+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pow ();
+int
+main ()
+{
+return pow ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_m_pow=yes
+else
+  ac_cv_lib_m_pow=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_pow" >&5
+$as_echo "$ac_cv_lib_m_pow" >&6; }
+if test "x$ac_cv_lib_m_pow" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthread" >&5
+$as_echo_n "checking for pthread_create in -lpthread... " >&6; }
+if test "${ac_cv_lib_pthread_pthread_create+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpthread  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pthread_create ();
+int
+main ()
+{
+return pthread_create ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pthread_pthread_create=yes
+else
+  ac_cv_lib_pthread_pthread_create=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_create" >&5
+$as_echo "$ac_cv_lib_pthread_pthread_create" >&6; }
+if test "x$ac_cv_lib_pthread_pthread_create" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBPTHREAD 1
+_ACEOF
+
+  LIBS="-lpthread $LIBS"
+
+fi
+
+
+# Checks for header files.
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5 ; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sys/wait.h that is POSIX.1 compatible" >&5
+$as_echo_n "checking for sys/wait.h that is POSIX.1 compatible... " >&6; }
+if test "${ac_cv_header_sys_wait_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+int
+main ()
+{
+  int s;
+  wait (&s);
+  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_sys_wait_h=yes
+else
+  ac_cv_header_sys_wait_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_sys_wait_h" >&5
+$as_echo "$ac_cv_header_sys_wait_h" >&6; }
+if test $ac_cv_header_sys_wait_h = yes; then
+
+$as_echo "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in fcntl.h stdlib.h string.h sys/ioctl.h sys/param.h sys/socket.h sys/time.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# Checks for typedefs, structures, and compiler characteristics.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
+$as_echo_n "checking for an ANSI C-conforming const... " >&6; }
+if test "${ac_cv_c_const+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset cs;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_const=yes
+else
+  ac_cv_c_const=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_const" >&5
+$as_echo "$ac_cv_c_const" >&6; }
+if test $ac_cv_c_const = no; then
+
+$as_echo "#define const /**/" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
+$as_echo_n "checking for inline... " >&6; }
+if test "${ac_cv_c_inline+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_inline=$ac_kw
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
+$as_echo "$ac_cv_c_inline" >&6; }
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
+if test "x$ac_cv_type_size_t" = x""yes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned int
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether time.h and sys/time.h may both be included" >&5
+$as_echo_n "checking whether time.h and sys/time.h may both be included... " >&6; }
+if test "${ac_cv_header_time+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+int
+main ()
+{
+if ((struct tm *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_time=yes
+else
+  ac_cv_header_time=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_time" >&5
+$as_echo "$ac_cv_header_time" >&6; }
+if test $ac_cv_header_time = yes; then
+
+$as_echo "#define TIME_WITH_SYS_TIME 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for stdbool.h that conforms to C99" >&5
+$as_echo_n "checking for stdbool.h that conforms to C99... " >&6; }
+if test "${ac_cv_header_stdbool_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stdbool.h>
+#ifndef bool
+ "error: bool is not defined"
+#endif
+#ifndef false
+ "error: false is not defined"
+#endif
+#if false
+ "error: false is not 0"
+#endif
+#ifndef true
+ "error: true is not defined"
+#endif
+#if true != 1
+ "error: true is not 1"
+#endif
+#ifndef __bool_true_false_are_defined
+ "error: __bool_true_false_are_defined is not defined"
+#endif
+
+	struct s { _Bool s: 1; _Bool t; } s;
+
+	char a[true == 1 ? 1 : -1];
+	char b[false == 0 ? 1 : -1];
+	char c[__bool_true_false_are_defined == 1 ? 1 : -1];
+	char d[(bool) 0.5 == true ? 1 : -1];
+	bool e = &s;
+	char f[(_Bool) 0.0 == false ? 1 : -1];
+	char g[true];
+	char h[sizeof (_Bool)];
+	char i[sizeof s.t];
+	enum { j = false, k = true, l = false * true, m = true * 256 };
+	/* The following fails for
+	   HP aC++/ANSI C B3910B A.05.55 [Dec 04 2003]. */
+	_Bool n[m];
+	char o[sizeof n == m * sizeof n[0] ? 1 : -1];
+	char p[-1 - (_Bool) 0 < 0 && -1 - (bool) 0 < 0 ? 1 : -1];
+#	if defined __xlc__ || defined __GNUC__
+	 /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0
+	    reported by James Lemley on 2005-10-05; see
+	    http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html
+	    This test is not quite right, since xlc is allowed to
+	    reject this program, as the initializer for xlcbug is
+	    not one of the forms that C requires support for.
+	    However, doing the test right would require a runtime
+	    test, and that would make cross-compilation harder.
+	    Let us hope that IBM fixes the xlc bug, and also adds
+	    support for this kind of constant expression.  In the
+	    meantime, this test will reject xlc, which is OK, since
+	    our stdbool.h substitute should suffice.  We also test
+	    this with GCC, where it should work, to detect more
+	    quickly whether someone messes up the test in the
+	    future.  */
+	 char digs[] = "0123456789";
+	 int xlcbug = 1 / (&(digs + 5)[-2 + (bool) 1] == &digs[4] ? 1 : -1);
+#	endif
+	/* Catch a bug in an HP-UX C compiler.  See
+	   http://gcc.gnu.org/ml/gcc-patches/2003-12/msg02303.html
+	   http://lists.gnu.org/archive/html/bug-coreutils/2005-11/msg00161.html
+	 */
+	_Bool q = true;
+	_Bool *pq = &q;
+
+int
+main ()
+{
+
+	*pq |= q;
+	*pq |= ! q;
+	/* Refer to every declared value, to avoid compiler optimizations.  */
+	return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
+		+ !m + !n + !o + !p + !q + !pq);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdbool_h=yes
+else
+  ac_cv_header_stdbool_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdbool_h" >&5
+$as_echo "$ac_cv_header_stdbool_h" >&6; }
+ac_fn_c_check_type "$LINENO" "_Bool" "ac_cv_type__Bool" "$ac_includes_default"
+if test "x$ac_cv_type__Bool" = x""yes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE__BOOL 1
+_ACEOF
+
+
+fi
+
+if test $ac_cv_header_stdbool_h = yes; then
+
+$as_echo "#define HAVE_STDBOOL_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for uid_t in sys/types.h" >&5
+$as_echo_n "checking for uid_t in sys/types.h... " >&6; }
+if test "${ac_cv_type_uid_t+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "uid_t" >/dev/null 2>&1; then :
+  ac_cv_type_uid_t=yes
+else
+  ac_cv_type_uid_t=no
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_uid_t" >&5
+$as_echo "$ac_cv_type_uid_t" >&6; }
+if test $ac_cv_type_uid_t = no; then
+
+$as_echo "#define uid_t int" >>confdefs.h
+
+
+$as_echo "#define gid_t int" >>confdefs.h
+
+fi
+
+
+# Checks for library functions.
+if test $ac_cv_c_compiler_gnu = yes; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC needs -traditional" >&5
+$as_echo_n "checking whether $CC needs -traditional... " >&6; }
+if test "${ac_cv_prog_gcc_traditional+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sgtty.h>
+Autoconf TIOCGETP
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then :
+  ac_cv_prog_gcc_traditional=yes
+else
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <termio.h>
+Autoconf TCGETA
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then :
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_gcc_traditional" >&5
+$as_echo "$ac_cv_prog_gcc_traditional" >&6; }
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat correctly handles trailing slash" >&5
+$as_echo_n "checking whether lstat correctly handles trailing slash... " >&6; }
+if test "${ac_cv_func_lstat_dereferences_slashed_symlink+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f conftest.sym conftest.file
+echo >conftest.file
+if test "$as_ln_s" = "ln -s" && ln -s conftest.file conftest.sym; then
+  if test "$cross_compiling" = yes; then :
+  ac_cv_func_lstat_dereferences_slashed_symlink=no
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+struct stat sbuf;
+     /* Linux will dereference the symlink and fail, as required by POSIX.
+	That is better in the sense that it means we will not
+	have to compile and use the lstat wrapper.  */
+     return lstat ("conftest.sym/", &sbuf) == 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_func_lstat_dereferences_slashed_symlink=yes
+else
+  ac_cv_func_lstat_dereferences_slashed_symlink=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+else
+  # If the `ln -s' command failed, then we probably don't even
+  # have an lstat function.
+  ac_cv_func_lstat_dereferences_slashed_symlink=no
+fi
+rm -f conftest.sym conftest.file
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_lstat_dereferences_slashed_symlink" >&5
+$as_echo "$ac_cv_func_lstat_dereferences_slashed_symlink" >&6; }
+
+test $ac_cv_func_lstat_dereferences_slashed_symlink = yes &&
+
+cat >>confdefs.h <<_ACEOF
+#define LSTAT_FOLLOWS_SLASHED_SYMLINK 1
+_ACEOF
+
+
+if test "x$ac_cv_func_lstat_dereferences_slashed_symlink" = xno; then
+  case " $LIBOBJS " in
+  *" lstat.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lstat.$ac_objext"
+ ;;
+esac
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stat accepts an empty string" >&5
+$as_echo_n "checking whether stat accepts an empty string... " >&6; }
+if test "${ac_cv_func_stat_empty_string_bug+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then :
+  ac_cv_func_stat_empty_string_bug=yes
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+struct stat sbuf;
+  return stat ("", &sbuf) == 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_func_stat_empty_string_bug=no
+else
+  ac_cv_func_stat_empty_string_bug=yes
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_stat_empty_string_bug" >&5
+$as_echo "$ac_cv_func_stat_empty_string_bug" >&6; }
+if test $ac_cv_func_stat_empty_string_bug = yes; then
+  case " $LIBOBJS " in
+  *" stat.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS stat.$ac_objext"
+ ;;
+esac
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STAT_EMPTY_STRING_BUG 1
+_ACEOF
+
+fi
+
+for ac_func in floor gettimeofday memset pow sqrt
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+ac_script='
+:mline
+/\\$/{
+ N
+ s,\\\n,,
+ b mline
+}
+t clear
+:clear
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+b any
+:quote
+s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
+s/\[/\\&/g
+s/\]/\\&/g
+s/\$/$$/g
+H
+:any
+${
+	g
+	s/^\n//
+	s/\n/ /g
+	p
+}
+'
+DEFS=`sed -n "$ac_script" confdefs.h`
+
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+ if test -n "$EXEEXT"; then
+  am__EXEEXT_TRUE=
+  am__EXEEXT_FALSE='#'
+else
+  am__EXEEXT_TRUE='#'
+  am__EXEEXT_FALSE=
+fi
+
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by dttsp $as_me new, which was
+generated by GNU Autoconf 2.67.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Configuration commands:
+$config_commands
+
+Report bugs to <ab2kt@arrl.net> or <rwmcgwier@gmail.com>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+dttsp config.status new
+configured by $0, generated by GNU Autoconf 2.67,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2010 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h |  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5 ;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
+s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+
+eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5 ;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5 ;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5  ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ ;;
+
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
--- /dev/null
+++ dttsp-0~svn675/filterbank.c
@@ -0,0 +1,198 @@
+/** 
+* @file filterbank.c
+* @brief Functions to implement a filter bank 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <filterbank.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new filter bank 
+* 
+* @param SampleRate 
+* @param ChangeRatio 
+* @param Analysis 
+* @param StopbandAttenuation 
+* @param TransitionBandwidth 
+* @param databuf 
+* @param lp 
+* @param wisdombits 
+*/
+/* ---------------------------------------------------------------------------- */
+FilterBank
+newFilterBank(REAL SampleRate,
+	      int ChangeRatio,
+	      BOOLEAN Analysis,
+	      REAL StopbandAttenuation,
+	      REAL TransitionBandwidth,
+	      COMPLEX *databuf,
+	      RealFIR lp,
+	      int wisdombits)
+{
+  FilterBank fbtmp;
+
+  fbtmp = (FilterBank) safealloc(1, sizeof(FilterBankDesc), "FilterBank");
+  int FilterSize;
+  REAL cutoff;
+  fbtmp->MyFilt = FALSE;
+  gsl_vector_float_view old, new;
+  if (floor(SampleRate / ChangeRatio) != (SampleRate / ChangeRatio)) {
+    perror("Partitions must divide Sample Rate");
+    exit(1);
+  } else {
+    if (!lp) {	// Filter was NOT passed in, we need to calculate
+      FilterSize =
+	pow(10.0, StopbandAttenuation / 20.0) *
+	TransitionBandwidth / (22.0 * SampleRate);
+      fbtmp->MyFilt = TRUE;
+      cutoff = (SampleRate - 0.5 * TransitionBandwidth) / ChangeRatio;
+
+      // needed to partition the filter.  You round up to have the
+      // same number of of columns and the filter can be zero stuffed
+      // if you want a specific filter.
+      FilterSize = fbtmp->Partitions * fbtmp->Columns;
+      fbtmp->fbfil = newFIR_Lowpass_REAL(cutoff, SampleRate, FilterSize);	// Make a real low pass filter for Analysis 
+    } else {
+      FilterSize = lp->size;
+      fbtmp->fbfil = lp;
+    }
+    // ChangeRatio gives the number of bands
+    fbtmp->Partitions = ChangeRatio;
+    // The filtersize determines the number of columns
+    fbtmp->Columns = ceil(FilterSize / fbtmp->Partitions);
+  }
+  fbtmp->out = (gsl_complex_float *) databuf;
+  fbtmp->in  = (gsl_complex_float *) safealloc(1, sizeof(COMPLEX *),
+					       "FB analysis fft iput buffer");
+  if (Analysis) {
+    int index;
+    fbtmp->databuf = (gsl_complex_float *) databuf;
+    fbtmp->gvcf.data = (float *) databuf;
+    fbtmp->gvcf.size = fbtmp->Partitions;
+    fbtmp->gvcf.stride = 1;
+    fbtmp->gvcf.block = (gsl_block_complex_float *) databuf;
+    fbtmp->gvcf.owner = 0;
+    fbtmp->filter_partition =
+      (gsl_matrix_float *) gsl_matrix_float_calloc(fbtmp->Partitions,
+						   fbtmp->Columns);
+    fbtmp->data_partition =
+      (gsl_matrix_complex_float *) gsl_matrix_complex_float_calloc(fbtmp->Partitions,
+								   fbtmp->Columns);
+    fbtmp->old =
+      gsl_matrix_complex_float_submatrix(fbtmp->data_partition, 0, 0,
+					 fbtmp->Partitions,
+					 fbtmp->Columns - 1);
+    fbtmp->new =
+      gsl_matrix_complex_float_submatrix(fbtmp->data_partition, 0, 1,
+					 fbtmp->Partitions, fbtmp->Columns);
+
+    //  FFT performs channel construction and alias elimination
+    fbtmp->fb_fft = fftwf_plan_dft_1d(fbtmp->Partitions,
+				      (fftwf_complex *) fbtmp->in,
+				      (fftwf_complex *) fbtmp->out,
+				      FFTW_MEASURE | FFTW_FORWARD,
+				      wisdombits);
+
+
+    // Partition the filter here
+    for (index = 0; index < FilterSize; index++) {
+      int i_index, j_index;
+      i_index = index % fbtmp->Partitions;
+      j_index = (index - i_index) / fbtmp->Partitions;
+      gsl_matrix_float_set(fbtmp->filter_partition,
+			   i_index,
+			   j_index,
+			   fbtmp->fbfil->coef[index]);
+    }
+  } else {
+    // Synthesis
+  }
+  return fbtmp;
+}
+
+// Filterbank in this form is called ONCE with a vector of complex
+// samples "Partitions" long and the same vector returns the filter
+// bank of downsampled and shifted bins filtered by the partitioned
+// low pass filter.
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run Analysis Filter Bank 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+runAnalysisFilterBank(FilterBank p)
+{
+  size_t i, j;
+  for (i = 0; i < p->Partitions; i++)
+    gsl_matrix_complex_float_set(p->data_partition, i, 0, p->databuf[i]);
+  for (i = 0; i < p->Partitions; i++) {
+    float tmp;
+    gsl_complex_float tmpz;
+    gsl_complex_float *datptr = &p->in[i];
+    tmp = gsl_matrix_float_get(p->filter_partition, i, 0);
+    tmpz = gsl_matrix_complex_float_get(p->data_partition, i, 0);
+    GSL_SET_COMPLEX(datptr, GSL_REAL(tmpz) * tmp, GSL_IMAG(tmpz) * tmp);	// initialize sum for filter partition
+    for (j = 0; j < p->Columns; j++) {
+      tmp = gsl_matrix_float_get(p->filter_partition, i, j);
+      tmpz = gsl_matrix_complex_float_get(p->data_partition, i, j);
+      datptr->dat[0] += tmp * tmpz.dat[0];
+      datptr->dat[1] += tmp * tmpz.dat[1];
+    }
+  }
+  fftwf_execute(p->fb_fft);
+  for (i = 0; i < p->Partitions; i++)
+    for (j = p->Columns - 2; j >= 0; j--) {}
+  // Copy the submatrices in the correct order for the partitions.
+  // REPLACE WITH CIRCULAR BUFFERS!!!!
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete Filter Bank 
+* 
+* @param p 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delFilterBank(FilterBank p)
+{
+  if (p->MyFilt)
+    delFIR_REAL(p->fbfil);
+  fftwf_destroy_plan(p->fb_fft);
+  gsl_matrix_float_free(p->filter_partition);
+  gsl_matrix_complex_float_free(p->data_partition);
+  safefree((char *) p->in);
+  safefree((char *) p);
+}
--- /dev/null
+++ dttsp-0~svn675/missing
@@ -0,0 +1,376 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2009-04-28.21; # UTC
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006,
+# 2008, 2009 Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+run=:
+sed_output='s/.* --output[ =]\([^ ]*\).*/\1/p'
+sed_minuso='s/.* -o \([^ ]*\).*/\1/p'
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg="missing on your system"
+
+case $1 in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg="probably too old"
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  autom4te     touch the output file, or create a stub one
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Version suffixes to PROGRAM as well as the prefixes \`gnu-', \`gnu', and
+\`g' are ignored when checking the name.
+
+Send bug reports to <bug-automake@gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# normalize program name to check for.
+program=`echo "$1" | sed '
+  s/^gnu-//; t
+  s/^gnu//; t
+  s/^g//; t'`
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).  This is about non-GNU programs, so use $1 not
+# $program.
+case $1 in
+  lex*|yacc*)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar*)
+    if test -n "$run"; then
+       echo 1>&2 "ERROR: \`tar' requires --run"
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case $program in
+  aclocal*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case $f in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  autom4te*)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison*|yacc*)
+    echo 1>&2 "\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f y.tab.h; then
+	echo >y.tab.h
+    fi
+    if test ! -f y.tab.c; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex*|flex*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f lex.yy.c; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  help2man*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit $?
+    fi
+    ;;
+
+  makeinfo*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    # The file to touch is that specified with -o ...
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -z "$file"; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '
+	/^@setfilename/{
+	  s/.* \([^ ]*\) *$/\1/
+	  p
+	  q
+	}' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar*)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case $firstarg in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case $firstarg in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
--- /dev/null
+++ dttsp-0~svn675/waveshape.h
@@ -0,0 +1,56 @@
+// waveshape.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _waveshape_h
+#define _waveshape_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+typedef struct _waveshaper {
+  int npts;
+  REAL *tbl;
+  CXB buff;
+} WaveShaperinfo, *WaveShaper;
+
+extern void WaveShape(WaveShaper wvs);
+extern void setWaveShaper(WaveShaper wvs, int npts, REAL *tbl);
+extern WaveShaper newWaveShaper(CXB buff);
+extern void delWaveShaper(WaveShaper wvs);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/update.c
@@ -0,0 +1,2566 @@
+/** 
+* @file update.c
+* @brief Functions to update radio parameters 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+common defs and code for parm update 
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <common.h>
+
+////////////////////////////////////////////////////////////////////////////
+/// for commands affecting RX, which RX is Listening
+
+#define RL (uni->multirx.lis)
+
+////////////////////////////////////////////////////////////////////////////
+
+/* -------------------------------------------------------------------------- */
+/** @brief private db2lin 
+* 
+* @param dB 
+* @return REAL 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL INLINE
+dB2lin(REAL dB) { return pow(10.0, dB / 20.0); }
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXFilter 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXFilter(int n, char **p) {
+  REAL low_frequency = atof(p[0]),
+       high_frequency = atof(p[1]);
+  int i, ncoef = rx[RL]->len + 1, fftlen = 2 * rx[RL]->len;
+  fftwf_plan ptmp;
+  COMPLEX *zcvec;
+
+  if (fabs(low_frequency) >= 0.5 * uni->rate.sample)
+    return -1;
+  if (fabs(high_frequency) >= 0.5 * uni->rate.sample)
+    return -2;
+  if ((low_frequency + 10) >= high_frequency)
+    return -3;
+  delFIR_COMPLEX(rx[RL]->filt.coef);
+
+#if 0
+  fprintf(stderr, "setRXFilter %f %f\n", low_frequency, high_frequency);
+#endif
+  
+  rx[RL]->filt.coef = newFIR_Bandpass_COMPLEX(low_frequency,
+					      high_frequency,
+					      uni->rate.sample,
+					      ncoef);
+
+  zcvec = newvec_COMPLEX(fftlen, "filter z vec in setFilter");
+  ptmp = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zcvec,
+			   (fftwf_complex *) rx[RL]->filt.ovsv->zfvec,
+			   FFTW_FORWARD,
+			   uni->wisdom.bits);
+#ifdef LHS
+  for (i = 0; i < ncoef; i++)
+    zcvec[i] = rx[RL]->filt.coef->coef[i];
+#else
+  for (i = 0; i < ncoef; i++)
+    zcvec[fftlen - ncoef + i] = rx[RL]->filt.coef->coef[i];
+#endif
+  fftwf_execute(ptmp);
+  fftwf_destroy_plan(ptmp);
+  delvec_COMPLEX(zcvec);
+  normalize_vec_COMPLEX(rx[RL]->filt.ovsv->zfvec, rx[RL]->filt.ovsv->fftlen);
+  memcpy((char *) rx[RL]->filt.save, (char *) rx[RL]->filt.ovsv->zfvec,
+	 rx[RL]->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXFiltCoefs 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXFiltCoefs(int n, char **p) {
+  int i, j, ncoef = rx[RL]->len + 1, fftlen = 2 * rx[RL]->len;
+  fftwf_plan ptmp;
+  COMPLEX *zcvec;
+
+  delFIR_COMPLEX(rx[RL]->filt.coef);
+
+  rx[RL]->filt.coef = newFIR_COMPLEX(ncoef, "setRXFiltCoefs");
+
+  for (i = j = 0; i < ncoef && j < n; i++, j += 2)
+    FIRtap(rx[RL]->filt.coef, i) = Cmplx(atof(p[j]), atof(p[j + 1]));
+  for (; i < ncoef; i++)
+    FIRtap(rx[RL]->filt.coef, i) = cxzero;
+
+  zcvec = newvec_COMPLEX(fftlen, "filter z vec in setFilter");
+  ptmp = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zcvec,
+			   (fftwf_complex *) rx[RL]->filt.ovsv->zfvec,
+			   FFTW_FORWARD,
+			   uni->wisdom.bits);
+
+#ifdef LHS
+  for (i = 0; i < ncoef; i++)
+    zcvec[i] = FIRtap(rx[RL]->filt.coef, i);
+#else
+  for (i = 0; i < ncoef; i++)
+    zcvec[fftlen - ncoef + i] = FIRtap(rx[RL]->filt.coef, i);
+#endif
+
+  fftwf_execute(ptmp);
+  fftwf_destroy_plan(ptmp);
+  delvec_COMPLEX(zcvec);
+  normalize_vec_COMPLEX(rx[RL]->filt.ovsv->zfvec, rx[RL]->filt.ovsv->fftlen);
+  memcpy((char *) rx[RL]->filt.save,
+	 (char *) rx[RL]->filt.ovsv->zfvec,
+	 rx[RL]->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXFilter 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXFilter(int n, char **p) {
+  REAL low_frequency = atof(p[0]),
+       high_frequency = atof(p[1]);
+  int i, ncoef = tx->len + 1, fftlen = 2 * tx->len;
+  fftwf_plan ptmp;
+  COMPLEX *zcvec;
+
+  if (fabs(low_frequency) >= 0.5 * uni->rate.sample)
+    return -1;
+  if (fabs(high_frequency) >= 0.5 * uni->rate.sample)
+    return -2;
+  if ((low_frequency + 10) >= high_frequency)
+    return -3;
+  delFIR_COMPLEX(tx->filt.coef);
+  tx->filt.coef = newFIR_Bandpass_COMPLEX(low_frequency,
+					  high_frequency,
+					  uni->rate.sample,
+					  ncoef);
+
+  zcvec = newvec_COMPLEX(fftlen, "filter z vec in setFilter");
+  ptmp = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zcvec,
+			   (fftwf_complex *) tx->filt.ovsv->zfvec,
+			   FFTW_FORWARD,
+			   uni->wisdom.bits);
+
+#ifdef LHS
+  for (i = 0; i < ncoef; i++)
+    zcvec[i] = tx->filt.coef->coef[i];
+#else
+  for (i = 0; i < ncoef; i++)
+    zcvec[fftlen - ncoef + i] = tx->filt.coef->coef[i];
+#endif
+  fftwf_execute(ptmp);
+  fftwf_destroy_plan(ptmp);
+  delvec_COMPLEX(zcvec);
+  normalize_vec_COMPLEX(tx->filt.ovsv->zfvec, tx->filt.ovsv->fftlen);
+  memcpy((char *) tx->filt.save,
+	 (char *) tx->filt.ovsv->zfvec,
+	 tx->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXFiltCoefs 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXFiltCoefs(int n, char **p) {
+  int i, j, ncoef = tx->len + 1, fftlen = 2 * tx->len;
+  fftwf_plan ptmp;
+  COMPLEX *zcvec;
+
+  delFIR_COMPLEX(tx->filt.coef);
+
+  tx->filt.coef = newFIR_COMPLEX(ncoef, "setRXFiltCoefs");
+
+  for (i = j = 0; i < ncoef && j < n; i++, j += 2)
+    FIRtap(tx->filt.coef, i) = Cmplx(atof(p[j]), atof(p[j + 1]));
+  for (; i < ncoef; i++)
+    FIRtap(tx->filt.coef, i) = cxzero;
+
+  zcvec = newvec_COMPLEX(fftlen, "filter z vec in setFilter");
+  ptmp = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zcvec,
+			   (fftwf_complex *) tx->filt.ovsv->zfvec,
+			   FFTW_FORWARD,
+			   uni->wisdom.bits);
+
+#ifdef LHS
+  for (i = 0; i < ncoef; i++)
+    zcvec[i] = FIRtap(tx->filt.coef, i);
+#else
+  for (i = 0; i < ncoef; i++)
+    zcvec[fftlen - ncoef + i] = FIRtap(tx->filt.coef, i);
+#endif
+
+  fftwf_execute(ptmp);
+  fftwf_destroy_plan(ptmp);
+  delvec_COMPLEX(zcvec);
+  normalize_vec_COMPLEX(rx[RL]->filt.ovsv->zfvec, tx->filt.ovsv->fftlen);
+  memcpy((char *) tx->filt.save,
+	 (char *) tx->filt.ovsv->zfvec,
+	 tx->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setFilter 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setFilter(int n, char **p) {
+  if (n == 2)
+    return setRXFilter(n, p);
+  else {
+    int trx = atoi(p[2]);
+    if (trx == RX)
+      return setRXFilter(n, p);
+    else if (trx == TX)
+      return setTXFilter(n, p);
+    else
+      return -1;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setMode 
+* 
+* setMode <mode> [TRX]
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setMode(int n, char **p) {
+  int mode = atoi(p[0]);
+  if (n > 1) {
+    int trx = atoi(p[1]);
+    switch (trx) {
+    case TX:
+      tx->mode = mode;
+      break;
+    case RX:
+    default:
+      rx[RL]->mode = mode;
+      break;
+    }
+  } else
+    tx->mode = rx[RL]->mode = uni->mode.sdr = mode;
+  if (rx[RL]->mode == AM)
+    rx[RL]->am.gen->mode = AMdet;
+  if (rx[RL]->mode == SAM)
+    rx[RL]->am.gen->mode = SAMdet;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setOSC 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setOsc(int n, char **p) {
+  double newfreq = atof(p[0]);
+  if (fabs(newfreq) >= 0.5 * uni->rate.sample)
+    return -1;
+  newfreq *= 2.0 * M_PI / uni->rate.sample;
+  if (n > 1) {
+    int trx = atoi(p[1]);
+    switch (trx) {
+    case TX:
+      tx->osc.gen->Frequency = newfreq;
+      break;
+    case RX:
+    default:
+      rx[RL]->osc.gen->Frequency = newfreq;
+      break;
+    }
+  } else
+    tx->osc.gen->Frequency = rx[RL]->osc.gen->Frequency = newfreq;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private replay_update 
+*
+* @return void 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+replay_updates(void) {
+  char _str[4096], *str = _str;
+  splitfld _splt, *splt = &_splt;
+  BOOLEAN quiet = FALSE;
+  extern CTE update_cmds[];
+  FILE *log;
+
+  log = top->verbose ? stderr : 0;
+
+  // left back at end after rewind
+  // and subsequent reads
+  rewind(uni->update.fp);
+
+  while (fgets(str, 4096, uni->update.fp)) {
+
+    // echo to logging output?
+    if (*str == '-') {
+      quiet = TRUE;
+      str++;
+    } else
+      quiet = FALSE;
+
+    split(splt, str);
+    if (NF(splt) < 1)
+      continue;
+
+    else {
+      Thunk thk = Thunk_lookup(update_cmds, F(splt, 0));
+      if (!thk)
+	continue;
+
+      else {
+	int val = (*thk)(NF(splt) - 1, Fptr(splt, 1));
+
+	if (log && !quiet) {
+	  int i;
+	  char *s = since(&top->start_tv);
+	  fprintf(log, "replay[%s]: returned %d from", s, val);
+	  for (i = 0; i < NF(splt); i++)
+	    fprintf(log, " %s", F(splt, i));
+	  putc('\n', log);
+	  fflush(log);
+	}
+	// discard val
+      }
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setBlkNR 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setBlkNR(int n, char **p) {
+  rx[RL]->banr.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setBlkNRval 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setBlkNRval(int n, char **p) {
+  REAL adaptation_rate = atof(p[0]);
+  rx[RL]->banr.gen->adaptation_rate = adaptation_rate;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setBlkANF 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setBlkANF(int n, char **p) {
+  rx[RL]->banf.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setBlkANFval 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setBlkANFval(int n, char **p) {
+  REAL adaptation_rate = atof(p[0]);
+  rx[RL]->banf.gen->adaptation_rate = adaptation_rate;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNB 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNB(int n, char **p) {
+  rx[RL]->nb.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNBvals 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNBvals(int n, char **p) {
+  REAL threshold = atof(p[0]);
+  rx[RL]->nb.gen->threshold = rx[RL]->nb.thresh = threshold;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSDROM 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSDROM(int n, char **p) {
+  rx[RL]->nb_sdrom.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSDROMvals 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSDROMvals(int n, char **p) {
+  REAL threshold = atof(p[0]);
+  rx[RL]->nb_sdrom.gen->threshold = rx[RL]->nb_sdrom.thresh = threshold;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setBIN 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setBIN(int n, char **p) {
+  rx[RL]->bin.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setfixedAGC 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setfixedAGC(int n, char **p) {
+  REAL gain = atof(p[0]);
+  if (n > 1) {
+    int trx = atoi(p[1]);
+    switch (trx) {
+    case TX:
+      tx->leveler.gen->gain.now = gain;
+      break;
+    case RX:
+    default:
+      rx[RL]->dttspagc.gen->gain.now = gain;
+      break;
+    }
+  } else
+    tx->leveler.gen->gain.now = rx[RL]->dttspagc.gen->gain.now = gain;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCCompression 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCCompression(int n, char **p) {
+  REAL rxcompression = atof(p[0]);
+  rx[RL]->dttspagc.gen->gain.top = pow(10.0, rxcompression * 0.05);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXLevelerAttack 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXLevelerAttack(int n, char **p) {
+  REAL tmp = atof(p[0]);
+  tx->leveler.gen->attack = 1.0 - exp(-1000.0 / (tmp * uni->rate.sample));
+  tx->leveler.gen->one_m_attack = exp(-1000.0 / (tmp * uni->rate.sample));
+  tx->leveler.gen->sndx =
+    (tx->leveler.gen->indx +
+     (int) (0.003 * uni->rate.sample * tmp)) & tx->leveler.gen->mask;
+  tx->leveler.gen->fastindx =
+    (tx->leveler.gen->sndx +
+     FASTLEAD * tx->leveler.gen->mask) & tx->leveler.gen->mask;
+  tx->leveler.gen->fasthangtime = 0.1;	//wa6ahl: 100 ms
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXLevelerSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXLevelerSt(int n, char **p) {
+  BOOLEAN tmp = atoi(p[0]);
+  tx->leveler.flag = tmp;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXLevelerDecay 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXLevelerDecay(int n, char **p) {
+  REAL tmp = atof(p[0]);
+  tx->leveler.gen->decay = 1.0 - exp(-1000.0 / (tmp * uni->rate.sample));
+  tx->leveler.gen->one_m_decay = exp(-1000.0 / (tmp * uni->rate.sample));
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXLevelerTop 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXLevelerTop(int n, char **p) {
+  REAL top = atof(p[0]);
+  tx->leveler.gen->gain.top = top;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXLevelerHang 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXLevelerHang(int n, char **p) {
+  REAL hang = atof(p[0]);
+  tx->leveler.gen->hangtime = 0.001 * hang;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGC 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGC(int n, char **p) {
+  int setit = atoi(p[0]);
+  rx[RL]->dttspagc.gen->mode = 1;
+  rx[RL]->dttspagc.gen->attack = 1.0 - exp(-1000 / (2.0 * uni->rate.sample));
+  rx[RL]->dttspagc.gen->one_m_attack = 1.0 - rx[RL]->dttspagc.gen->attack;
+  rx[RL]->dttspagc.gen->hangindex = rx[RL]->dttspagc.gen->indx = 0;
+  rx[RL]->dttspagc.gen->sndx = (int) (uni->rate.sample * 0.006f);
+  rx[RL]->dttspagc.gen->fastindx = FASTLEAD;
+  switch (setit) {
+  case agcOFF:
+    rx[RL]->dttspagc.gen->mode = agcOFF;
+    rx[RL]->dttspagc.flag = TRUE;
+    break;
+  case agcSLOW:
+    rx[RL]->dttspagc.gen->mode = agcSLOW;
+    rx[RL]->dttspagc.gen->hangtime = 0.5;
+    rx[RL]->dttspagc.gen->fasthangtime = 0.1;
+    rx[RL]->dttspagc.gen->decay = 1.0 - exp(-1000 / (500.0 * uni->rate.sample));
+    rx[RL]->dttspagc.gen->one_m_decay = 1.0 - rx[RL]->dttspagc.gen->decay;
+    rx[RL]->dttspagc.flag = TRUE;
+    break;
+  case agcMED:
+    rx[RL]->dttspagc.gen->mode = agcMED;
+    rx[RL]->dttspagc.gen->hangtime = 0.25;
+    rx[RL]->dttspagc.gen->fasthangtime = 0.1;
+    rx[RL]->dttspagc.gen->decay = 1.0 - exp(-1000 / (250.0 * uni->rate.sample));
+    rx[RL]->dttspagc.gen->one_m_decay = 1.0 - rx[RL]->dttspagc.gen->decay;
+    rx[RL]->dttspagc.flag = TRUE;
+    break;
+  case agcFAST:
+    rx[RL]->dttspagc.gen->mode = agcFAST;
+    rx[RL]->dttspagc.gen->hangtime = 0.1;
+    rx[RL]->dttspagc.gen->fasthangtime = 0.1;
+    rx[RL]->dttspagc.gen->hangtime = 0.1;
+    rx[RL]->dttspagc.gen->decay = 1.0 - exp(-1000 / (100.0 * uni->rate.sample));
+    rx[RL]->dttspagc.gen->one_m_decay = 1.0 - rx[RL]->dttspagc.gen->decay;
+    rx[RL]->dttspagc.flag = TRUE;
+    break;
+  case agcLONG:
+    rx[RL]->dttspagc.gen->mode = agcLONG;
+    rx[RL]->dttspagc.flag = TRUE;
+    rx[RL]->dttspagc.gen->hangtime = 0.75;
+    rx[RL]->dttspagc.gen->fasthangtime = 0.1;
+    rx[RL]->dttspagc.gen->decay = 1.0 - exp(-0.5 / uni->rate.sample);
+    rx[RL]->dttspagc.gen->one_m_decay = 1.0 - rx[RL]->dttspagc.gen->decay;
+    break;
+  }
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCAttack 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCAttack(int n, char **p) {
+  REAL tmp = atof(p[0]);
+  rx[RL]->dttspagc.gen->mode = 1;
+  rx[RL]->dttspagc.gen->hangindex = rx[RL]->dttspagc.gen->indx = 0;
+  rx[RL]->dttspagc.gen->sndx = (int) (uni->rate.sample * 0.006);
+  rx[RL]->dttspagc.gen->fasthangtime = 0.1;
+  rx[RL]->dttspagc.gen->fastindx = FASTLEAD;
+  rx[RL]->dttspagc.gen->attack = 1.0 - exp(-1000.0 / (tmp * uni->rate.sample));
+  rx[RL]->dttspagc.gen->one_m_attack = exp(-1000.0 / (tmp * uni->rate.sample));
+  rx[RL]->dttspagc.gen->sndx = (int) (uni->rate.sample * tmp * 0.003);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCDelay 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCDecay(int n, char **p) {
+  REAL tmp = atof(p[0]);
+  rx[RL]->dttspagc.gen->decay = 1.0 - exp(-1000.0 / (tmp * uni->rate.sample));
+  rx[RL]->dttspagc.gen->one_m_decay = exp(-1000.0 / (tmp * uni->rate.sample));
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCHang 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCHang(int n, char **p) {
+  REAL hang = atof(p[0]);
+  rx[RL]->dttspagc.gen->hangtime = 0.001 * hang;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCSlope 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCSlope(int n, char **p) {
+  REAL slope = atof(p[0]);
+  rx[RL]->dttspagc.gen->slope = dB2lin(0.1 * slope);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCHangThreshold 
+* 
+* @param h 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCHangThreshold(int h, char **p) {
+  REAL hangthreshold = atof(p[0]);
+  rx[RL]->dttspagc.gen->hangthresh = 0.01 * hangthreshold;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCLimit 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCLimit(int n, char **p) {
+  REAL limit = atof(p[0]);
+  rx[RL]->dttspagc.gen->gain.top = limit;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCTop 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCTop(int n, char **p) {
+  REAL top = atof(p[0]);
+  rx[RL]->dttspagc.gen->gain.top = top;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXAGCFix 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXAGCFix(int n, char **p) {
+  rx[RL]->dttspagc.gen->gain.fix = atof(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setfTXAGCFF 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXAGCFF(int n, char **p) {
+  tx->spr.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXAGCFFCompresion 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXAGCFFCompression(int n, char **p) {
+  REAL txcompression = atof(p[0]);
+  tx->spr.gen->MaxGain =
+    (((0.0000401002 * txcompression) - 0.0032093390) * txcompression + 0.0612862687) * txcompression + 0.9759745718;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXSpeechCompression 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXSpeechCompression(int n, char **p) {
+  tx->spr.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXSpeechCompressionGain 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXSpeechCompressionGain(int n, char **p) {
+  tx->spr.gen->MaxGain = dB2lin(atof(p[0]));
+  return 0;
+}
+
+#if 0
+PRIVATE int
+f2x(REAL f) {
+  REAL fix = tx->filt.ovsv->fftlen * f / uni->rate.sample;
+  return (int) (fix + 0.5);
+}
+#endif 
+
+/* -------------------------------------------------------------------------- */
+/** @brief private gmean 
+* 
+* @param x 
+* @param y 
+* @return REAL 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+gmean(REAL x, REAL y) { return sqrt(x * y); }
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrphRXEQ3 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphRXEQ3(int n, char **p) {
+  if (n < 4)
+    return -1;
+  else {
+    int i;
+    fftwf_plan ptmp;
+    ComplexFIR tmpfilt;
+    COMPLEX *filtcoef = newvec_COMPLEX(512, "filter for EQ"),
+            *tmpcoef  = newvec_COMPLEX(257, "tmp filter for EQ");
+    REAL gain[3],
+         preamp = dB2lin(atof(p[0])) * 0.5;
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-400, 400, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cscl(tmpfilt->coef[i], gain[0]);
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(400, 1500, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[1]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-1500, -400, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[1]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(1500, 6000, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[2]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-6000, -1500, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[2]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    for (i = 0; i < 257; i++)
+      filtcoef[254 + i] = tmpcoef[i];
+
+    ptmp = fftwf_plan_dft_1d(512,
+			     (fftwf_complex *) filtcoef,
+			     (fftwf_complex *) rx[RL]->grapheq.gen->p->zfvec,
+			     FFTW_FORWARD,
+			     uni->wisdom.bits);
+
+    fftwf_execute(ptmp);
+    fftwf_destroy_plan(ptmp);
+    delvec_COMPLEX(filtcoef);
+    delvec_COMPLEX(tmpcoef);
+  }
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrphRXEQ10 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphRXEQ10(int n, char **p) {
+  if (n < 11)
+    return -1;
+  else {
+    int band, i, j;
+    fftwf_plan ptmp;
+    ComplexFIR tmpfilt;
+    COMPLEX *filtcoef = newvec_COMPLEX(512, "filter for EQ"),
+            *tmpcoef  = newvec_COMPLEX(257, "tmp filter for EQ");
+    REAL preamp = dB2lin(atof(p[0])) * 0.5;
+
+    for (j = 1, band = 15; j <= 10; j++, band += 3) {
+      REAL f_here  = ISOband_get_nominal(band),
+	   f_below = gmean(f_here / 2.0, f_here),
+	   f_above = gmean(f_here, f_here * 2.0),
+	   g_here  = dB2lin(atof(p[j])) * preamp;
+
+      tmpfilt = newFIR_Bandpass_COMPLEX(-f_above, -f_below, uni->rate.sample, 257);
+      for (i = 0; i < 257; i++)
+	tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], g_here));
+      delFIR_Bandpass_COMPLEX(tmpfilt);
+
+      tmpfilt = newFIR_Bandpass_COMPLEX(f_below, f_above, uni->rate.sample, 257);
+      for (i = 0; i < 257; i++)
+	tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], g_here));
+      delFIR_Bandpass_COMPLEX(tmpfilt);
+    }
+
+    for (i = 0; i < 257; i++)
+      filtcoef[254 + i] = tmpcoef[i];
+
+    ptmp = fftwf_plan_dft_1d(512,
+			     (fftwf_complex *) filtcoef,
+			     (fftwf_complex *) rx[RL]->grapheq.gen->p->zfvec,
+			     FFTW_FORWARD,
+			     uni->wisdom.bits);
+
+    fftwf_execute(ptmp);
+    fftwf_destroy_plan(ptmp);
+    delvec_COMPLEX(filtcoef);
+    delvec_COMPLEX(tmpcoef);
+  }
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrpgTXEQ3 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphTXEQ3(int n, char **p) {
+  if (n < 4)
+    return -1;
+  else {
+    int i;
+    fftwf_plan ptmp;
+    ComplexFIR tmpfilt;
+    COMPLEX *filtcoef = newvec_COMPLEX(512, "filter for EQ"),
+            *tmpcoef  = newvec_COMPLEX(257, "tmp filter for EQ");
+    REAL gain[3],
+         preamp = dB2lin(atof(p[0])) * 0.5;
+
+    gain[0] = dB2lin(atof(p[1])) * preamp;
+    gain[1] = dB2lin(atof(p[2])) * preamp;
+    gain[2] = dB2lin(atof(p[3])) * preamp;
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-400, 400, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cscl(tmpfilt->coef[i], gain[0]);
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(400, 1500, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[1]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-1500, -400, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[1]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(1500, 6000, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[2]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+
+    tmpfilt = newFIR_Bandpass_COMPLEX(-6000, -1500, uni->rate.sample, 257);
+    for (i = 0; i < 257; i++)
+      tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], gain[2]));
+    delFIR_Bandpass_COMPLEX(tmpfilt);
+    for (i = 0; i < 257; i++)
+      filtcoef[255 + i] = tmpcoef[i];
+
+    ptmp = fftwf_plan_dft_1d(512,
+			     (fftwf_complex *) filtcoef,
+			     (fftwf_complex *) tx->grapheq.gen->p->zfvec,
+			     FFTW_FORWARD,
+			     uni->wisdom.bits);
+    fftwf_execute(ptmp);
+
+    fftwf_destroy_plan(ptmp);
+    delvec_COMPLEX(filtcoef);
+  }
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrphTXEQ10 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphTXEQ10(int n, char **p) {
+  if (n < 11)
+    return -1;
+  else {
+    int band, i, j;
+    fftwf_plan ptmp;
+    ComplexFIR tmpfilt;
+    COMPLEX *filtcoef = newvec_COMPLEX(512, "filter for EQ"),
+            *tmpcoef  = newvec_COMPLEX(257, "tmp filter for EQ");
+    REAL preamp = dB2lin(atof(p[0])) * 0.5;
+
+    for (j = 1, band = 15; j <= 10; j++, band += 3) {
+      REAL f_here  = ISOband_get_nominal(band),
+	   f_below = gmean(f_here / 2.0, f_here),
+	   f_above = gmean(f_here, f_here * 2.0),
+	   g_here  = dB2lin(atof(p[j])) * preamp;
+
+      tmpfilt = newFIR_Bandpass_COMPLEX(-f_above, -f_below, uni->rate.sample, 257);
+      for (i = 0; i < 257; i++)
+	tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], g_here));
+      delFIR_Bandpass_COMPLEX(tmpfilt);
+
+      tmpfilt = newFIR_Bandpass_COMPLEX(f_below, f_above, uni->rate.sample, 257);
+      for (i = 0; i < 257; i++)
+	tmpcoef[i] = Cadd(tmpcoef[i], Cscl(tmpfilt->coef[i], g_here));
+      delFIR_Bandpass_COMPLEX(tmpfilt);
+    }
+
+    for (i = 0; i < 257; i++)
+      filtcoef[254 + i] = tmpcoef[i];
+
+    ptmp = fftwf_plan_dft_1d(512,
+			     (fftwf_complex *) filtcoef,
+			     (fftwf_complex *) tx->grapheq.gen->p->zfvec,
+			     FFTW_FORWARD,
+			     uni->wisdom.bits);
+
+    fftwf_execute(ptmp);
+    fftwf_destroy_plan(ptmp);
+    delvec_COMPLEX(filtcoef);
+    delvec_COMPLEX(tmpcoef);
+  }
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNotch160 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNotch160(int n, char **p) {
+  tx->grapheq.gen->notchflag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXCarrierLevel 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXCarrierLevel(int n, char **p) {
+  tx->am.carrier_level = atof(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setANF 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setANF(int n, char **p) {
+  rx[RL]->anf.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setANFvals 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setANFvals(int n, char **p) {
+  int taps = atoi(p[0]), delay = atoi(p[1]);
+  REAL gain = atof(p[2]), leak = atof(p[3]);
+  rx[RL]->anf.gen->adaptive_filter_size = taps;
+  rx[RL]->anf.gen->delay = delay;
+  rx[RL]->anf.gen->adaptation_rate = gain;
+  rx[RL]->anf.gen->leakage = leak;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNR 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNR(int n, char **p) {
+  rx[RL]->anr.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNRvals 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNRvals(int n, char **p) {
+  int taps = atoi(p[0]), delay = atoi(p[1]);
+  REAL gain = atof(p[2]), leak = atof(p[3]);
+  rx[RL]->anr.gen->adaptive_filter_size = taps;
+  rx[RL]->anr.gen->delay = delay;
+  rx[RL]->anr.gen->adaptation_rate = gain;
+  rx[RL]->anr.gen->leakage = leak;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectIQ 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectIQ(int n, char **p) {
+  REAL phaseadjustment = atof(p[0]),
+    gainadjustment = atof(p[1]);
+  rx[RL]->iqfix->phase = 0.001 * phaseadjustment;
+  rx[RL]->iqfix->gain = 1.0 + 0.001 * gainadjustment;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectIQphase 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectIQphase(int n, char **p) {
+  REAL phaseadjustment = atof(p[0]);
+  rx[RL]->iqfix->phase = 0.001 *phaseadjustment;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectIQgain 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectIQgain(int n, char **p) {
+  REAL gainadjustment = atof(p[0]);
+  rx[RL]->iqfix->gain = (1.0 + 0.001 * gainadjustment);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectTXIQ 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectTXIQ(int n, char **p) {
+  REAL phaseadjustment = atof(p[0]),
+    gainadjustment = atof(p[1]);
+  tx->iqfix->phase = 0.001 * phaseadjustment;
+  tx->iqfix->gain = 1.0 + 0.001 * gainadjustment;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectTXIQphase 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectTXIQphase(int n, char **p) {
+  REAL phaseadjustment = atof(p[0]);
+  tx->iqfix->phase = 0.001 * phaseadjustment;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setcorrectTXIQgain 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setcorrectTXIQgain(int n, char **p) {
+  REAL gainadjustment = atof(p[0]);
+  tx->iqfix->gain = 1.0 + 0.001 * gainadjustment;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSquelch 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSquelch(int n, char **p) {
+  rx[RL]->squelch.thresh = atof(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSquelchSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSquelchSt(int n, char **p) {
+  rx[RL]->squelch.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXSquelch 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXSquelch(int n, char **p) {
+  tx->squelch.thresh = atof(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXSquelchSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXSquelchSt(int n, char **p) {
+  tx->squelch.flag = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXWaveShapeFunc 
+* 
+* experimental waveshaping/pre-distortion
+*
+* len f0 f1 ... f{len-1}
+* if #args < 2, clear current, set to nil
+* len should be odd in the usual case,
+*  to avoid low-level DC artifacts
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+/***/
+
+PRIVATE int
+setTXWaveShapeFunc(int n, char **p) {
+  if (n < 2) {
+    if (tx->wvs.gen->tbl) {
+      delvec_REAL(tx->wvs.gen->tbl);
+      tx->wvs.gen->tbl = 0;
+    }
+    return 0;
+  } else {
+    int npts = atoi(p[0]);
+    REAL *temp = newvec_REAL(npts, "TX WaveShape table update temp");
+    {
+      int i;
+      for (i = 0; i < npts; i++)
+	temp[i] = atof(p[i + 1]);
+    }
+    setWaveShaper(tx->wvs.gen, npts, temp);
+    delvec_REAL(temp);
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXWaveShapeSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXWaveShapeSt(int n, char **p) {
+  tx->wvs.flag = atoi(p[0]);
+  return 0;
+}
+
+/***/
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTRX 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTRX(int n, char **p) {
+  uni->mode.trx = atoi(p[0]);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNRunState 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRunState(int n, char **p) {
+  RUNMODE rs = (RUNMODE) atoi(p[0]);
+  top->state = rs;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSpotToneVals 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSpotToneVals(int n, char **p) {
+  REAL gain = atof(p[0]),
+       freq = atof(p[1]),
+       rise = atof(p[2]),
+       fall = atof(p[3]);
+  setSpotToneGenVals(rx[RL]->spot.gen, gain, freq, rise, fall);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSpotTone 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSpotTone(int n, char **p) {
+  if (atoi(p[0])) {
+    SpotToneOn(rx[RL]->spot.gen);
+    rx[RL]->spot.flag = TRUE;
+  } else
+    SpotToneOff(rx[RL]->spot.gen);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setFinished 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setFinished(int n, char **p) {
+  top->running = FALSE;
+  pthread_exit(0);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSWCH 
+* 
+* next-trx-mode fall-msec stdy-msec rise-msec
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+setSWCH(int n, char **p) {
+  if (n < 4)
+    return -1;
+  else {
+    int  nextrx = atoi(p[0]);
+    REAL fallms = atof(p[1]),
+         stdyms = atof(p[2]),
+         risems = atof(p[3]);
+
+    top->swch.trx.next = nextrx;
+
+    top->swch.env.fall.size = uni->rate.sample * fallms / 1e3 + 0.5;
+    if (top->swch.env.fall.size > 1)
+      top->swch.env.fall.incr = -1.0 / (top->swch.env.fall.size - 1);
+    else
+      top->swch.env.fall.incr = -1.0;
+
+    top->swch.env.stdy.size = uni->rate.sample * stdyms / 1e3 + 0.5;
+    top->swch.env.stdy.incr = 0.0;
+
+    top->swch.env.rise.size = uni->rate.sample * risems / 1e3 + 0.5;
+    if (top->swch.env.rise.size > 1)
+      top->swch.env.rise.incr = 1.0 / (top->swch.env.rise.size - 1);
+    else
+      top->swch.env.rise.incr = 1.0;
+
+    top->swch.env.curr.type = SWCH_FALL;
+    top->swch.env.curr.cnt = 0;
+    top->swch.env.curr.val = 1.0;
+
+    if (top->state != RUN_SWCH)
+      top->swch.run.last = top->state;
+    top->state = RUN_SWCH;
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRingBufferOffset 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRingBufferOffset(int n, char **p) {
+  top->offs = atoi(p[0]);
+  top->snds.doin = TRUE;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRingBufferReset 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRingBufferReset(int n, char **p) {
+  top->snds.doin = TRUE;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSNDResetSize 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSNDSResetSize(int n, char **p) {
+  top->snds.rsiz = atoi(p[0]);
+  top->snds.doin = TRUE;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXListen 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXListen(int n, char **p) {
+  int lis = atoi(p[0]);
+  if (lis < 0 || lis >= uni->multirx.nrx)
+    return -1;
+  else {
+    uni->multirx.lis = lis;
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXOn 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXOn(int n, char **p) {
+  if (n < 1) {
+    if (uni->multirx.act[RL])
+      return -1;
+    else {
+      uni->multirx.act[RL] = TRUE;
+      uni->multirx.nac++;
+      rx[RL]->tick = 0;
+      return 0;
+    }
+  } else {
+    int k = atoi(p[0]);
+    if (k < 0 || k >= uni->multirx.nrx)
+      return -1;
+    else {
+      if (uni->multirx.act[k])
+	return -1;
+      else {
+	uni->multirx.act[k] = TRUE;
+	uni->multirx.nac++;
+	rx[k]->tick = 0;
+	return 0;
+      }
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXOff 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXOff(int n, char **p) {
+  if (n < 1) {
+    if (!uni->multirx.act[RL])
+      return -1;
+    else {
+      uni->multirx.act[RL] = FALSE;
+      --uni->multirx.nac;
+      return 0;
+    }
+  } else {
+    int k = atoi(p[0]);
+    if (k < 0 || k >= uni->multirx.nrx)
+      return -1;
+    else {
+      if (!uni->multirx.act[k])
+	return -1;
+      else {
+	uni->multirx.act[k] = FALSE;
+	--uni->multirx.nac;
+	return 0;
+      }
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXPan 
+* 
+* [pos]  0.0 <= pos <= 1.0
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+setRXPan(int n, char **p) {
+  REAL pos, theta;
+  if (n < 1) {
+    pos = 0.5;
+    theta = (1.0 - pos) * M_PI / 2.0;
+    rx[RL]->azim = Cmplx(cos(theta), sin(theta));
+    return 0;
+  } else {
+    if ((pos = atof(p[0])) < 0.0 || pos > 1.0)
+      return -1;
+    theta = (1.0 - pos) * M_PI / 2.0;
+    rx[RL]->azim = Cmplx(cos(theta), sin(theta));
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGain 
+* 
+* TRX IO [gain] in->0, out->1, gain in dB, gain default->reset
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+setGain(int n, char **p) {
+  if (n < 2)
+    return -1;
+  
+  else {
+    int trx = atoi(p[0]),
+        io = atoi(p[1]);
+    REAL gain;
+    
+    if (n < 3)
+      gain = 1.0;
+    else
+      gain = dB2lin(atof(p[2]));
+    
+    switch (trx) {
+      
+    case RX:
+      switch (io) {
+      case 0: rx[RL]->gain.i = gain; break;
+      case 1: rx[RL]->gain.o = gain; break;
+      default: return -1;
+      }
+      break;
+      
+    case TX:
+      switch (io) {
+      case 0: tx->gain.i = gain; break;
+      case 1: tx->gain.o = gain; break;
+      default: return -1;
+      }
+      break;
+
+    default:
+      return -1;
+    }
+  }
+  
+  return 0;
+}
+
+#if 0
+/* -------------------------------------------------------------------------- */
+/** @brief private setRXGain 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setRXGain(int n, char **p) {
+  if (n < 1) {
+    rx[RL]->gain = 1.0;
+    return 0;
+  } else {
+    rx[RL]->gain = dB2lin(atof(p[0]));
+    return 0;
+  }
+}
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setCompandSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setCompandSt(int n, char **p) {
+  if (n < 1) {
+    tx->cpd.flag = FALSE;
+    return 0;
+  } else {
+    BOOLEAN flag = atoi(p[0]);
+    if (n > 1) {
+      switch (atoi(p[1])) {
+      case RX:
+	rx[RL]->cpd.flag = flag;
+	break;
+      case TX:
+      default:
+	tx->cpd.flag = flag;
+	break;
+      }
+    } else
+      tx->cpd.flag = flag;
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setCompand 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setCompand(int n, char **p) {
+  if (n < 1)
+    return -1;
+  else {
+    REAL fac = atof(p[0]);
+    if (n > 1) {
+      switch (atoi(p[1])) {
+      case RX:
+	WSCReset(rx[RL]->cpd.gen, fac);
+	break;
+      case TX:
+      default:
+	WSCReset(tx->cpd.gen, fac);
+	break;
+      }
+    } else
+      WSCReset(tx->cpd.gen, fac);
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrphTXEQcmd 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphTXEQcmd(int n, char **p) {
+  if (n < 1) {
+    tx->grapheq.flag = FALSE;
+    return 0;
+  } else {
+    BOOLEAN flag = atoi(p[0]);
+    tx->grapheq.flag = flag;
+  }
+  return 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setGrphRXEQcmd 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setGrphRXEQcmd(int n, char **p) {
+  if (n < 1) {
+    rx[RL]->grapheq.flag = FALSE;
+    return 0;
+  } else {
+    BOOLEAN flag = atoi(p[0]);
+    rx[RL]->grapheq.flag = flag;
+  }
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXCompandSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXCompandSt(int n, char **p) {
+  if (n < 1) {
+    tx->cpd.flag = FALSE;
+    return 0;
+  } else {
+    BOOLEAN flag = atoi(p[0]);
+    tx->cpd.flag = flag;
+  }
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTXCompand 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTXCompand(int n, char **p) {
+  if (n < 1)
+    return -1;
+  else {
+    REAL fac = atof(p[0]);
+    WSCReset(tx->cpd.gen, fac);
+  }
+  return 0;
+}
+
+//------------------------------------------------------------------------
+
+#if 0
+// [type]
+/* -------------------------------------------------------------------------- */
+/** @brief private setMeterType 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setMeterType(int n, char **p) {
+  if (n < 1)
+    uni->meter.rx.type = SIGNAL_STRENGTH;
+  else {
+    METERTYPE type = (METERTYPE) atoi(p[0]);
+    if (n > 1) {
+      int trx = atoi(p[1]);
+      switch (trx) {
+      case TX:
+	uni->meter.tx->type = type;
+	break;
+      case RX:
+      default:
+	uni->meter.rx.type = type;
+	break;
+      }
+    } else
+      uni->meter.rx.type = type;
+  }
+  return 0;
+}
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSpectrumPolyphase 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSpectrumPolyphase(int n, char **p) {
+  BOOLEAN setit = atoi(p[0]);
+  if (uni->spec.polyphase != setit) {
+    if (setit) {
+      uni->spec.polyphase = TRUE;
+      uni->spec.mask = (8 * uni->spec.size) - 1;
+      {
+	RealFIR WOLAfir;
+	REAL MaxTap = 0;
+	int i;
+	WOLAfir = newFIR_Lowpass_REAL(1.0,
+				      (REAL) uni->spec.size,
+				      8 * uni->spec.size - 1);
+	memset(uni->spec.window, 0, 8 * sizeof(REAL) * uni->spec.size);
+	memcpy(uni->spec.window,
+	       FIRcoef(WOLAfir),
+	       sizeof(REAL) * (8 * uni->spec.size - 1));
+	for (i = 0; i < 8 * uni->spec.size; i++)
+	  MaxTap = max(MaxTap, fabs(uni->spec.window[i]));
+	MaxTap = 1.0f / MaxTap;
+	for (i = 0; i < 8 * uni->spec.size; i++)
+	  uni->spec.window[i] *= MaxTap;
+	delFIR_REAL(WOLAfir);
+      }
+    } else {
+      uni->spec.polyphase = FALSE;
+      uni->spec.mask = uni->spec.size - 1;
+      memset(uni->spec.window, 0, sizeof(REAL) * uni->spec.size);
+      makewindow(uni->spec.wintype, uni->spec.size - 1, uni->spec.window);
+    }
+    reinit_spectrum(&uni->spec);
+  }
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private seSpectrumWindow 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSpectrumWindow(int n, char **p) {
+  Windowtype window = atoi(p[0]);
+  if (!uni->spec.polyphase)
+    makewindow(window, uni->spec.size, uni->spec.window);
+  uni->spec.wintype = window;
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setSpectrumType 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setSpectrumType(int n, char **p) {
+  uni->spec.type = SPEC_POST_FILT;
+  uni->spec.scale = SPEC_PWR;
+  uni->spec.rxk = RL;
+  switch (n) {
+  case 3:
+    uni->spec.rxk = atoi(p[2]);
+  case 2:
+    uni->spec.scale = atoi(p[1]);
+  case 1:
+    uni->spec.type = atoi(p[0]);
+    break;
+  case 0:
+    break;
+  default:
+    return -1;
+  }
+  return uni->spec.type;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setDCBlockSt 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setDCBlockSt(int n, char **p) {
+  if (n < 1) {
+    tx->dcb.flag = FALSE;
+    return 0;
+  } else {
+    tx->dcb.flag = atoi(p[0]);
+    return 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setDCBlock 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setDCBlock(int n, char **p) {
+  resetDCBlocker(tx->dcb.gen);
+  return 0;
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setNewBuflen 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setNewBuflen(int n, char **p) {
+  extern int reset_for_buflen(int);
+  int rtn = -1;
+  if (n == 1) {
+    top->susp = TRUE;
+    if (reset_for_buflen(atoi(p[0])) != -1) {
+      if (uni->update.flag)
+	replay_updates();
+      rtn = 0;
+    }
+    top->susp = FALSE;
+  }
+  return rtn;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTEST 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTEST(int n, char **p) {
+  if (n == 1) {
+    int mode = atoi(p[0]);
+    if ((mode >= TEST_TONE) && (mode <= TEST_NOISE)) {
+      top->test.mode = mode;
+      return 0;
+    }
+  }
+  return -1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTestTone 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+// setTestTone freq-in-hz amp-in-dB
+
+PRIVATE int
+setTestTone(int n, char **p) {
+  if (n == 2) {
+    REAL freq = atof(p[0]),
+         amp  = dB2lin(atof(p[1])),
+         phs  = OSCphase(top->test.tone.gen);
+    delOSC(top->test.tone.gen);
+    top->test.tone.gen = newOSC(top->hold.size.frames,
+				ComplexTone,
+				freq,
+				phs,
+				uni->rate.sample,
+				"test mode single tone");
+    top->test.tone.amp = amp;
+    return 0;
+  }
+  return -1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTestTwoTone 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+// setTestTwoTone freq-in-hz-A amp-in-dB-A freq-in-hz-B amp-in-dB-B
+
+PRIVATE int
+setTestTwoTone(int n, char **p) {
+  if (n == 4) {
+    REAL freq = atof(p[0]),
+         amp  = dB2lin(atof(p[1])),
+         phs  = OSCphase(top->test.twotone.a.gen);
+    delOSC(top->test.twotone.a.gen);
+    top->test.twotone.a.gen = newOSC(top->hold.size.frames,
+				     ComplexTone,
+				     freq,
+				     phs,
+				     uni->rate.sample,
+				     "test mode two tone A");
+    top->test.twotone.a.amp = amp;
+
+    freq = atof(p[2]),
+    amp  = dB2lin(atof(p[3])),
+    phs  = OSCphase(top->test.twotone.b.gen);
+    delOSC(top->test.twotone.b.gen);
+    top->test.twotone.b.gen = newOSC(top->hold.size.frames,
+				     ComplexTone,
+				     freq,
+				     phs,
+				     uni->rate.sample,
+				     "test mode two tone B");
+    top->test.twotone.b.amp = amp;
+
+    return 0;
+  }
+
+  return -1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTestNoise 
+* 
+* setTestNoise amp-in-dB
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+setTestNoise(int n, char **p) {
+  if (n == 1) {
+    top->test.noise.amp = dB2lin(atof(p[0]));
+    return 0;
+  }
+  return -1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setTestThru 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE int
+setTestThru(int n, char **p) {
+  if (n == 1) {
+    top->test.thru = atoi(p[0]);
+    return 0;
+  }
+  return -1;
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private reqMeter 
+* 
+* save current state while guarded by upd sem
+*
+* reqMeter [label [TRX]]
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+reqMeter(int n, char **p) {
+  if (n > 1) {
+    int trx = atoi(p[1]);
+    switch (trx) {
+    case TX:
+      snap_meter_tx(&uni->meter, atoi(p[0]));
+      break;
+    case RX:
+    default:
+      snap_meter_rx(&uni->meter, atoi(p[0]));
+    }
+  } else
+    snap_meter_rx(&uni->meter, n > 0 ? atoi(p[0]) : 0);
+    
+  sem_post(top->sync.mtr.sem);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private reqRXMeter 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+// reqRXMeter [label]
+
+PRIVATE int
+reqRXMeter(int n, char **p) {
+  snap_meter_rx(&uni->meter, n > 0 ? atoi(p[0]) : 0);
+  sem_post(top->sync.mtr.sem);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private reqTXMeter 
+* 
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+// reqTXMeter [label]
+
+PRIVATE int
+reqTXMeter(int n, char **p) {
+  snap_meter_tx(&uni->meter, n > 0 ? atoi(p[0]) : 0);
+  sem_post(top->sync.mtr.sem);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private ReqSpectrum 
+* 
+* simile modo
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+reqSpectrum(int n, char **p) {
+  snap_spectrum(&uni->spec, n > 0 ? atoi(p[0]) : 0, uni->tick);
+  sem_post(top->sync.pws.sem);
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private reqScope 
+* 
+* quasi modo
+*
+* @param n 
+* @param *p 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+
+PRIVATE int
+reqScope(int n, char **p) {
+  snap_scope(&uni->spec, n > 0 ? atoi(p[0]) : 0, uni->tick);
+  sem_post(top->sync.pws.sem);
+  return 0;
+}
+
+//========================================================================
+
+CTE update_cmds[] = {
+  {"reqMeter", reqMeter},
+  {"reqRXMeter", reqRXMeter},
+  {"reqTXMeter", reqTXMeter},
+  {"reqScope", reqScope},
+  {"reqSpectrum", reqSpectrum},
+  {"setANF", setANF},
+  {"setANFvals", setANFvals},
+  {"setBIN", setBIN},
+  {"setBlkANF", setBlkANF},
+  {"setBlkANFval", setBlkANFval},
+  {"setBlkNR", setBlkNR},
+  {"setBlkNRval", setBlkNRval},
+  {"setCompand", setCompand},
+  {"setCompandSt", setCompandSt},
+  {"setcorrectIQ", setcorrectIQ},
+  {"setcorrectIQgain", setcorrectIQgain},
+  {"setcorrectIQphase", setcorrectIQphase},
+  {"setcorrectTXIQ", setcorrectTXIQ},
+  {"setcorrectTXIQgain", setcorrectTXIQgain},
+  {"setcorrectTXIQphase", setcorrectTXIQphase},
+  {"setDCBlock", setDCBlock},
+  {"setDCBlockSt", setDCBlockSt},
+  {"setFilter", setFilter},
+  {"setFinished", setFinished},
+  {"setfixedAGC", setfixedAGC},
+
+  {"setGain", setGain},
+
+  {"setGrphRXEQ3", setGrphRXEQ3},
+  {"setGrphRXEQ10", setGrphRXEQ10},
+  {"setGrphRXEQcmd", setGrphRXEQcmd},
+  {"setGrphTXEQ3", setGrphTXEQ3},
+  {"setGrphTXEQ10", setGrphTXEQ10},
+  {"setGrphTXEQcmd", setGrphTXEQcmd},
+  {"setSNDSResetSize", setSNDSResetSize},
+  {"setMode", setMode},
+  {"setNB", setNB},
+  {"setNBvals", setNBvals},
+  {"setNR", setNR},
+  {"setNRvals", setNRvals},
+  {"setNewBuflen", setNewBuflen},
+  {"setNotch160", setNotch160},
+  {"setOsc", setOsc},
+  {"setRXAGC", setRXAGC},
+  {"setRXAGCAttack", setRXAGCAttack},
+  {"setRXAGCCompression", setRXAGCCompression},
+  {"setRXAGCCompression", setRXAGCCompression},
+  {"setRXAGCDecay", setRXAGCDecay},
+  {"setRXAGCFix", setRXAGCFix},
+  {"setRXAGCHang", setRXAGCHang},
+  {"setRXAGCHangThreshold", setRXAGCHangThreshold},
+  {"setRXAGCLimit", setRXAGCLimit},
+  {"setRXAGCSlope", setRXAGCSlope},
+  {"setRXAGCTop", setRXAGCTop},
+
+  {"setRXFiltCoefs", setRXFiltCoefs},
+  {"setTXFiltCoefs", setTXFiltCoefs},
+
+  {"setRXListen", setRXListen},
+  {"setRXOff", setRXOff},
+  {"setRXOn", setRXOn},
+  //  {"setRXGain", setRXGain},
+  {"setRXPan", setRXPan},
+  {"setRingBufferOffset", setRingBufferOffset},
+  {"setRingBufferReset", setRingBufferReset},
+  {"setRunState", setRunState},
+  {"setSDROM", setSDROM},
+  {"setSDROMvals", setSDROMvals},
+  {"setSWCH", setSWCH},
+  {"setSpectrumPolyphase", setSpectrumPolyphase},
+  {"setSpectrumType", setSpectrumType},
+  {"setSpectrumWindow", setSpectrumWindow},
+  {"setSpotTone", setSpotTone},
+  {"setSpotToneVals", setSpotToneVals},
+  {"setSquelch", setSquelch},
+  {"setSquelchSt", setSquelchSt},
+
+  {"SetTEST", setTEST},
+  {"SetTestTone", setTestTone},
+  {"SetTestTwoTone", setTestTwoTone},
+  {"SetTestNoise", setTestNoise},
+  {"SetTestThru", setTestThru},
+
+  {"setTRX", setTRX},
+  {"setTXAGCFF", setTXAGCFF},
+  {"setTXAGCFFCompression", setTXAGCFFCompression},
+  {"setTXCarrierLevel", setTXCarrierLevel},
+  {"setTXCompand", setTXCompand},
+  {"setTXCompandSt", setTXCompandSt},
+  {"setTXLevelerAttack", setTXLevelerAttack},
+  {"setTXLevelerDecay", setTXLevelerDecay},
+  {"setTXLevelerHang", setTXLevelerHang},
+  {"setTXLevelerSt", setTXLevelerSt},
+  {"setTXLevelerTop", setTXLevelerTop},
+  {"setTXSpeechCompression", setTXSpeechCompression},
+  {"setTXSpeechCompressionGain", setTXSpeechCompressionGain},
+  {"setTXSquelch", setTXSquelch},
+  {"setTXSquelchSt", setTXSquelchSt},
+
+  /***/
+  // experimental waveshaping/pre-distortion
+
+  {"setTXWaveShapeFunc", setTXWaveShapeFunc},
+  {"setTXWaveShapeSt", setTXWaveShapeSt},
+
+  /***/
+
+
+
+#if 0
+  {"setMeterType", setMeterType},
+#endif
+  {0, 0}
+};
+
+//........................................................................
+
+/* -------------------------------------------------------------------------- */
+/** @brief do_update 
+* 
+* @param str 
+* @param log 
+* @return int 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+do_update(char *str, FILE *log) {
+  BOOLEAN quiet = FALSE;
+  SPLIT splt = &uni->update.splt;
+
+  // append to replay file?
+  if (*str == '!') {
+    str++;			// strip !
+    if (uni->update.flag)
+      fputs(str, uni->update.fp);
+  }
+  // echo to logging output?
+  if (*str == '-') {
+    quiet = TRUE;
+    str++;
+  }
+
+  split(splt, str);
+
+  if (NF(splt) < 1)
+    return -1;
+
+  else {
+    Thunk thk = Thunk_lookup(update_cmds, F(splt, 0));
+    if (!thk)
+      return -1;
+    else {
+      int val;
+
+      sem_wait(top->sync.upd.sem);
+      val = (*thk)(NF(splt) - 1, Fptr(splt, 1));
+      sem_post(top->sync.upd.sem);
+
+      if (log && !quiet) {
+	int i;
+	char *s = since(&top->start_tv);
+	fprintf(log, "update[%s]: returned %d from", s, val);
+	for (i = 0; i < NF(splt); i++)
+	  fprintf(log, " %s", F(splt, i));
+	putc('\n', log);
+	fflush(log);
+      }
+
+      return val;
+    }
+  }
+}
+
+//------------------------------------------------------------------------
--- /dev/null
+++ dttsp-0~svn675/cwtones.c
@@ -0,0 +1,225 @@
+/** 
+* @file cwtones.c
+* @brief Functions to implement cw tones 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2005, 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <cwtones.h>
+
+/// ------------------------------------------------------------------------
+///  An ASR envelope on a complex phasor,
+///  with asynchronous trigger for R stage.
+///  A/R use sine shaping.
+/// ------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run CWTone 
+* 
+* @param cwt 
+*/
+/* ---------------------------------------------------------------------------- */
+BOOLEAN
+CWTone(CWToneGen cwt) {
+  int i, n = cwt->size;
+
+  ComplexOSC(cwt->osc.gen);
+
+  for (i = 0; i < n; i++) {
+
+    // in an envelope stage?
+
+    if (cwt->stage == CWTone_RISE) {
+
+      // still going?
+      if (cwt->rise.have++ < cwt->rise.want) {
+	cwt->curr += cwt->rise.incr;
+	cwt->mul = cwt->scl * sin(cwt->curr * M_PI / 2.0);
+      } else {
+	// no, assert steady-state, force level
+	cwt->curr = 1.0;
+	cwt->mul = cwt->scl;
+	cwt->stage = CWTone_STDY;
+	// won't come back into envelopes
+	// until FALL asserted from outside
+      }
+
+    } else if (cwt->stage == CWTone_FALL) {
+
+      // still going?
+      if (cwt->fall.have++ < cwt->fall.want) {
+	cwt->curr -= cwt->fall.incr;
+	cwt->mul = cwt->scl * sin(cwt->curr * M_PI / 2.0);
+      } else {
+	// no, assert trailing, force level
+	cwt->curr = 0.0;
+	cwt->mul = 0.0;
+	cwt->stage = CWTone_HOLD;
+	// won't come back into envelopes hereafter
+      }
+    }
+    ///  apply envelope
+    // (same base as osc.gen internal buf)
+    CXBdata(cwt->buf, i) = Cscl(CXBdata(cwt->buf, i), cwt->mul);
+  }
+
+  ///  indicate whether it's turned itself off
+  ///  sometime during this pass
+
+  return cwt->stage != CWTone_HOLD;
+}
+
+/// ------------------------------------------------------------------------
+///  turn tone on with current settings
+
+/* -------------------------------------------------------------------------- */
+/** @brief Turn CW Tone On 
+* 
+* @param cwt 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+CWToneOn(CWToneGen cwt) {
+
+  ///  gain is in dB
+
+  cwt->scl = pow(10.0, cwt->gain / 20.0);
+  cwt->curr = cwt->mul = 0.0;
+
+  ///  A/R times are in msec
+
+  cwt->rise.want = (int) (0.5 + cwt->sr * (cwt->rise.dur / 1e3));
+  cwt->rise.have = 0;
+  if (cwt->rise.want <= 1)
+    cwt->rise.incr = 1.0;
+  else
+    cwt->rise.incr = 1.0f / (cwt->rise.want - 1);
+
+  cwt->fall.want = (int) (0.5 + cwt->sr * (cwt->fall.dur / 1e3));
+  cwt->fall.have = 0;
+  if (cwt->fall.want <= 1)
+    cwt->fall.incr = 1.0;
+  else
+    cwt->fall.incr = 1.0f / (cwt->fall.want - 1);
+
+  ///  freq is in Hz
+
+  OSCfreq(cwt->osc.gen) = 2.0 * M_PI * cwt->osc.freq / cwt->sr;
+  OSCphase(cwt->osc.gen) = 0.0;
+
+  cwt->stage = CWTone_RISE;
+}
+
+/// ------------------------------------------------------------------------
+/// initiate turn-off
+
+/* -------------------------------------------------------------------------- */
+/** @brief Turn CW Tone Off 
+* 
+* @param cwt 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+CWToneOff(CWToneGen cwt) {
+  cwt->stage = CWTone_FALL;
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief set CW Tone General Values 
+* 
+* @param cwt 
+* @param gain 
+* @param freq 
+* @param rise 
+* @param fall 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+setCWToneGenVals(CWToneGen cwt, REAL gain, REAL freq, REAL rise, REAL fall) {
+  cwt->gain = gain;
+  cwt->osc.freq = freq;
+  cwt->rise.dur = rise;
+  cwt->fall.dur = fall;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new CW Tone General 
+* @param gain 
+* @param freq 
+* @param rise 
+* @param fall 
+* @param size 
+* @param samplerate 
+*/
+/* ---------------------------------------------------------------------------- */
+CWToneGen
+newCWToneGen(REAL gain,	// dB
+	     REAL freq, // Hz
+             REAL rise,	// ms
+	     REAL fall,	// ms
+	     int size, 
+             REAL samplerate) {
+
+  CWToneGen cwt = (CWToneGen) safealloc(1, sizeof(CWToneGenDesc),
+					"CWToneGenDesc");
+
+  setCWToneGenVals(cwt, gain, freq, rise, fall);
+  cwt->size = size;
+  cwt->sr = samplerate;
+
+  cwt->osc.gen = newOSC(cwt->size,
+			ComplexTone,
+			(double) cwt->osc.freq, 0.0, cwt->sr, "CWTone osc");
+
+  /// overload oscillator buf
+  cwt->buf = newCXB(cwt->size, OSCCbase(cwt->osc.gen), "CWToneGen buf");
+
+  return cwt;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create delete CW Tone General 
+a 
+* @param cwt 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delCWToneGen(CWToneGen cwt) {
+  if (cwt) {
+    delCXB(cwt->buf);
+    delOSC(cwt->osc.gen);
+    safefree((char *) cwt);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/sdrexport.c
@@ -0,0 +1,43 @@
+/* 
+* @file sdrexport.c
+* @brief 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <common.h>
+
+struct _uni *uni;
+struct _rx *rx[MAXRX];
+struct _tx *tx;
+struct _top *top;
--- /dev/null
+++ dttsp-0~svn675/banal.c
@@ -0,0 +1,396 @@
+/** 
+* @file banal.c
+* @brief Functin for block analysis
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+Doxygen comments added by Dave Larsen, KV0S
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <fromsys.h>
+#include <banal.h>
+
+void
+/* -------------------------------------------------------------------------- */
+/** @brief nil function
+*/
+/* ---------------------------------------------------------------------------- */
+nilfunc(void) {}
+
+int
+/* -------------------------------------------------------------------------- */
+/** @brief Population count
+* 
+* @param k 
+*/
+/* ---------------------------------------------------------------------------- */
+popcnt(int k) {
+  int c, i;
+  c = k & 01;
+  for (i = 1; i < 32; i++)
+    c += (k >> i) & 01;
+  return c;
+}
+
+int
+/* -------------------------------------------------------------------------- */
+/** @brief npoof2 
+* 
+* @param n 
+*/
+/* ---------------------------------------------------------------------------- */
+npoof2(int n) {
+  int i = 0;
+  --n;
+  while (n > 0)
+    n >>= 1, i++;
+  return i;
+}
+
+int
+/* -------------------------------------------------------------------------- */
+/** @brief nblock2
+* 
+* @param n 
+*/
+/* ---------------------------------------------------------------------------- */
+nblock2(int n) { return 1 << npoof2(n); }
+
+int
+/* -------------------------------------------------------------------------- */
+/** @brief in_blocks 
+* 
+* @param count 
+* @param block_size 
+*/
+/* ---------------------------------------------------------------------------- */
+in_blocks(int count, int block_size) {
+  if (block_size < 1) {
+    fprintf(stderr, "block_size zero in in_blocks\n");
+    exit(1);
+  }
+  return (1 + ((count - 1) / block_size));
+}
+
+
+FILE *
+/* -------------------------------------------------------------------------- */
+/** @brief efopen
+* 
+* @param path 
+* @param mode 
+*/
+/* ---------------------------------------------------------------------------- */
+efopen(char *path, char *mode) {
+  FILE *iop = fopen(path, mode);
+  if (!iop) {
+    fprintf(stderr, "can't open \"%s\" in mode \"%s\"\n", path, mode);
+    exit(1);
+  }
+  return iop;
+}
+
+FILE *
+/* -------------------------------------------------------------------------- */
+/** @brief efreopen
+* 
+* @param path 
+* @param mode 
+* @param strm 
+*/
+/* ---------------------------------------------------------------------------- */
+efreopen(char *path, char *mode, FILE * strm) {
+  FILE *iop = freopen(path, mode, strm);
+  if (!iop) {
+    fprintf(stderr, "can't reopen \"%s\" in mode \"%s\"\n", path, mode);
+    exit(1);
+  }
+  return iop;
+}
+
+size_t
+/* -------------------------------------------------------------------------- */
+/** @brief filesize
+* 
+* @param path 
+*/
+/* ---------------------------------------------------------------------------- */
+filesize(char *path) {
+  struct stat sbuf;
+  if (stat(path, &sbuf) == -1) return -1;
+  return sbuf.st_size;
+}
+
+size_t
+/* -------------------------------------------------------------------------- */
+/** @brief fdsize
+* 
+* @param fd 
+*/
+/* ---------------------------------------------------------------------------- */
+fdsize(int fd) {
+  struct stat sbuf;
+  if (fstat(fd, &sbuf) == -1) return -1;
+  return sbuf.st_size;
+}
+
+#define MILLION (1000000)
+
+// return current tv
+/* -------------------------------------------------------------------------- */
+/** @brief now_tv 
+*/
+/* ---------------------------------------------------------------------------- */
+struct timeval
+now_tv(void) {
+  struct timeval tv;
+  gettimeofday(&tv, 0);
+  return tv;
+}
+
+// return ta - tb
+/* -------------------------------------------------------------------------- */
+/** @brief diff_tv 
+* 
+* @param ta 
+* @param tb 
+*/
+/* ---------------------------------------------------------------------------- */
+struct timeval
+diff_tv(struct timeval *ta, struct timeval *tb) {
+  struct timeval tv;
+  if (tb->tv_usec > ta->tv_usec) {
+    ta->tv_sec--;
+    ta->tv_usec += MILLION;
+  }
+  tv.tv_sec = ta->tv_sec - tb->tv_sec;
+  if ((tv.tv_usec = ta->tv_usec - tb->tv_usec) >= MILLION) {
+    tv.tv_usec -= MILLION;
+    tv.tv_sec++;
+  }
+  return tv;
+}
+
+// return ta + tb
+/* -------------------------------------------------------------------------- */
+/** @brief 
+* 
+* @param ta 
+* @param tb 
+*/
+/* ---------------------------------------------------------------------------- */
+struct timeval
+sum_tv(struct timeval *ta, struct timeval *tb) {
+  struct timeval tv;
+  tv.tv_sec = ta->tv_sec + tb->tv_sec;
+  if ((tv.tv_usec = ta->tv_usec + tb->tv_usec) >= MILLION) {
+    tv.tv_usec -= MILLION;
+    tv.tv_sec++;
+  }
+  return tv;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief fmt_tv 
+* 
+* @param tv 
+*/
+/* ---------------------------------------------------------------------------- */
+char *
+fmt_tv(struct timeval *tv) {
+  static char buff[256];
+  snprintf(buff, sizeof(buff), "%ds%du", (int) tv->tv_sec, (int) tv->tv_usec);
+  return buff;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief since 
+* 
+* @param tv 
+*/
+/* ---------------------------------------------------------------------------- */
+char *
+since(struct timeval *tv) {
+  struct timeval nt = now_tv(), dt = diff_tv(&nt, tv);
+  return fmt_tv(&dt);
+}
+
+/// linear integer interpolation:
+/// real vector v, n long, -> real vector u, m long
+/// *** n must divide m
+/// returns actual number of valid points in u
+/// (== n - m/n since v[n] is undefined)
+
+/* -------------------------------------------------------------------------- */
+/** @brief hinterp_vec 
+* 
+* @param u 
+* @param m 
+* @param v 
+* @param n 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+hinterp_vec(REAL *u, int m, REAL *v, int n) {
+  if (!u || !v || (n < 2) || (m < n) || (m % n))
+    return 0;
+  else {
+    int div = m / n, i, j = 0;
+    for (i = 1; i < n; i++) {
+      int k;
+      REAL vl = v[i - 1], del = (v[i] - vl) / div;
+      u[j++] = vl;
+      for (k = 1; k < div; k++)
+	u[j++] = vl + k * del;
+    }
+    u[j++] = v[n - 1];
+    return j;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief status_message 
+* 
+* @param msg 
+* @param write(2 
+* @param msg 
+* @param strlen(msg 
+* @param  
+*/
+/* ---------------------------------------------------------------------------- */
+void
+status_message(char *msg) { (void) write(2, msg, strlen(msg)); }
+
+FILE *
+find_rcfile(char *base) {
+  char path[MAXPATHLEN];
+  FILE *fp;
+  sprintf(path, "./%s", base);
+  if ((fp = fopen(path, "r")))
+    return fp;
+  else {
+    char *home = getenv("HOME");
+    if (!home)
+      fprintf(stderr, "can't get HOME!\n"), exit(1);
+    sprintf(path, "%s/%s", home, base);
+    if ((fp = fopen(path, "r")))
+      return fp;
+  }
+  return 0;
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief hash 
+* 
+* @param str 
+*/
+/* ---------------------------------------------------------------------------- */
+unsigned long
+hash(unsigned char *str) {
+  unsigned long hash = 5381;
+  int c;
+  while (c = *str++)
+    hash = ((hash << 5) + hash) + c;	// (hash * 33 + c) better
+  return hash;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief gcd 
+* 
+* @param u 
+* @param v 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+gcd(int u, int v) {
+  int shift;
+
+  /// GCD(0, x) := x
+  if (u == 0 || v == 0)
+    return u | v;
+
+  /// Let shift := lg K,
+  /// where K is the greatest power of 2
+  /// dividing both u and v.
+  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
+    u >>= 1;
+    v >>= 1;
+  }
+
+  while ((u & 1) == 0)
+    u >>= 1;
+
+  /// From here on, u is always odd.
+  do {
+    while ((v & 1) == 0)
+      v >>= 1;
+
+    /// Now u and v are both odd,
+    /// so diff(u, v) is even.
+    /// Let u = min(u, v), v = diff(u, v)/2.
+    if (u <= v)
+      v -= u;
+    else {
+      int diff = u - v;
+      u = v;
+      v = diff;
+    }
+    v >>= 1;
+  } while (v != 0);
+
+  return u << shift;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief lcm 
+* 
+* @param u 
+* @param v 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+lcm(int u, int v) {
+  return u * v / gcd(u, v);
+}
+
+#if 0
+int
+gcd(int m, int n) {
+  return (m % n == 0 ? n : gcd(n, m % n));
+}
+
+int
+lcm(int m, int n) {
+  return (abs((m * n) / gcd(m, n)));
+}
+#endif
--- /dev/null
+++ dttsp-0~svn675/ringb.h
@@ -0,0 +1,201 @@
+/* ringb.h
+  Derived from jack/ringbuffer.h
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 3 of the License, or
+    (at your option) any later version.
+    
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software 
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+    Original
+    Copyright (C) 2000 Paul Davis
+    Copyright (C) 2003 Rohan Drape
+
+    Derived
+    Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+*/
+
+#ifndef _ringb_h
+#define _ringb_h
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <bufvec.h>
+
+typedef struct {
+  char *buf;
+  size_t len;
+} ringb_data_t;
+
+typedef struct {
+  char *buf;
+  size_t wptr, rptr, size, mask;
+} ringb_t;
+
+typedef struct {
+  float *buf;
+  size_t len;
+} ringb_floatdata_t;
+
+typedef struct {
+  float *buf;
+  size_t wptr, rptr, size, mask;
+} ringb_float_t;
+
+/* Sets up a ringbuffer data structure of a specified size
+ * and allocates the required memory.  
+ * sz is requested ringbuffer size in bytes(floats),
+ * MUST be a power of 2.
+ * pre-allocated memory must be large enough to
+ * accommodate (ringb header + stipulated memory size).
+ * return a pointer to a new ringb_t, if successful,
+ * 0 otherwise.
+ * Freeing is done by calling ringb_free. */
+
+extern ringb_t *ringb_create(size_t sz2);
+extern ringb_float_t *ringb_float_create(size_t sz2);
+
+// free the ring buffers
+
+extern void ringb_free(ringb_t *rb);
+extern void ringb_float_free(ringb_float_t *rb);
+
+/* Fill a data structure with a description of the current readable
+ * data held in the ringbuffer.  This description is returned in a two
+ * element array of ringb_data_t.  Two elements are needed
+ * because the data to be read may be split across the end of the
+ * ringbuffer.
+ *
+ * The first element will always contain a valid len field, which
+ * may be zero or greater.  If the len field is non-zero, then data
+ * can be read in a contiguous fashion using the address given in the
+ * corresponding @a buf field.
+ *
+ * If the second element has a non-zero len field, then a second
+ * contiguous stretch of data can be read from the address given in
+ * its corresponding buf field.
+ *
+ *rb a pointer to the ringbuffer structure.
+ *vec a pointer to a 2 element array of ringb_data_t. */
+
+extern void ringb_get_read_vector(const ringb_t *rb, ringb_data_t *vec);
+
+/* Fill a data structure with a description of the current writable
+ * space in the ringbuffer.  The description is returned in a two
+ * element array of ringb_data_t.  Two elements are needed
+ * because the space available for writing may be split across the end
+ * of the ringbuffer.
+ * The first element will always contain a valid len field, which
+ * may be zero or greater.  If the @a len field is non-zero, then data
+ * can be written in a contiguous fashion using the address given in
+ * the corresponding buf field.
+ * If the second element has a non-zero len field, then a second
+ * contiguous stretch of data can be written to the address given in
+ * the corresponding buf field.
+ *rb a pointer to the ringbuffer structure.
+ *vec a pointer to a 2 element array of ringb_data_t. */
+
+extern void ringb_get_write_vector(const ringb_t *rb, ringb_data_t *vec);
+
+/*
+ * Read data from the ringbuffer.
+ *rb a pointer to the ringbuffer structure.
+ * dest a pointer to a buffer where data read from the
+ * ringbuffer will go.
+ * cnt the number of bytes to read.
+ * return the number of bytes read, which may range from 0 to cnt. */
+
+extern size_t ringb_read(ringb_t *rb, char *dest, size_t cnt);
+extern size_t ringb_float_read(ringb_float_t *rb, float *dest, size_t cnt);
+
+/* Read data from the ringbuffer. Opposed to ringb_read()
+ * this function does not move the read pointer. Thus it's
+ * a convenient way to inspect data in the ringbuffer in a
+ * continous fashion. The price is that the data is copied
+ * into a user provided buffer. For "raw" non-copy inspection
+ * of the data in the ringbuffer use ringb_get_read_vector().
+ * rb a pointer to the ringbuffer structure.
+ * dest a pointer to a buffer where data read from the
+ *   ringbuffer will go.
+ * cnt the number of bytes to read.
+ * return the number of bytes read, which may range from 0 to cnt.
+ */
+
+extern size_t ringb_peek(ringb_t *rb, char *dest, size_t cnt);
+
+/* Advance the read pointer.
+ * After data have been read from the ringbuffer using the pointers
+ * returned by ringb_get_read_vector(), use this function to
+ * advance the buffer pointers, making that space available for future
+ * write operations.
+ * rb a pointer to the ringbuffer structure.
+ * cnt the number of bytes read. */
+
+extern void ringb_read_advance(ringb_t *rb, size_t cnt);
+
+/* Return the number of bytes available for reading.
+ *rb a pointer to the ringbuffer structure.
+ * return the number of bytes available to read. */
+
+extern size_t ringb_read_space(const ringb_t *rb);
+extern size_t ringb_float_read_space(const ringb_float_t *rb);
+
+/* Reset the read and write pointers, making an empty buffer.
+ * This is not thread safe. */
+
+extern void ringb_reset(ringb_t *rb);
+extern void ringb_float_reset(ringb_float_t *rb);
+
+/* Write data into the ringbuffer.
+ *rb a pointer to the ringbuffer structure.
+ * src a pointer to the data to be written to the ringbuffer.
+ * cnt the number of bytes(floats) to write.
+ * return the number of bytes(floats) written, which may range from 0 to cnt */
+
+extern size_t ringb_write(ringb_t *rb, const char *src, size_t cnt);
+extern size_t ringb_float_write(ringb_float_t *rb, const float *src,
+				size_t cnt);
+
+/* Advance the write pointer.
+ * After data have been written the ringbuffer using the pointers
+ * returned by ringb_get_write_vector(), use this function
+ * to advance the buffer pointer, making the data available for future
+ * read operations.
+ * rb a pointer to the ringbuffer structure.
+ * cnt the number of bytes written. */
+
+extern void ringb_write_advance(ringb_t *rb, size_t cnt);
+
+/* Return the number of bytes(floats) available for writing.
+ *rb a pointer to the ringbuffer structure.
+ * return the amount of free space (in bytes) available for writing. */
+
+extern size_t ringb_write_space(const ringb_t *rb);
+extern size_t ringb_float_write_space(const ringb_float_t *rb);
+
+/* Fill the ring buffer for nbytes at the beginning with zeros 
+ * rb a pointer to the ring buffer structure
+ * nbytes the number of bytes to be written */
+
+extern void ringb_clear(ringb_t *rb, size_t nbytes);
+extern void ringb_float_clear(ringb_float_t *rb, size_t nfloats);
+
+/* Reset the read and write pointers, making an empty buffer.
+ * This is not thread safe. 
+ * Fill the ring buffer for nbytes at the beginning with zeros 
+ * rb a pointer to the ring buffer structure
+ * nbytes the number of bytes to be written */
+
+extern void ringb_restart(ringb_t *rb, size_t nbytes);
+extern void ringb_float_restart(ringb_float_t *rb, size_t nfloats);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/hilbert.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+
+# import sys
+# import pygsl as gsl
+# import pygsl.fft as fft
+# import pygsl.spline as spline
+# import pygsl.wavelet as wvlt
+# import math as M
+import numpy as N
+# import scipy as S
+
+class HilbertTransformer():
+
+    def __init__(self):
+        self.x = N.zeros(4)
+        self.y = N.zeros(6)
+        self.d = N.zeros(6)
+
+    def reset(self):
+        self.x[:] = 0
+        self.y[:] = 0
+        self.d[:] = 0
+
+    def tick(self, xin):
+        self.x[0] = self.d[1] - xin
+        self.x[1] = self.d[0] - self.x[0] * 0.00196
+        self.x[2] = self.d[3] - self.x[1]
+        self.x[3] = self.d[1] + self.x[2] * 0.737
+        
+        self.d[1] = self.x[1]
+        self.d[3] = self.x[3]
+        
+        self.y[0] = self.d[2] - xin
+        self.y[1] = self.d[0] + self.y[0] * 0.924
+        self.y[2] = self.d[4] - self.y[1]
+        self.y[3] = self.d[2] + self.y[2] * 0.439
+        self.y[4] = self.d[5] - self.y[3]
+        self.y[5] = self.d[4] - self.y[4] * 0.586
+        
+        self.d[2] = self.y[1]
+        self.d[4] = self.y[3]
+        self.d[5] = self.y[5]
+        
+        self.d[0] = xin
+
+        return complex(self.x[3], self.y[5])
+
+
+    def run(self, xa):
+        return N.asarray(map(lambda x: self.tick(x), xa))
+        
+
+if __name__ == '__main__':
+    pass
--- /dev/null
+++ dttsp-0~svn675/Makefile.in
@@ -0,0 +1,735 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+bin_PROGRAMS = sdr-core$(EXEEXT)
+subdir = .
+DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(top_srcdir)/configure AUTHORS COPYING \
+	ChangeLog INSTALL NEWS THANKS config.guess config.sub depcomp \
+	install-sh missing
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libDttSP_a_AR = $(AR) $(ARFLAGS)
+libDttSP_a_LIBADD =
+am_libDttSP_a_OBJECTS = am_demod.$(OBJEXT) banal.$(OBJEXT) \
+	bufvec.$(OBJEXT) correctIQ.$(OBJEXT) cwtones.$(OBJEXT) \
+	cxops.$(OBJEXT) dcblock.$(OBJEXT) dttspagc.$(OBJEXT) \
+	fastrig.$(OBJEXT) filter.$(OBJEXT) fm_demod.$(OBJEXT) \
+	graphiceq.$(OBJEXT) halfband.$(OBJEXT) hilbert.$(OBJEXT) \
+	isoband.$(OBJEXT) lmadf.$(OBJEXT) meter.$(OBJEXT) \
+	noiseblanker.$(OBJEXT) oscillator.$(OBJEXT) ovsv.$(OBJEXT) \
+	resample.$(OBJEXT) ringb.$(OBJEXT) sdr.$(OBJEXT) \
+	spectrum.$(OBJEXT) speechproc.$(OBJEXT) splitfields.$(OBJEXT) \
+	spottone.$(OBJEXT) thunk.$(OBJEXT) window.$(OBJEXT) \
+	waveshape.$(OBJEXT) wscompand.$(OBJEXT) update.$(OBJEXT)
+libDttSP_a_OBJECTS = $(am_libDttSP_a_OBJECTS)
+am__installdirs = "$(DESTDIR)$(bindir)"
+PROGRAMS = $(bin_PROGRAMS)
+am_sdr_core_OBJECTS = sdr-main.$(OBJEXT) sdrexport.$(OBJEXT)
+sdr_core_OBJECTS = $(am_sdr_core_OBJECTS)
+sdr_core_DEPENDENCIES = libDttSP.a
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libDttSP_a_SOURCES) $(sdr_core_SOURCES)
+DIST_SOURCES = $(libDttSP_a_SOURCES) $(sdr_core_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d "$(distdir)" \
+    || { find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr "$(distdir)"; }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+sdr_core_SOURCES = sdr-main.c sdrexport.c
+sdr_core_LDADD = libDttSP.a
+noinst_LIBRARIES = libDttSP.a
+libDttSP_a_SOURCES = \
+	am_demod.c\
+	am_demod.h \
+	banal.c\
+	banal.h\
+	bufvec.c\
+	bufvec.h\
+	correctIQ.c\
+	correctIQ.h\
+	cwtones.c\
+	cwtones.h\
+	cxops.c\
+	cxops.h\
+	dcblock.c\
+	dcblock.h\
+	dttspagc.c\
+	dttspagc.h\
+	fastrig.c\
+	fastrig.h\
+	filter.c\
+	filter.h\
+	fm_demod.c\
+	fm_demod.h\
+	graphiceq.c\
+	graphiceq.h\
+	halfband.c\
+	halfband.h\
+	hilbert.c\
+	hilbert.h\
+	isoband.c\
+	isoband.h\
+	lmadf.c\
+	lmadf.h\
+	meter.c\
+	meter.h\
+	noiseblanker.c\
+	noiseblanker.h\
+	oscillator.c\
+	oscillator.h\
+	ovsv.c\
+	ovsv.h\
+	resample.c\
+	resample.h\
+	ringb.c\
+	ringb.h\
+	sdr.c\
+	sdrexport.h\
+	spectrum.c\
+	spectrum.h\
+	speechproc.c\
+	speechproc.h\
+	splitfields.c\
+	splitfields.h\
+	spottone.c\
+	spottone.h\
+	thunk.c\
+	thunk.h\
+	window.c\
+	window.h\
+	waveshape.c\
+	waveshape.h\
+	wscompand.c\
+	wscompand.h\
+	update.c \
+	update.h\
+	common.h\
+	complex.h\
+	datatypes.h\
+	defs.h\
+	fromsys.h\
+	keyer.h\
+	local.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+am--refresh:
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --gnu'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --gnu \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libDttSP.a: $(libDttSP_a_OBJECTS) $(libDttSP_a_DEPENDENCIES) 
+	-rm -f libDttSP.a
+	$(libDttSP_a_AR) libDttSP.a $(libDttSP_a_OBJECTS) $(libDttSP_a_LIBADD)
+	$(RANLIB) libDttSP.a
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	for p in $$list; do echo "$$p $$p"; done | \
+	sed 's/$(EXEEXT)$$//' | \
+	while read p p1; do if test -f $$p; \
+	  then echo "$$p"; echo "$$p"; else :; fi; \
+	done | \
+	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
+	sed 'N;N;N;s,\n, ,g' | \
+	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
+	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
+	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
+	    else { print "f", $$3 "/" $$4, $$1; } } \
+	  END { for (d in files) print "f", d, files[d] }' | \
+	while read type dir files; do \
+	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
+	    test -z "$$files" || { \
+	      echo " $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
+	      $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
+	    } \
+	; done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	files=`for p in $$list; do echo "$$p"; done | \
+	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
+	      -e 's/$$/$(EXEEXT)/' `; \
+	test -n "$$list" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(bindir)" && rm -f $$files
+
+clean-binPROGRAMS:
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
+sdr-core$(EXEEXT): $(sdr_core_OBJECTS) $(sdr_core_DEPENDENCIES) 
+	@rm -f sdr-core$(EXEEXT)
+	$(LINK) $(sdr_core_OBJECTS) $(sdr_core_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/am_demod.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/banal.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bufvec.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/correctIQ.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cwtones.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cxops.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dcblock.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dttspagc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fastrig.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filter.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fm_demod.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/graphiceq.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/halfband.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hilbert.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isoband.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lmadf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/meter.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/noiseblanker.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oscillator.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ovsv.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/resample.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ringb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdr-main.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdr.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdrexport.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spectrum.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/speechproc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/splitfields.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spottone.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thunk.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/update.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/waveshape.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wscompand.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@$(am__cd) '$(distuninstallcheck_dir)' \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(PROGRAMS)
+installdirs:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-binPROGRAMS clean-generic clean-noinstLIBRARIES ctags \
+	dist dist-all dist-bzip2 dist-gzip dist-lzma dist-shar \
+	dist-tarZ dist-xz dist-zip distcheck distclean \
+	distclean-compile distclean-generic distclean-tags \
+	distcleancheck distdir distuninstallcheck dvi dvi-am html \
+	html-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-binPROGRAMS
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
--- /dev/null
+++ dttsp-0~svn675/hilbert.c
@@ -0,0 +1,239 @@
+/** 
+* @file hilbert.c
+* @brief Functions to implement Hilbert transformer 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <hilbert.h>
+
+/// cf "Musical Engineer's Handbook" by Bernie Hutchins
+
+PRIVATE REAL
+pole[12] = {
+   0.3609, 2.7412, 11.1573, 44.7581, 179.6242,  798.4578,
+   1.2524, 5.5671, 22.3423, 89.6271, 364.7914, 2770.1114
+};
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new Hilbert transformer 
+* 
+* @param ibuf 
+* @param obuf 
+* @param rate 
+* @return Hilbert
+*/
+/* ---------------------------------------------------------------------------- */
+Hilbert
+newHilbert(CXB ibuf, CXB obuf, REAL rate) {
+  Hilbert h = (Hilbert) safealloc(1, sizeof(HilbertInfo), "Hilbert Transformer");
+  h->size = CXBsize(ibuf);
+  h->c  = newvec_REAL(12, "Hilbert Transformer c vector");
+  h->x1 = newvec_REAL(12, "Hilbert Transformer x1 vector");
+  h->y1 = newvec_REAL(12, "Hilbert Transformer y1 vector");
+  {
+    int i;
+    for (i = 0; i < 12; i++) {
+      REAL u = pole[i] * M_PI * 15.0 * rate;
+      h->c[i] = (u - 1.0) / (u + 1.0);
+      h->x1[i] = h->y1[i] = 0.0;
+    }
+  }
+  h->buf.i = newCXB(h->size, CXBbase(ibuf), "Hilbert Transformer input buffer");
+  h->buf.o = newCXB(h->size, CXBbase(obuf), "Hilbert Transformer output buffer");
+  return h;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a new Hilbert transformer 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delHilbert(Hilbert h) {
+  if (h) {
+    delvec_REAL(h->c);
+    delvec_REAL(h->x1);
+    delvec_REAL(h->y1);
+    delCXB(h->buf.i);
+    delCXB(h->buf.o);
+    safefree((char *) h);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run Hilbert transformer 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+hilbert_transform(Hilbert h) {
+  REAL xn1, xn2, yn1, yn2;
+  int i;
+
+  for (i = 0; i < h->size; i++) {
+    int j;
+
+    xn1 = xn2 = CXBreal(h->buf.i, i);
+
+    for (j = 0; j < 6; j++) {
+      yn1 = h->c[j] * (xn1 - h->y1[j]) + h->x1[j];
+      h->x1[j] = xn1;
+      h->y1[j] = yn1;
+      xn1 = yn1;
+    }
+    
+    for (j = 6; j < 12; j++) {
+      yn2 = h->c[j] * (xn2 - h->y1[j]) + h->x1[j];
+      h->x1[j] = xn2;
+      h->y1[j] = yn2;
+      xn2 = yn2;
+    }
+    
+    CXBdata(h->buf.o, i) = Cmplx(yn2, yn1);
+  }
+}
+ 
+/* -------------------------------------------------------------------------- */
+/** @brief Run Hilbert simulation tranformer 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+hilsim_transform(Hilsim h) {
+  REAL *x = h->x,
+       *y = h->y,
+       *d = h->d;
+  int i;
+  
+  for (i = 0; i < h->size; i++) {
+    REAL xin = CXBreal(h->buf.i, i);
+    
+    x[0] = d[1] - xin;
+    x[1] = d[0] - x[0] * 0.00196;
+    x[2] = d[3] - x[1];
+    x[3] = d[1] + x[2] * 0.737;
+    
+    d[1] = x[1];
+    d[3] = x[3];
+    
+    y[0] = d[2] - xin;
+    y[1] = d[0] + y[0] * 0.924;
+    y[2] = d[4] - y[1];
+    y[3] = d[2] + y[2] * 0.439;
+    y[4] = d[5] - y[3];
+    y[5] = d[4] - y[4] * 0.586;
+    
+    d[2] = y[1];
+    d[4] = y[3];
+    d[5] = y[5];
+    
+    d[0] = xin;
+    
+    CXBdata(h->buf.o, i) = Cmplx(x[3], y[5]);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Hilbert simulator 
+* 
+* @param ibuf 
+* @param obuf 
+* @return Hilsim
+*/
+/* ---------------------------------------------------------------------------- */
+Hilsim
+newHilsim(CXB ibuf, CXB obuf) {
+  Hilsim h = (Hilsim) safealloc(1, sizeof(HilsimInfo), "Simple Hilbert Transformer");
+  memset((char *) h->x, 0, sizeof(h->x));
+  memset((char *) h->y, 0, sizeof(h->y));
+  memset((char *) h->d, 0, sizeof(h->d));
+  h->buf.i = newCXB(h->size, CXBbase(ibuf), "Simple Hilbert Transformer input buffer");
+  h->buf.o = newCXB(h->size, CXBbase(obuf), "Simple Hilbert Transformer output buffer");
+  return h;
+}
+ 
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy Hilbert simulator 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delHilsim(Hilsim h) {
+  if (h) {
+    delCXB(h->buf.i);
+    delCXB(h->buf.o);
+    safefree((char *) h);
+  }
+}
+
+/*
+(defstruct (hilfil (:conc-name hilf-)) x y d)
+
+(defun new-hilf ()
+  (make-hilfil :x (make-array 4 :initial-element 0.0)
+	       :y (make-array 6 :initial-element 0.0)
+	       :d (make-array 6 :initial-element 0.0)))
+
+(defun hilfilt (xin hilf)
+  (let ((x (hilf-x hilf))
+	(y (hilf-y hilf))
+	(d (hilf-d hilf)))
+    (setf (aref x 0) (- (aref d 1) xin)
+	  (aref x 1) (- (aref d 0) (* (aref x 0) 0.00196))
+	  (aref x 2) (- (aref d 3) (aref x 1))
+	  (aref x 3) (+ (aref d 1) (* (aref x 2) 0.737))
+	  (aref d 1) (aref x 1)
+	  (aref d 3) (aref x 3)
+	  (aref y 0) (- (aref d 2) xin)
+	  (aref y 1) (+ (aref d 0) (* (aref y 0) 0.924))
+	  (aref y 2) (- (aref d 4) (aref y 1))
+	  (aref y 3) (+ (aref d 2) (* (aref y 2) 0.439))
+	  (aref y 4) (- (aref d 5) (aref y 3))
+	  (aref y 5) (- (aref d 4) (* (aref y 4) 0.586))
+	  (aref d 5) (aref y 5)
+	  (aref d 4) (aref y 3)
+	  (aref d 2) (aref y 1)
+	  (aref d 0) xin)
+    (values (aref x 3) (aref y 5))))
+
+ */  
--- /dev/null
+++ dttsp-0~svn675/iambic-keyer-e.c
@@ -0,0 +1,888 @@
+/* iambic-keyer.c */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+The code in this file is derived from routines originally written by
+Pierre-Philippe Coupard for his CWirc X-chat program. That program
+is issued under the GPL and is
+Copyright (C) Pierre-Philippe Coupard - 18/06/2003
+
+This derived version is
+Copyright (C) 2004-2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <linux/rtc.h>
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <oscillator.h>
+#include <cwtones.h>
+
+//========================================================================
+
+#define L_KEY_DOWN	  (01 << 00)
+#define R_KEY_DOWN	  (01 << 01)
+
+#define NO_TIME_LEFTS_SCHED	(-2)
+#define NO_ELEMENT		(-1)
+#define DIT			 (0)
+#define DAH			 (1)
+#define MODE_A			 (0)
+#define MODE_B			 (1)
+#define NO_PADDLE_SQUEEZE	 (0)
+#define PADDLES_SQUEEZED	 (1)
+#define PADDLES_RELEASED	 (2)
+#define NO_DELAY		 (0)
+#define CHAR_SPACING_DELAY	 (1)
+#define WORD_SPACING_DELAY	 (2)
+#define DEBOUNCE_BUF_MAX_SIZE	(30)
+
+//========================================================================
+
+typedef
+struct _keyer_state {
+  struct {
+    BOOLEAN iambic,	// iambic or straight
+      	    mdlmdB,	// set true if mode B
+            revpdl;	// paddles reversed
+    struct {
+      BOOLEAN dit, dah;
+    } memory;		// set both true for mode B
+    struct {
+      BOOLEAN khar, word;
+    } autospace;
+  } flag;
+  int debounce,	// # seconds to read paddles
+      mode,	// 0 = mode A, 1 = mode B
+      weight;	// 15 -> 85%
+  double wpm;	// for iambic keyer
+} KeyerStateInfo, *KeyerState;
+
+extern KeyerState newKeyerState(void);
+extern void delKeyerState(KeyerState ks);
+
+//------------------------------------------------------------------------
+
+typedef
+struct _keyer_logic {
+  struct {
+    BOOLEAN init;
+    struct {
+      BOOLEAN dit, dah;
+    } prev;
+  } flag;
+  struct {
+    BOOLEAN altrn, // insert alternate element
+            psqam; // paddles squeezed after mid-element
+    int curr, // -1 = nothing, 0 = dit, 1 = dah
+        iamb, //  0 = none, 1 = squeezed, 2 = released
+        last; // -1 = nothing, 0 = dit, 1 = dah
+  } element;
+  struct {
+    double beep, dlay, elem, midl;
+  } time_left;
+  int dlay_type; // 0 = none, 1 = interchar, 2 = interword
+} KeyerLogicInfo, *KeyerLogic;
+
+extern KeyerLogic newKeyerLogic(void);
+extern void delKeyerLogic(KeyerLogic kl);
+
+extern BOOLEAN klogic(KeyerLogic kl,
+		      BOOLEAN dit,
+		      BOOLEAN dah,
+		      double wpm,
+		      int iambicmode,
+		      BOOLEAN need_midelemodeB,
+		      BOOLEAN want_dit_mem,
+		      BOOLEAN want_dah_mem,
+		      BOOLEAN autocharspacing,
+		      BOOLEAN autowordspacing,
+		      int weight,
+		      double ticklen);
+
+//========================================================================
+//========================================================================
+//========================================================================
+
+#define SAMP_RATE (48000)
+
+// # times key is sampled per sec
+//#define RTC_RATE (64)
+#define RTC_RATE (1024)
+
+// # samples generated during 1 clock tick at RTC_RATE
+#define TONE_SIZE (SAMP_RATE / RTC_RATE)
+
+// ring buffer size
+#define RING_SIZE (01 << 022)
+
+KeyerState ks;
+KeyerLogic kl;
+
+pthread_t poller, play, key, update, outside;
+sem_t poll_action, clock_fired, keyer_started, update_ok, state_change;
+int poll_status;
+
+int fdser, fdrtc;
+
+jack_client_t *client;
+jack_port_t *lport, *rport;
+jack_ringbuffer_t *lring, *rring;
+jack_nframes_t size;
+
+CWToneGen gen;
+BOOLEAN playing = FALSE, iambic = FALSE;
+double wpm = 18.0, freq = 700.0, ramp = 5.0, gain = -3.0, hang = 200.0;
+
+//========================================================================
+//========================================================================
+//========================================================================
+
+/* Get most recent input port status,
+   do debouncing,
+   then return the key state */
+
+BOOLEAN
+read_straight_key(KeyerState ks) {
+  int i, j, status;
+  static BOOLEAN keystate = 0;
+  static int debounce_buf_i = 0,
+             debounce_buf[DEBOUNCE_BUF_MAX_SIZE];
+
+  /* Get the key state */
+  sem_wait(&poll_action);
+  status = poll_status;
+  poll_status = 0;
+
+  debounce_buf[debounce_buf_i] = status & (L_KEY_DOWN | R_KEY_DOWN);
+  debounce_buf_i++;
+
+  /* If the debounce buffer is full,
+     determine the state of the key */
+  if (debounce_buf_i >= ks->debounce) {
+    debounce_buf_i = 0;
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (debounce_buf[i])
+	j++;
+    keystate = (j > ks->debounce / 2) ? 1 : 0;
+  }
+
+  return keystate;
+}
+
+//------------------------------------------------------------------------
+
+/* Get most recent input port status,
+   do debouncing,
+   emulate a straight key,
+   then return the emulated key state */
+
+BOOLEAN
+read_iambic_key(KeyerState ks, KeyerLogic kl, double ticklen) {
+  int i, j, status;
+  static BOOLEAN dah_debounce_buf[DEBOUNCE_BUF_MAX_SIZE],
+                 dit_debounce_buf[DEBOUNCE_BUF_MAX_SIZE];
+  static int dah = 0, debounce_buf_i = 0, dit = 0;
+
+  /* Get the key states */
+  sem_wait(&poll_action);
+  status = poll_status;
+  poll_status = 0;
+
+  if (ks->flag.revpdl) {
+    dah_debounce_buf[debounce_buf_i] = status & L_KEY_DOWN;
+    dit_debounce_buf[debounce_buf_i] = status & R_KEY_DOWN;
+  } else {
+    dit_debounce_buf[debounce_buf_i] = status & R_KEY_DOWN;
+    dah_debounce_buf[debounce_buf_i] = status & L_KEY_DOWN;
+  }
+  debounce_buf_i++;
+
+  /* If the debounce buffer is full, determine the state of the keys */
+  if (debounce_buf_i >= ks->debounce) {
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (dah_debounce_buf[i]) j++;
+    dah = (j > ks->debounce / 2) ? 1 : 0;
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (dit_debounce_buf[i]) j++;
+    dit = (j > ks->debounce / 2) ? 1 : 0;
+
+    debounce_buf_i = 0;
+  }
+
+  return klogic(kl,
+		dit,
+		dah,
+		ks->wpm,
+		ks->mode,
+		ks->flag.mdlmdB,
+		ks->flag.memory.dit,
+		ks->flag.memory.dah,
+		ks->flag.autospace.khar,
+		ks->flag.autospace.word,
+		ks->weight,
+		ticklen);
+}
+
+//========================================================================
+
+BOOLEAN
+klogic(KeyerLogic kl,
+       BOOLEAN dit,
+       BOOLEAN dah,
+       double wpm,
+       int iambicmode,
+       BOOLEAN need_midelemodeB,
+       BOOLEAN want_dit_mem,
+       BOOLEAN want_dah_mem,
+       BOOLEAN autocharspacing,
+       BOOLEAN autowordspacing,
+       int weight,
+       double ticklen) {
+
+  double ditlen = 1200 / wpm;
+  int set_which_ele_time_left = NO_TIME_LEFTS_SCHED;
+
+  /* Do we need to initialize the keyer? */
+  if (!kl->flag.init) {
+    kl->flag.prev.dit = dit;
+    kl->flag.prev.dah = dah;
+    kl->element.last = kl->element.curr = NO_ELEMENT;
+    kl->element.iamb = NO_PADDLE_SQUEEZE;
+    kl->element.psqam = 0;
+    kl->element.altrn = 0;
+    kl->time_left.midl = kl->time_left.beep = kl->time_left.elem = 0;
+    kl->time_left.dlay = 0;
+    kl->dlay_type = NO_DELAY;
+    kl->flag.init = 1;
+  }
+
+  /* Decrement the time_lefts */
+  kl->time_left.dlay -= kl->time_left.dlay > 0 ? ticklen : 0;
+  if (kl->time_left.dlay <= 0) {
+    /* If nothing is scheduled to play,
+       and we just did a character space delay,
+       and we're doing auto word spacing,
+       then pause for a word space,
+       otherwise resume the normal element time_left countdowns */
+    if (kl->time_left.elem <= 0 &&
+	kl->dlay_type == CHAR_SPACING_DELAY &&
+	autowordspacing) {
+      kl->time_left.dlay = ditlen * 4;
+      kl->dlay_type = WORD_SPACING_DELAY;
+    } else {
+      kl->dlay_type = NO_DELAY;
+      kl->time_left.midl -= kl->time_left.midl > 0 ? ticklen : 0;
+      kl->time_left.beep -= kl->time_left.beep > 0 ? ticklen : 0;
+      kl->time_left.elem -= kl->time_left.elem > 0 ? ticklen : 0;
+    }
+  }
+
+  /* Are both paddles squeezed? */
+  if (dit && dah) {
+    kl->element.iamb = PADDLES_SQUEEZED;
+    /* Are the paddles squeezed past the middle of the element? */
+    if (kl->time_left.midl <= 0)
+      kl->element.psqam = 1;
+  } else if (!dit && !dah && kl->element.iamb == PADDLES_SQUEEZED)
+    /* Are both paddles released and we had gotten a squeeze in this element? */
+    kl->element.iamb = PADDLES_RELEASED;
+
+  /* Is the current element finished? */
+  if (kl->time_left.elem <= 0 && kl->element.curr != NO_ELEMENT) {
+    kl->element.last = kl->element.curr;
+
+    /* Should we insert an alternate element? */
+    if (((dit && dah) ||
+	 (kl->element.altrn &&
+	  kl->element.iamb != PADDLES_RELEASED) ||
+	 (kl->element.iamb == PADDLES_RELEASED &&
+	  iambicmode == MODE_B &&
+	  (!need_midelemodeB || kl->element.psqam)))) {
+      if (kl->element.last == DAH)
+	set_which_ele_time_left = kl->element.curr = DIT;
+      else
+	set_which_ele_time_left = kl->element.curr = DAH;
+
+    } else {
+      /* No more element */
+      kl->element.curr = NO_ELEMENT;
+      /* Do we do automatic character spacing? */
+      if (autocharspacing && !dit && !dah) {
+	kl->time_left.dlay = ditlen * 2;
+	kl->dlay_type = CHAR_SPACING_DELAY;
+      }
+    }
+
+    kl->element.altrn = 0;
+    kl->element.iamb = NO_PADDLE_SQUEEZE;
+    kl->element.psqam = 0;
+  }
+
+  /* Is an element not currently being played? */
+  if (kl->element.curr == NO_ELEMENT) {
+    if (dah)		/* Dah paddle down? */
+      set_which_ele_time_left = kl->element.curr = DAH;
+    else if (dit)	/* Dit paddle down? */
+      set_which_ele_time_left = kl->element.curr = DIT;
+  }
+
+  /* Take the dah memory request into account */
+  if (kl->element.curr == DIT &&
+      !kl->flag.prev.dah &&
+      dah &&
+      want_dah_mem)
+    kl->element.altrn = 1;
+
+  /* Take the dit memory request into account */
+  if (kl->element.curr == DAH &&
+      !kl->flag.prev.dit &&
+      dit &&
+      want_dit_mem)
+    kl->element.altrn = 1;
+
+  /* If we had a dit or dah scheduled for after a delay,
+     and both paddles are up before the end of the delay,
+     and we have not requested dit or dah memory,
+     forget it
+     NB can't happen in full mode B */
+
+  if (kl->time_left.dlay > 0 && !dit && !dah &&
+      ((kl->element.curr == DIT && !want_dit_mem) ||
+       (kl->element.curr == DAH && !want_dah_mem)))
+    set_which_ele_time_left = kl->element.curr = NO_ELEMENT;
+
+  /* Set element time_lefts, if needed */
+  switch (set_which_ele_time_left) {
+  case NO_ELEMENT:		/* Cancel any element */
+    kl->time_left.beep = 0;
+    kl->time_left.midl = 0;
+    kl->time_left.elem = 0;
+    break;
+
+  case DIT:			/* Schedule a dit */
+    kl->time_left.beep = (ditlen * (double) weight) / 50;
+    kl->time_left.midl = kl->time_left.beep / 2;
+    kl->time_left.elem = ditlen * 2;
+    break;
+
+  case DAH:			/* Schedule a dah */
+    kl->time_left.beep = (ditlen * (double) weight) / 50 + ditlen * 2;
+    kl->time_left.midl = kl->time_left.beep / 2;
+    kl->time_left.elem = ditlen * 4;
+    break;
+  }
+
+  kl->flag.prev.dit = dit;
+  kl->flag.prev.dah = dah;
+
+  return kl->time_left.beep > 0 && kl->time_left.dlay <= 0;
+}
+
+KeyerState
+newKeyerState(void) {
+  return (KeyerState) safealloc(1, sizeof(KeyerStateInfo), "newKeyerState");
+}
+
+void
+delKeyerState(KeyerState ks) {
+  safefree((char *) ks);
+}
+
+KeyerLogic
+newKeyerLogic(void) {
+  return (KeyerLogic) safealloc(1, sizeof(KeyerLogicInfo), "newKeyerLogic");
+}
+
+void
+delKeyerLogic(KeyerLogic kl) {
+  safefree((char *) kl);
+}
+
+//========================================================================
+
+void
+jack_ringbuffer_clear(jack_ringbuffer_t *ring, int nbytes) {
+  int i;
+  char zero = 0;
+  for (i = 0; i < nbytes; i++)
+    jack_ringbuffer_write(ring, &zero, 1);
+}
+
+void
+jack_ringbuffer_restart(jack_ringbuffer_t *ring, int nbytes) {
+  jack_ringbuffer_reset(ring);
+  jack_ringbuffer_clear(ring, nbytes);
+}
+
+//------------------------------------------------------------
+
+// generated tone -> output ringbuffer
+void
+send_tone(void) {
+  if (jack_ringbuffer_write_space(lring) < TONE_SIZE * sizeof(float)) {
+    write(2, "overrun tone\n", 13);
+    jack_ringbuffer_restart(lring, TONE_SIZE * sizeof(float));
+    jack_ringbuffer_restart(rring, TONE_SIZE * sizeof(float));
+  } else {
+    int i;
+    for (i = 0; i < gen->size; i++) {
+      float l = CXBreal(gen->buf, i),
+	    	r = CXBimag(gen->buf, i);
+      jack_ringbuffer_write(lring, (char *) &l, sizeof(float));
+      jack_ringbuffer_write(rring, (char *) &r, sizeof(float));
+    }
+  }
+}
+
+// silence -> output ringbuffer
+void
+send_silence(void) {
+  if (jack_ringbuffer_write_space(lring) < TONE_SIZE * sizeof(float)) {
+    write(2, "overrun zero\n", 13);
+    jack_ringbuffer_restart(lring, TONE_SIZE * sizeof(float));
+    jack_ringbuffer_restart(rring, TONE_SIZE * sizeof(float));
+  } else {
+    int i;
+    for (i = 0; i < gen->size; i++) {
+      float zero = 0.0;
+      jack_ringbuffer_write(lring, (char *) &zero, sizeof(float));
+      jack_ringbuffer_write(rring, (char *) &zero, sizeof(float));
+    }
+  }
+}
+
+//------------------------------------------------------------------------
+
+// sound/silence generation
+// tone turned on/off asynchronously
+
+void
+sound_thread(void) {
+  for (;;) {
+    sem_wait(&clock_fired);
+
+    if (playing) {
+      // CWTone keeps playing for awhile after it's turned off,
+      // in order to allow for a decay envelope;
+      // returns FALSE when it's actually done.
+      playing = CWTone(gen);
+      send_tone();
+    } else {
+      send_silence();
+      // only let updates run when we've just generated silence
+      sem_post(&update_ok);
+    }
+  }
+
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+void
+poll_thread(void) {
+  struct timespec req, rem;
+  req.tv_sec = 0;
+  req.tv_nsec = 1000000;
+  for (;;) {
+    int status;
+    nanosleep(&req, &rem);
+    if (ioctl(fdser, TIOCMGET, &status) != -1) {
+      if (status & TIOCM_DSR)
+	poll_status |= L_KEY_DOWN;
+      if (status & TIOCM_CTS)
+	poll_status |= R_KEY_DOWN;
+      sem_post(&poll_action);
+    }
+  }
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+// basic heartbeat
+// returns actual dur in msec since last tick;
+// uses Linux rtc interrupts.
+// other strategies will work too, so long as they
+// provide a measurable delay in msec.
+
+double
+timed_delay(void) {
+  double del;
+  unsigned long data;
+  if (read(fdrtc, &data, sizeof(unsigned long)) == -1) {
+    perror("read");
+    exit(1);
+  }
+  del = (data >> 010) * 1000 / (double) RTC_RATE;
+  return del;
+}
+
+// key down? (real or via keyer logic)
+
+BOOLEAN
+read_key(double del) {
+  if (iambic)
+    return read_iambic_key(ks, kl, del);
+  else
+    return read_straight_key(ks);
+}
+
+//------------------------------------------------------------------------
+
+// main keyer loop
+
+void
+key_thread(void) {
+
+  sem_wait(&keyer_started);
+
+  for (;;) {
+    double del = timed_delay();
+    BOOLEAN keydown = read_key(del);
+
+    if (!playing && keydown) {
+      CWToneOn(gen);
+      playing = TRUE;
+      sem_post(&state_change);
+    } else if (playing && !keydown)
+      CWToneOff(gen);
+      sem_post(&state_change);
+    }	
+
+    sem_post(&clock_fired);
+  }
+
+  pthread_exit(0);
+}
+
+void
+state_watcher_thread(void) {
+
+  for (;;) {
+    sem_wait(&state_change);
+    if (playing)
+      notify_keydown();
+    else {
+      do_hangtime();
+      notify_keyup();
+    }
+  }
+
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+// update keyer parameters via text input from stdin
+// <wpm xxx>  -> set keyer speed to xxx
+// <gain xxx> -> set gain to xxx (dB)
+// <freq xxx> -> set freq to xxx
+// <ramp xxx> -> set attack/decay times to xxx ms
+// <quit>     -> terminate keyer
+
+#define MAX_ESC (512)
+#define ESC_L '<'
+#define ESC_R '>'
+
+void
+update_thread(void) {
+  for (;;) {
+    int c;
+
+    // get or wait for next input char
+    if ((c = getchar()) == EOF) goto finish;
+
+    // if we see the beginning of a command,
+    if (c == ESC_L) {
+      int i = 0;
+      char buf[MAX_ESC];
+
+      // gather up the remainder
+      while ((c = getchar()) != EOF) {
+	if (c == ESC_R) break;
+	buf[i] = c;
+	if (++i >= (MAX_ESC - 1)) break;
+      }
+      if (c == EOF) goto finish;
+      buf[i] = 0;
+
+      // wait until changes are safe
+      sem_wait(&update_ok);
+
+      if (!strncmp(buf, "wpm", 3))
+	ks->wpm = wpm = atof(buf + 3);
+      else if (!strncmp(buf, "ramp", 4)) {
+	ramp = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "freq", 4)) {
+	freq = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "gain", 4)) {
+	gain = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "quit", 4))
+	goto finish;
+
+    } // otherwise go around again
+  }
+
+  // we saw an EOF or quit; kill other threads and exit neatly
+
+ finish:
+  pthread_cancel(poller);
+  pthread_cancel(play);
+  pthread_cancel(key);
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+PRIVATE void
+jack_xrun(void *arg) {
+  char *str = "xrun";
+  write(2, str, strlen(str));
+}
+
+PRIVATE void
+jack_shutdown(void *arg) {}
+
+PRIVATE void
+jack_callback(jack_nframes_t nframes, void *arg) {
+  float *lp, *rp;
+  int nbytes = nframes * sizeof(float);
+  if (nframes == size) {
+    // output: copy from ring to port
+    lp = (float *) jack_port_get_buffer(lport, nframes);
+    rp = (float *) jack_port_get_buffer(rport, nframes);
+    if (jack_ringbuffer_read_space(lring) >= nbytes) {
+      jack_ringbuffer_read(lring, (char *) lp, nbytes);
+      jack_ringbuffer_read(rring, (char *) rp, nbytes);
+    } else { // rb pathology
+      memset((char *) lp, 0, nbytes);
+      memset((char *) rp, 0, nbytes);
+      jack_ringbuffer_reset(lring);
+      jack_ringbuffer_reset(rring);
+      jack_ringbuffer_clear(lring, TONE_SIZE * sizeof(float));
+      jack_ringbuffer_clear(rring, TONE_SIZE * sizeof(float));
+      //write(2, "underrun\n", 9); 
+    }
+  }
+}
+
+int
+main(int argc, char **argv) {
+  int i;
+  char *serialdev = "/dev/ttyS0",
+       *clockdev = "/dev/rtc";
+  int serstatus;
+
+  for (i = 1; i < argc; i++)
+    if (argv[i][0] == '-')
+      switch (argv[i][1]) {
+      case 'f':
+	freq = atof(argv[++i]);
+	break;
+      case 'i':
+	iambic = TRUE;
+	break;
+      case 'g':
+	gain = atof(argv[++i]);
+	break;
+      case 'r':
+	ramp = atof(argv[++i]);
+	break;
+      case 'w':
+	wpm = atof(argv[++i]);
+	break;
+      default:
+	fprintf(stderr,
+		"iambic-keyer [-i] [-w wpm] [-g gain_dB] [-r ramp_ms]\n");
+	exit(1);
+      }
+    else break;
+
+  if (i < argc) {
+    if (!freopen(argv[i], "r", stdin))
+      perror(argv[i]), exit(1);
+    i++;
+  }
+
+  //------------------------------------------------------------
+
+  gen = newCWToneGen(gain, freq, ramp, ramp, TONE_SIZE, 48000.0);
+
+  //------------------------------------------------------------
+
+  kl = newKeyerLogic();
+  ks = newKeyerState();
+  ks->flag.iambic = TRUE;
+  ks->flag.revpdl = TRUE;
+  // set On by default; straight key never sees them,
+  // mode A users are on their own
+  ks->flag.mdlmdB = ks->flag.memory.dit = ks->flag.memory.dah = TRUE;
+  ks->flag.autospace.khar = ks->flag.autospace.word = FALSE;
+  ks->debounce = 1;
+  ks->mode = MODE_B;
+  ks->weight = 50;
+  ks->wpm = wpm;
+
+  //------------------------------------------------------------
+
+  if (!(client = jack_client_new("ikyr")))
+    fprintf(stderr, "can't make client -- jack not running?\n"), exit(1);
+  jack_set_process_callback(client, (void *) jack_callback, 0);
+  jack_on_shutdown(client, (void *) jack_shutdown, 0);
+  jack_set_xrun_callback(client, (void *) jack_xrun, 0);
+  size = jack_get_buffer_size(client);
+  lport = jack_port_register(client,
+			     "ol",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  rport = jack_port_register(client,
+			     "or",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  lring = jack_ringbuffer_create(RING_SIZE);
+  rring = jack_ringbuffer_create(RING_SIZE);
+  jack_ringbuffer_clear(lring, TONE_SIZE * sizeof(float));
+  jack_ringbuffer_clear(rring, TONE_SIZE * sizeof(float));
+  
+  //------------------------------------------------------------
+
+  // key
+  if ((fdser = open(serialdev, O_WRONLY)) == -1) {
+    fprintf(stderr, "cannot open serial device %s", serialdev);
+    exit(1);
+  }
+  if (ioctl(fdser, TIOCMGET, &serstatus) == -1) {
+    close(fdser);
+    fprintf(stderr, "cannot get serial device status");
+    exit(1);
+  }
+  serstatus |= TIOCM_DTR;
+  if (ioctl(fdser, TIOCMSET, &serstatus) == -1) {
+    close(fdser);
+    fprintf(stderr, "cannot set serial device status");
+    exit(1);
+  }
+
+  // rtc
+  if ((fdrtc = open(clockdev, O_RDONLY)) == -1) {
+    perror(clockdev);
+    exit(1);
+  }
+  if (ioctl(fdrtc, RTC_IRQP_SET, RTC_RATE) == -1) {
+    perror("ioctl irqp");
+    exit(1);
+  }
+  if (ioctl(fdrtc, RTC_PIE_ON, 0) == -1) {
+    perror("ioctl pie on");
+    exit(1);
+  }
+
+  //------------------------------------------------------------
+
+  sem_init(&poll_action, 0, 0);
+  sem_init(&clock_fired, 0, 0);
+  sem_init(&keyer_started, 0, 0);
+  sem_init(&update_ok, 0, 0);
+  sem_init(&state_change, 0, 0);
+  pthread_create(&poller, 0, (void *) poll_thread, 0);
+  pthread_create(&play, 0, (void *) sound_thread, 0);
+  pthread_create(&key, 0, (void *) key_thread, 0);
+  pthread_create(&update, 0, (void *) update_thread, 0);
+  pthread_create(&outside, 0, (void *) state_change_thread, 0);
+
+  //------------------------------------------------------------
+
+  jack_activate(client);
+  {
+    const char **ports;
+    if (!(ports = jack_get_ports(client, 0, 0, JackPortIsPhysical | JackPortIsInput))) {
+      fprintf(stderr, "can't find any physical playback ports\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(lport), ports[0])) {
+      fprintf(stderr, "can't connect left output\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(rport), ports[1])) {
+      fprintf(stderr, "can't connect left output\n");
+      exit(1);
+    }
+    free(ports);
+  }
+
+  sem_post(&keyer_started);
+
+  pthread_join(poller, 0);
+  pthread_join(play, 0);
+  pthread_join(key, 0);
+  pthread_join(update, 0);
+  pthread_join(outside, 0);
+  jack_client_close(client);
+
+  //------------------------------------------------------------
+
+  if (ioctl(fdrtc, RTC_PIE_OFF, 0) == -1) {
+    perror("ioctl pie off");
+    exit(1);
+  }
+  close(fdrtc);
+  close(fdser);
+
+  jack_ringbuffer_free(lring);
+  jack_ringbuffer_free(rring);
+
+  sem_destroy(&poll_action);
+  sem_destroy(&clock_fired);
+  sem_destroy(&keyer_started);
+  sem_destroy(&state-change);
+
+  delCWToneGen(gen);
+  delKeyerState(ks);
+  delKeyerLogic(kl);
+
+  //------------------------------------------------------------
+
+  exit(0);
+}
--- /dev/null
+++ dttsp-0~svn675/common.h
@@ -0,0 +1,75 @@
+/* common.h
+a simple way to get all the necessary includes
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _common_h
+#define _common_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <ringb.h>
+#include <fftw3.h>
+#include <window.h>
+#include <ovsv.h>
+#include <filter.h>
+#include <oscillator.h>
+#include <hilbert.h>
+#include <lmadf.h>
+#include <dttspagc.h>
+#include <am_demod.h>
+#include <fm_demod.h>
+#include <resample.h>
+#include <noiseblanker.h>
+#include <correctIQ.h>
+#include <dcblock.h>
+#include <graphiceq.h>
+#include <speechproc.h>
+#include <wscompand.h>
+#include <spottone.h>
+#include <cwtones.h>
+#include <update.h>
+#include <meter.h>
+#include <spectrum.h>
+#include <isoband.h>
+#include <hilbert.h>
+#include <halfband.h>
+#include <waveshape.h>
+
+#include <sdrexport.h>
+#include <local.h>
+#endif
--- /dev/null
+++ dttsp-0~svn675/thunk.c
@@ -0,0 +1,95 @@
+/** 
+* @file thunk.c
+* @brief Function to cross map a key table to a hash table 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+ This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <common.h>
+#include <thunk.h>
+
+PRIVATE BOOLEAN
+/* -------------------------------------------------------------------------- */
+/** @brief streq 
+* 
+* @param p 
+* @param q 
+*/
+/* ---------------------------------------------------------------------------- */
+streq(char *p, char *q) {
+  return !strcmp(p, q);
+}
+
+/** somewhere along the line
+   we'll kick this up a notch
+   with gperf */
+
+/* -------------------------------------------------------------------------- */
+/** @brief Lookup function for thunk 
+* 
+* @param ctb 
+* @param key 
+* @return Thunk
+*/
+/* ---------------------------------------------------------------------------- */
+Thunk
+Thunk_lookup(CTB ctb, char *key) {
+  if (key && *key) {
+    for (;;) {
+      if (!ctb || !ctb->key || !ctb->thk)
+	break;
+      if (streq(key, ctb->key))
+	return ctb->thk;
+      ctb++;
+    }
+  }
+  return (Thunk) 0;
+}
+
+#ifdef notdef
+/* -------------------------------------------------------------------------- */
+/** @brief Hash table lookup used if notedef is not defined 
+* 
+* @param str 
+* @return unsigned long 
+*/
+/* ---------------------------------------------------------------------------- */
+unsigned long
+hash(unsigned char *str) {
+  unsigned long hash = 5381;
+  int c;
+  while (c = *str++)
+    hash = ((hash << 5) + hash) + c;	// (hash * 33 + c) better
+  return hash;
+}
+#endif
--- /dev/null
+++ dttsp-0~svn675/splitfields.c
@@ -0,0 +1,151 @@
+/** 
+* @file splitfields.c
+* @brief Functions to split character fields 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <splitfields.h>
+
+static char *_white = " \t\n";
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new character block structure 
+ * @return SPLIT
+*/
+/* ---------------------------------------------------------------------------- */
+SPLIT
+newSPLIT(void) {
+  return (SPLIT) safealloc(1, sizeof(splitfld), "splitfield");
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a character block structure
+* 
+* @param s 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delSPLIT(SPLIT s) {
+  safefree((char *) s);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to return the spliting character 
+* 
+* @param s 
+* @param i 
+* @return *char
+*/
+/* ---------------------------------------------------------------------------- */
+char *
+F(SPLIT s, int i) {
+  return s->f[i];
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to return a pointer to the spliting character 
+* 
+* @param s 
+* @param i 
+* @return *char
+*/
+/* ---------------------------------------------------------------------------- */
+char **
+Fptr(SPLIT s, int i) {
+  return &(s->f[i]);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to return the number of characters 
+* 
+* @param s 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+NF(SPLIT s) {
+  return s->n;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to break character string on tokens to a maximum value 
+* 
+* @param s  -- The split structure 
+* @param str -- vector of character stings  
+* @param delim -- the spliting token 
+* @param *fld -- character sting vector for each element in fmx 
+* @param fmx -- maximum number of element in fld vector 
+* @return The number times the splits will be less than fmx 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+splitonto(SPLIT s, char *str, char *delim, char **fld, int fmx) {
+  int i = 0;
+  char *p = strtok(str, delim);
+  while (p) {
+    fld[i] = p;
+    if (++i >= fmx)
+      break;
+    p = strtok(0, delim);
+  }
+  return i;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to break character string on tokens 
+* 
+* @param s 
+* @param str 
+* @param delim 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+spliton(SPLIT s, char *str, char *delim) {
+  return (s->n = splitonto(s, str, delim, s->f, MAXFLD));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to break a caracter string into default tokens 
+* 
+* @param s 
+* @param str 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+split(SPLIT s, char *str) {
+  spliton(s, str, _white);
+}
--- /dev/null
+++ dttsp-0~svn675/ovsv.c
@@ -0,0 +1,301 @@
+/** 
+* @file ovsv.c
+* @brief Functions to implement the OvSv filter 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <ovsv.h>
+
+
+/*------------------------------------------------------------*/
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run OvSV filter
+* 
+* @param pflt 
+* @return 
+*/
+/* ---------------------------------------------------------------------------- */
+
+/* run the filter */
+
+void
+filter_OvSv(FiltOvSv pflt) {
+  int i, m = pflt->fftlen, n = pflt->buflen;
+  COMPLEX *zfvec = pflt->zfvec,
+          *zivec = pflt->zivec,
+          *zovec = pflt->zovec,
+          *zrvec = pflt->zrvec;
+  REAL scl = pflt->scale;
+
+  /* input sig -> z */
+  fftwf_execute(pflt->pfwd);
+
+#ifdef __SSE3__
+  CmulSSE3(zivec, zivec, zfvec, m);
+#else
+  /* convolve in z */
+  for (i = 0; i < m; i++)
+    zivec[i] = Cmul(zivec[i], zfvec[i]);
+#endif
+  /* z convolved sig -> time output sig */
+  fftwf_execute(pflt->pinv);
+
+  /* scale */
+  for (i = 0; i < n; i++)
+    zovec[i].re *= scl, zovec[i].im *= scl;
+
+  /* prepare input sig vec for next fill */
+  memcpy((char *) zrvec, (char *) &zrvec[n], n * sizeof(COMPLEX));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the OvSv Filter 
+* 
+* @param pflt 
+* @return 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reset_OvSv(FiltOvSv pflt) {
+  memset((char *) pflt->zrvec, 0, pflt->fftlen * sizeof(COMPLEX));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Initial point OvSv filter  
+* 
+* NB strategy. This is the address we pass to newCXB as
+* the place to read samples into. It's the right half of
+* the true buffer. Old samples get slid from here to
+* left half after each go-around. 
+*
+* @param pflt 
+* @return 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+FiltOvSv_initpoint(FiltOvSv pflt) {
+  return &(pflt->zrvec[pflt->buflen]);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief inital size for the OvSv filter 
+* 
+* how many to put there 
+*
+* @param pflt 
+* @return 
+*/
+/* ---------------------------------------------------------------------------- */
+int
+FiltOvSv_initsize(FiltOvSv pflt) {
+  return (pflt->fftlen - pflt->buflen);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Fetch point from the OvSv filter 
+* 
+* where to put next batch of samples to filter 
+*
+* @param pflt 
+* @return *COMPLEX
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+FiltOvSv_fetchpoint(FiltOvSv pflt) {
+  return &(pflt->zrvec[pflt->buflen]);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Fetch size from OvSv filter 
+* 
+* how many samples to put there 
+*
+* @param pflt 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+FiltOvSv_fetchsize(FiltOvSv pflt) {
+  return (pflt->fftlen - pflt->buflen);
+}
+
+#ifdef LHS
+/* -------------------------------------------------------------------------- */
+/** @brief Store point OvSv Filter 
+* 
+* where samples should be taken from after filtering 
+*
+* @param pflt 
+* @return *COMPLEX
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+FiltOvSv_storepoint(FiltOvSv pflt) {
+  return ((pflt->zovec) + pflt->buflen);
+}
+#else
+/* -------------------------------------------------------------------------- */
+/** @brief Store point OvSv Filter 
+* 
+* @param pflt 
+* @return *COMPLEX
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX *
+FiltOvSv_storepoint(FiltOvSv pflt) {
+  return ((pflt->zovec));
+}
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief Store size in the OvSv filter 
+* 
+* how many samples to take 
+* NB strategy. This is the number of good samples in the
+* left half of the true buffer. Samples in right half
+* are circular artifacts and are ignored.
+*
+* @param pflt 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+FiltOvSv_storesize(FiltOvSv pflt) {
+  return (pflt->fftlen - pflt->buflen);
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new OvSv filter 
+* 
+* create a new overlap/save filter from complex coefficients 
+*
+* @param coefs 
+* @param ncoef 
+* @param pbits 
+* @return FiltOvSv
+*/
+/* ---------------------------------------------------------------------------- */
+FiltOvSv
+newFiltOvSv(COMPLEX *coefs, int ncoef, int pbits) {
+  int buflen, fftlen;
+  FiltOvSv p;
+  fftwf_plan pfwd, pinv;
+  COMPLEX *zrvec, *zfvec, *zivec, *zovec;
+  
+  p = (FiltOvSv) safealloc(1, sizeof(filt_ov_sv), "new overlap/save filter");
+  buflen = nblock2(ncoef - 1);
+  fftlen = 2 * buflen;
+
+  zrvec = newvec_COMPLEX_fftw(fftlen, "raw signal vec in newFiltOvSv");
+  zfvec = newvec_COMPLEX_fftw(fftlen, "filter z vec in newFiltOvSv");
+  zivec = newvec_COMPLEX_fftw(fftlen, "signal in z vec in newFiltOvSv");
+  zovec = newvec_COMPLEX_fftw(fftlen, "signal out z vec in newFiltOvSv");
+
+  /* prepare frequency response from filter coefs */
+  {
+    int i;
+    COMPLEX *zcvec;
+    fftwf_plan ptmp;
+
+    zcvec = newvec_COMPLEX(fftlen, "temp filter z vec in newFiltOvSv");
+    ptmp =
+      fftwf_plan_dft_1d(fftlen,
+			(fftwf_complex *) zcvec,
+			(fftwf_complex *) zfvec,
+			FFTW_FORWARD,
+			pbits);
+
+#ifdef LHS
+    for (i = 0; i < ncoef; i++)
+      zcvec[i] = coefs[i];
+#else
+    for (i = 0; i < ncoef; i++)
+      zcvec[fftlen - ncoef + i] = coefs[i];
+#endif
+
+    fftwf_execute(ptmp);
+    fftwf_destroy_plan(ptmp);
+    delvec_COMPLEX(zcvec);
+  }
+
+  /* prepare transforms for signal */
+  pfwd = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zrvec,
+			   (fftwf_complex *) zivec,
+			   FFTW_FORWARD,
+			   pbits);
+  pinv = fftwf_plan_dft_1d(fftlen,
+			   (fftwf_complex *) zivec,
+			   (fftwf_complex *) zovec,
+			   FFTW_BACKWARD,
+			   pbits);
+  /* stuff values */
+  p->buflen = buflen;
+  p->fftlen = fftlen;
+  p->zfvec = zfvec;
+  p->zivec = zivec;
+  p->zovec = zovec;
+  p->zrvec = zrvec;
+  p->pfwd = pfwd;
+  p->pinv = pinv;
+  p->scale = 1.0 / (REAL) fftlen;
+
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a OvSv filter 
+* 
+* deep-six the filter 
+*
+* @param p 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delFiltOvSv(FiltOvSv p) {
+  if (p) {
+    delvec_COMPLEX_fftw(p->zfvec);
+    delvec_COMPLEX_fftw(p->zivec);
+    delvec_COMPLEX_fftw(p->zovec);
+    delvec_COMPLEX_fftw(p->zrvec);
+    fftwf_destroy_plan(p->pfwd);
+    fftwf_destroy_plan(p->pinv);
+    safefree((char *) p);
+  }
+}
+
+/*------------------------------------------------------------*/
--- /dev/null
+++ dttsp-0~svn675/lmadf.c
@@ -0,0 +1,383 @@
+/** 
+* @file lmadf.c
+* @brief Functions to implement the FFT transforms
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <lmadf.h>
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new LMSR 
+* 
+* @param signal 
+* @param sigsize 
+* @param delay 
+* @param adaptation_rate 
+* @param leakage 
+* @param adaptive_filter_size 
+* @param filter_type 
+* @return LMSR
+*/
+/* ---------------------------------------------------------------------------- */
+LMSR
+new_lmsr(CXB signal,
+	 int sigsize,
+	 int delay,
+	 REAL adaptation_rate,
+	 REAL leakage,
+	 int adaptive_filter_size,
+	 int filter_type) {
+  LMSR lms = (LMSR) safealloc(1, sizeof(_lmsstate), "new_lmsr state");
+
+  lms->signal = signal;
+  lms->signal_size = sigsize;
+  lms->delay = delay;
+  lms->size = 512;
+  lms->mask = lms->size - 1;
+  lms->delay_line = newvec_REAL(lms->size, "lmsr delay");
+  lms->adaptation_rate = adaptation_rate;
+  lms->leakage = leakage;
+  lms->adaptive_filter_size = adaptive_filter_size;
+  lms->adaptive_filter = newvec_REAL(128, "lmsr filter");
+  lms->filter_type = filter_type;
+  lms->delay_line_ptr = 0;
+
+  return lms;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy an LMSR 
+* 
+* @param lms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_lmsr(LMSR lms) {
+  if (lms) {
+    delvec_REAL(lms->delay_line);
+    delvec_REAL(lms->adaptive_filter);
+    safefree((char *) lms);
+  }
+}
+
+// just to make the algorithm itself a little clearer,
+// get the admin stuff out of the way
+
+#define ssiz (lms->signal_size)
+#define asiz (lms->adaptive_filter_size)
+#define dptr (lms->delay_line_ptr)
+#define rate (lms->adaptation_rate)
+#define leak (lms->leakage)
+
+#define ssig(n) (CXBreal(lms->signal,(n)))
+#define ssig_i(n) (CXBimag(lms->signal,(n)))
+
+#define dlay(n) (lms->delay_line[(n)])
+
+#define afil(n) (lms->adaptive_filter[(n)])
+#define wrap(n) (((n) + (lms->delay) + (lms->delay_line_ptr)) & (lms->mask))
+#define bump(n) (((n) + (lms->mask)) & (lms->mask))
+
+/* -------------------------------------------------------------------------- */
+/** @brief private lmsr_adapt_i 
+* 
+* @param lms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+lmsr_adapt_i(LMSR lms) {
+  int i, j, k;
+  REAL sum_sq, scl1, scl2;
+  REAL accum, error;
+
+  scl1 = 1.0 - rate * leak;
+
+  for (i = 0; i < ssiz; i++) {
+
+    dlay(dptr) = ssig(i);
+    accum = 0.0;
+    sum_sq = 0.0;
+
+    for (j = 0; j < asiz; j++) {
+      k = wrap(j);
+      sum_sq += sqr(dlay(k));
+      accum += afil(j) * dlay(k);
+    }
+
+    error = ssig(i) - accum;
+    ssig_i(i) = ssig(i) = error;
+
+    scl2 = rate / (sum_sq + 1e-10);
+    error *= scl2;
+    for (j = 0; j < asiz; j++) {
+      k = wrap(j);
+      afil(j) = afil(j) * scl1 + error * dlay(k);
+    }
+
+    dptr = bump(dptr);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief lmsr_adapt_n 
+* 
+* @param lms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+lmsr_adapt_n(LMSR lms) {
+  int i, j, k;
+  REAL sum_sq, scl1, scl2;
+  REAL accum, error;
+
+  scl1 = 1.0 - rate * leak;
+
+  for (i = 0; i < ssiz; i++) {
+
+    dlay(dptr) = ssig(i);
+    accum = 0.0;
+    sum_sq = 0.0;
+
+    for (j = 0; j < asiz; j++) {
+      k = wrap(j);
+      sum_sq += sqr(dlay(k));
+      accum += afil(j) * dlay(k);
+    }
+
+    error = ssig(i) - accum;
+    ssig_i(i) = ssig(i) = accum;
+
+    scl2 = rate / (sum_sq + 1e-10);
+    error *= scl2;
+    for (j = 0; j < asiz; j++) {
+      k = wrap(j);
+      afil(j) = afil(j) * scl1 + error * dlay(k);
+    }
+
+    dptr = bump(dptr);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief lmsr_adapt 
+* 
+* @param lms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+extern void
+lmsr_adapt(LMSR lms) {
+  switch (lms->filter_type) {
+  case LMADF_NOISE:
+    lmsr_adapt_n(lms);
+    break;
+  case LMADF_INTERFERENCE:
+    lmsr_adapt_i(lms);
+    break;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief del_blms 
+* 
+* @param blms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_blms(BLMS blms) {
+  if (blms) {
+    fftwf_destroy_plan(blms->Xplan);
+    fftwf_destroy_plan(blms->Yplan);
+    fftwf_destroy_plan(blms->Errhatplan);
+    fftwf_destroy_plan(blms->UPDplan);
+    fftwf_destroy_plan(blms->Wplan);
+    delvec_COMPLEX(blms->update);
+    delvec_COMPLEX(blms->Update);
+    delvec_COMPLEX(blms->What);
+    delvec_COMPLEX(blms->Xhat);
+    delvec_COMPLEX(blms->error);
+    delvec_COMPLEX(blms->Errhat);
+    delvec_COMPLEX(blms->Yhat);
+    delvec_COMPLEX(blms->y);
+    delvec_COMPLEX(blms->delay_line);
+    safefree((char *) blms);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new BLMS 
+* 
+* @param signal 
+* @param adaptation_rate 
+* @param leak_rate 
+* @param filter_type 
+* @param pbits 
+* @return BLMS
+*/
+/* ---------------------------------------------------------------------------- */
+BLMS
+new_blms(CXB signal,
+	 REAL adaptation_rate,
+	 REAL leak_rate,
+	 int filter_type,
+	 int pbits) {
+  BLMS tmp = (BLMS) safealloc(1, sizeof(_blocklms), "block lms");
+  tmp->delay_line = newvec_COMPLEX_fftw(256, "block lms delay line");
+  tmp->y = newvec_COMPLEX_fftw(256, "block lms output signal");
+  tmp->Yhat = newvec_COMPLEX_fftw(256, "block lms output transform");
+  tmp->Errhat = newvec_COMPLEX_fftw(256, "block lms Error transform");
+  tmp->error = newvec_COMPLEX_fftw(256, "block lms Error signal");
+  tmp->Xhat = newvec_COMPLEX_fftw(256, "block lms signal transform");
+  tmp->What = newvec_COMPLEX_fftw(256, "block lms filter transform");
+  tmp->Update = newvec_COMPLEX_fftw(256, "block lms update transform");
+  tmp->update = newvec_COMPLEX_fftw(256, "block lms update signal");
+  tmp->adaptation_rate = adaptation_rate;
+  tmp->leak_rate = 1.0 - leak_rate;
+  tmp->signal = signal;
+  tmp->filter_type = filter_type;
+  tmp->Xplan = fftwf_plan_dft_1d(256,
+				 (fftwf_complex *) tmp->delay_line,
+				 (fftwf_complex *) tmp->Xhat,
+				 FFTW_FORWARD, pbits);
+  tmp->Yplan = fftwf_plan_dft_1d(256,
+				 (fftwf_complex *) tmp->Yhat,
+				 (fftwf_complex *) tmp->y,
+				 FFTW_BACKWARD, pbits);
+  tmp->Errhatplan = fftwf_plan_dft_1d(256,
+				      (fftwf_complex *) tmp->error,
+				      (fftwf_complex *) tmp->Errhat,
+				      FFTW_FORWARD, pbits);
+  tmp->UPDplan = fftwf_plan_dft_1d(256,
+				   (fftwf_complex *) tmp->Errhat,
+				   (fftwf_complex *) tmp->update,
+				   FFTW_BACKWARD, pbits);
+  tmp->Wplan = fftwf_plan_dft_1d(256,
+				 (fftwf_complex *) tmp->update,
+				 (fftwf_complex *) tmp->Update,
+				 FFTW_FORWARD, pbits);
+  return tmp;
+}
+
+#define BLKSCL 1.0f/256.0f
+
+/* -------------------------------------------------------------------------- */
+/** @brief Adept the BLMS  
+* 
+* @param blms 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+blms_adapt(BLMS blms) {
+  int sigsize = CXBhave(blms->signal),
+      sigidx = 0;
+
+  do {
+    int j;
+
+    // do overlap move
+    memcpy(blms->delay_line,
+	   &blms->delay_line[128],
+	   sizeof(COMPLEX) * 128);
+
+    // copy in new data
+    memcpy(&blms->delay_line[128],
+	   &CXBdata(blms->signal, sigidx),
+	   sizeof(COMPLEX) * 128);	
+
+    // compute transform of input data
+    fftwf_execute(blms->Xplan);
+
+    // Filter new signal in freq. domain,
+    // take input data's complex conjugate
+    for (j = 0; j < 256; j++) {
+      blms->Yhat[j] = Cmul(blms->What[j], blms->Xhat[j]);
+      blms->Xhat[j] = Conjg(blms->Xhat[j]);
+    }
+
+    //compute output signal transform
+    fftwf_execute(blms->Yplan);
+    for (j = 128; j < 256; j++)
+      blms->y[j] = Cscl(blms->y[j], BLKSCL);
+
+    memset(blms->y, 0, 128 * sizeof(COMPLEX));
+
+    // compute error signal
+    for (j = 128; j < 256; j++)
+      blms->error[j] = Csub(blms->delay_line[j], blms->y[j]);
+
+    if (blms->filter_type)
+      // if noise filter, output y
+      memcpy(&CXBdata(blms->signal, sigidx),
+	     &blms->y[128],
+	     128 * sizeof(COMPLEX));
+    else
+      // if notch filter, output error
+      memcpy(&CXBdata(blms->signal, sigidx),
+	     &blms->error[128],
+	     128 * sizeof(COMPLEX));
+
+    // compute transform of the error signal
+    fftwf_execute(blms->Errhatplan);
+
+    // compute cross correlation transform
+    for (j = 0; j < 256; j++)
+      blms->Errhat[j] = Cmul(blms->Errhat[j], blms->Xhat[j]);
+
+    // compute inverse transform of cross correlation transform
+    fftwf_execute(blms->UPDplan);
+    for (j = 0; j < 128; j++)
+      blms->update[j] = Cscl(blms->update[j], BLKSCL);
+
+    // zero the last block of the update, so we get
+    // filter coefficients only at front of buffer
+    memset(&blms->update[128], 0, sizeof(COMPLEX) * 128);
+
+    fftwf_execute(blms->Wplan);
+
+    // leak the W away
+    // update at adaptation rate
+    for (j = 0; j < 256; j++)
+      blms->What[j] = Cadd(Cscl(blms->What[j], blms->leak_rate),
+			   Cscl(blms->Update[j], blms->adaptation_rate));
+
+    // move to next block in the signal buffer
+    sigidx += 128;
+  } while (sigidx < sigsize);
+}
--- /dev/null
+++ dttsp-0~svn675/fm_demod.c
@@ -0,0 +1,181 @@
+/** 
+* @file fm_demod.c
+* @brief FM Demodulations functions 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+/** fm_demod.c 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <fm_demod.h>
+
+/*------------------------------------------------------------------------------*/
+/* private to FM */
+/*------------------------------------------------------------------------------*/
+
+/* -------------------------------------------------------------------------- */
+/** @brief private init_pll 
+* 
+* @param fm 
+* @param samprate 
+* @param freq 
+* @param lofreq 
+* @param hifreq 
+* @param bandwidth 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+init_pll(FMD fm,
+	 REAL samprate,
+	 REAL freq,
+	 REAL lofreq,
+	 REAL hifreq,
+	 REAL bandwidth) {
+  REAL fac = (REAL) (TWOPI / samprate);
+
+  fm->pll.freq.f = freq * fac;
+  fm->pll.freq.l = lofreq * fac;
+  fm->pll.freq.h = hifreq * fac;
+  fm->pll.phs = 0.0;
+  fm->pll.delay = cxJ;
+
+  fm->pll.iir.alpha = bandwidth * fac;	/* arm filter */
+  fm->pll.alpha = fm->pll.iir.alpha * 0.3;	/* pll bandwidth */
+  fm->pll.beta = fm->pll.alpha * fm->pll.alpha * 0.25;	/* second order term */
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private pll 
+* 
+* @param fm 
+* @param sig 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+pll(FMD fm, COMPLEX sig) {
+  COMPLEX z = Cmplx((REAL) cos(fm->pll.phs), (IMAG) sin(fm->pll.phs));
+  REAL diff;
+
+  fm->pll.delay.re = z.re * sig.re + z.im * sig.im;
+  fm->pll.delay.im = -z.im * sig.re + z.re * sig.im;
+  diff = ATAN2(fm->pll.delay.im, fm->pll.delay.re);
+
+  fm->pll.freq.f += fm->pll.beta * diff;
+
+  if (fm->pll.freq.f < fm->pll.freq.l)
+    fm->pll.freq.f = fm->pll.freq.l;
+  if (fm->pll.freq.f > fm->pll.freq.h)
+    fm->pll.freq.f = fm->pll.freq.h;
+
+  fm->pll.phs += fm->pll.freq.f + fm->pll.alpha * diff;
+
+  while (fm->pll.phs >= TWOPI)
+    fm->pll.phs -= (REAL) TWOPI;
+  while (fm->pll.phs < 0)
+    fm->pll.phs += (REAL) TWOPI;
+}
+
+/*------------------------------------------------------------------------------*/
+/* public */
+/*------------------------------------------------------------------------------*/
+
+/* -------------------------------------------------------------------------- */
+/** @brief FMDmod 
+* 
+* @param fm 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+FMDemod(FMD fm) {
+  int i;
+  for (i = 0; i < CXBhave(fm->ibuf); i++) {
+    pll(fm, CXBdata(fm->ibuf, i));
+    fm->afc = (REAL) (0.9999 * fm->afc + 0.0001 * fm->pll.freq.f);
+    CXBreal(fm->obuf, i) =
+      CXBimag(fm->obuf, i) = (fm->pll.freq.f - fm->afc) * fm->cvt;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief newFMD 
+* 
+* @param samprate 
+* @param f_initial 
+* @param f_lobound 
+* @param f_hibound 
+* @param f_bandwid 
+* @param size 
+* @param ivec 
+* @param ovec 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+FMD
+newFMD(REAL samprate,
+       REAL f_initial,
+       REAL f_lobound,
+       REAL f_hibound,
+       REAL f_bandwid,
+       int size,
+       COMPLEX *ivec,
+       COMPLEX *ovec,
+       char *tag) {
+  FMD fm = (FMD) safealloc(1, sizeof(FMDDesc), tag);
+
+  fm->size = size;
+  fm->ibuf = newCXB(size, ivec, tag);
+  fm->obuf = newCXB(size, ovec, tag);
+
+  init_pll(fm, samprate, f_initial, f_lobound, f_hibound, f_bandwid);
+
+  fm->lock = 0.5;
+  fm->afc = 0.0;
+  fm->cvt = (REAL) (0.45 * samprate / (M_PI * f_bandwid));
+
+  return fm;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief delFMD 
+* 
+* @param fm 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delFMD(FMD fm) {
+  if (fm) {
+    delCXB(fm->ibuf);
+    delCXB(fm->obuf);
+    safefree((char *) fm);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/speechproc.h
@@ -0,0 +1,54 @@
+/* speechproc.h
+   
+  This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _speechproc_h
+#define _speechproc_h
+
+#include <fromsys.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <banal.h>
+
+typedef struct _speechprocessor {
+  int size;
+  RLB CG;
+  CXB SpeechProcessorBuffer;
+  REAL LastCG, K, MaxGain, fac;
+} speech_proc, *SpeechProc;
+
+extern SpeechProc newSpeechProc(REAL, REAL, COMPLEX *, int);
+extern void delSpeechProc(SpeechProc);
+extern void SpeechProcessor(SpeechProc);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/defs.h
@@ -0,0 +1,75 @@
+/* defs.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _defs_h
+#define _defs_h
+
+#define RINGMULT (2)
+#define DEFRATE (48000.0)
+#define DEFSIZE (1024)
+#define DEFBUFL (1024)
+#define DEFMODE (SAM)
+#define DEFSPEC (4096)
+#define DEFCOMP (512)
+#define DEFOFFS (0)
+
+#define MAXRX (4)
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN (2048)
+#endif
+
+typedef enum _sdrmode {
+  LSB,				//  0
+  USB,				//  1
+  DSB,				//  2
+  CWL,				//  3
+  CWU,				//  4
+  FMN,				//  5
+  AM,				//  6
+  DIGU,				//  7
+  SPEC,				//  8
+  DIGL,				//  9
+  SAM,				// 10
+  DRM				// 11
+} SDRMODE;
+
+typedef enum _trxmode { RX, TX } TRXMODE;
+
+typedef enum _swchstate {
+  SWCH_FALL,
+  SWCH_STDY,
+  SWCH_RISE
+} SWCHSTATE;
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/hilbert.h
@@ -0,0 +1,69 @@
+/* hilbert.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _hilbert_h
+#define _hilbert_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+typedef
+struct _hilbert {
+  int size;
+  REAL *c, *x1, *y1;
+  struct {
+    CXB i, o;
+  } buf;
+} HilbertInfo, *Hilbert;
+
+extern Hilbert newHilbert(CXB ibuf, CXB obuf, REAL rate);
+extern void delHilbert(Hilbert h);
+extern void hilbert_transform(Hilbert h);
+
+typedef
+struct _hilsim {
+  int size;
+  struct {
+    CXB i, o;
+  } buf;
+  REAL x[4], y[6], d[6];
+} HilsimInfo, *Hilsim;
+
+void hilsim_transform(Hilsim h);
+Hilsim newHilsim(CXB ibuf, CXB obuf);
+void delHilsim(Hilsim h);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/isoband.c
@@ -0,0 +1,157 @@
+/** 
+* @file isoband.c
+* @brief Function to implement isobands
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2006, 2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version. 
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+///////////////////////////////////////////////////////////////////////
+
+#include <isoband.h>
+
+typedef
+struct _ISOband_t {
+  REAL nominal, exact, low, high;
+} ISOband_t;
+
+static
+ISOband_t _ISOband_info[] = {
+  { /* 1 */      1.25,	  1.26,     1.12,    1.41 },
+  { /* 2 */      1.6,	  1.58,     1.41,    1.78 },
+  { /* 3 */      2.0,	  2.00,     1.78,    2.24 },
+  { /* 4 */      2.5,	  2.51,     2.24,    2.82 },
+  { /* 5 */      3.15,	  3.16,     2.82,    3.55 },
+  { /* 6 */      4.0,	  3.98,     3.55,    4.47 },
+  { /* 7 */      5.0,	  5.01,     4.47,    5.62 },
+  { /* 8 */      6.3,	  6.31,     5.62,    7.08 },
+  { /* 9 */      8.0,	  7.94,     7.08,    8.91 },
+  { /* 10 */    10.0,	 10.0,      8.91,   11.2  },
+  { /* 11 */    12.5,	 12.59,    11.2,    14.1  },
+  { /* 12 */    16.0,	 15.85,    14.1,    17.8  },
+  { /* 13 */    20.0,	 19.95,    17.8,    22.4  },
+  { /* 14 */    25.0,	 25.12,    22.4,    28.2  },
+  { /* 15 */    31.5,	 31.62,    28.2,    35.5  },
+  { /* 16 */    40.0,	 39.81,    35.5,    44.7  },
+  { /* 17 */    50.0, 	 50.12,    44.7,    56.2  },
+  { /* 18 */    63.0, 	 63.10,    56.2,    70.8  },
+  { /* 19 */    80.0,    79.43,    70.8,    89.1  },
+  { /* 20 */   100.0,   100.00,    89.1,   112.0  },
+  { /* 21 */   125.0,   125.89,   112.0,   141.0  },
+  { /* 22 */   160.0,   158.49,   141.0,   178.0  },
+  { /* 23 */   200.0,   199.53,   178.0,   224.0  },
+  { /* 24 */   250.0,   251.19,   224.0,   282.0  },
+  { /* 25 */   315.0,   316.23,   282.0,   355.0  },
+  { /* 26 */   400.0,   398.11,   355.0,   447.0  },
+  { /* 27 */   500.0,   501.19,   447.0,   562.0  },
+  { /* 28 */   630.0,   630.96,   562.0,   708.0  },
+  { /* 29 */   800.0,   794.33,   708.0,   891.0  },
+  { /* 30 */  1000.0,  1000.0,    891.0,  1120.0  },
+  { /* 31 */  1250.0,  1258.9,   1120.0,  1410.0  },
+  { /* 32 */  1600.0,  1584.9,   1410.0,  1780.0  },
+  { /* 33 */  2000.0,  1995.3,   1780.0,  2240.0  },
+  { /* 34 */  2500.0,  2511.9,   2240.0,  2820.0  },
+  { /* 35 */  3150.0,  3162.3,   2820.0,  3550.0  },
+  { /* 36 */  4000.0,  3981.1,   3550.0,  4470.0  },
+  { /* 37 */  5000.0,  5011.9,   4470.0,  5620.0  },
+  { /* 38 */  6300.0,  6309.6,   5620.0,  7080.0  },
+  { /* 39 */  8000.0,  7943.3,   7080.0,  8910.0  },
+  { /* 40 */ 10000.0, 10000.0,   8910.0, 11200.0  },
+  { /* 41 */ 12500.0, 12589.3,  11200.0, 14100.0  },
+  { /* 42 */ 16000.0, 15848.9,  14100.0, 17800.0  },
+  { /* 43 */ 20000.0, 19952.6,  17800.0, 22400.0  }
+};
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get information on ISObands 
+* 
+* @param band 
+* @return ISOband_t
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE INLINE ISOband_t *
+ISOband_get_info(int band) {
+  if (band < 1 || band > 43) {
+    fprintf(stderr, "ISO: band index out of range (%d)\n", band);
+    exit(1);
+  } else
+    return &_ISOband_info[band - 1];
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get nominal ISObands 
+* 
+* @param band 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+ISOband_get_nominal(int band) {
+  return ISOband_get_info(band)->nominal;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get exact ISOband
+* 
+* @param band 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+ISOband_get_exact(int band) {
+  return ISOband_get_info(band)->exact;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get low ISOband
+* 
+* @param band 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+ISOband_get_low(int band) {
+  return ISOband_get_info(band)->low;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get high ISOband 
+* 
+* @param band 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+ISOband_get_high(int band) {
+  return ISOband_get_info(band)->high;
+}
--- /dev/null
+++ dttsp-0~svn675/cxops.c
@@ -0,0 +1,247 @@
+/** 
+* @file cxops.c
+* @brief Functions Complex operations
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <cxops.h>
+
+// useful constants
+
+COMPLEX cxzero = { 0.0, 0.0 };
+COMPLEX cxone = { 1.0, 0.0 };
+COMPLEX cxJ = { 0.0, 1.0 };
+COMPLEX cxminusone = { -1.0, 0.0 };
+COMPLEX cxminusJ = { 0.0, -1.0 };
+
+#if 0
+// scalar
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cscl 
+* 
+* @param x 
+* @param a 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cscl(COMPLEX x, REAL a) {
+  COMPLEX z;
+  c_re(z) = c_re(x) * a;
+  c_im(z) = c_im(x) * a;
+  return z;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cadd 
+* 
+* @param x 
+* @param y 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cadd(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) + c_re(y);
+  c_im(z) = c_im(x) + c_im(y);
+  return z;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Csub 
+* 
+* @param x 
+* @param y 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Csub(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) - c_re(y);
+  c_im(z) = c_im(x) - c_im(y);
+  return z;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief 
+* 
+* @param x 
+* @param y 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cmul(COMPLEX x, COMPLEX y) {
+  COMPLEX z;
+  c_re(z) = c_re(x) * c_re(y) - c_im(x) * c_im(y);
+  c_im(z) = c_im(x) * c_re(y) + c_re(x) * c_im(y);
+  return z;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cdiv 
+* 
+* @param x 
+* @param y 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cdiv(COMPLEX x, COMPLEX y) {
+  REAL d = sqr(c_re(y)) + sqr(c_im(y));
+  COMPLEX z;
+  c_re(z) = (c_re(x) * c_re(y) + c_im(x) * c_im(y)) / d;
+  c_im(z) = (c_re(y) * c_im(x) - c_im(y) * c_re(x)) / d;
+  return z;
+}
+
+#define alpha 0.948059448969
+#define beta 0.392699081699
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cappmag 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+Cappmag(COMPLEX z) {
+  REAL tmpr = fabs(z.re), tmpi = fabs(z.im);
+  if (tmpr > tmpi) return alpha * tmpr + beta * tmpi;
+  else             return alpha * tmpi + beta * tmpr;
+}
+
+#undef alpha
+#undef beta
+
+//REAL
+//Cappmag(COMPLEX z) {
+//  REAL tmpr = (REAL) fabs(z.re),
+//       tmpi = (REAL) fabs(z.im);
+//  if (tmpr < tmpi) return 0.4f * tmpr + 0.7f * tmpi;
+//  else             return 0.4f * tmpi + 0.7f * tmpr;
+//}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cmag 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+Cmag(COMPLEX z) {
+  return (REAL) hypot(z.re, z.im);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cabs 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+Cabs(COMPLEX z) {
+  return (REAL) hypot(z.re, z.im);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Csqrmag 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+Csqrmag(COMPLEX z) {
+  return (REAL) (sqr(z.re) + sqr(z.im));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cmplx 
+* 
+* @param x 
+* @param y 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cmplx(REAL x, IMAG y) {
+  COMPLEX z;
+  z.re = x, z.im = y;
+  return z;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Conjg 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Conjg(COMPLEX z) {
+  return Cmplx(z.re, -z.im);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cexp 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cexp(COMPLEX z) {
+  REAL r = (REAL) exp(z.re);
+  return Cmplx((REAL) (r * cos(z.im)), (IMAG) (r * sin(z.im)));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cp2r 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cp2r(COMPLEX z) {
+  return Cmplx((REAL) (z.re * cos(z.im)), (IMAG) (z.re * sin(z.im)));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Cr2p 
+* 
+* @param z 
+*/
+/* ---------------------------------------------------------------------------- */
+COMPLEX
+Cr2p(COMPLEX z) {
+  return Cmplx((REAL) hypot(z.re, z.im),
+	       (REAL) ATAN2(z.im, z.re));
+}
+#endif
--- /dev/null
+++ dttsp-0~svn675/local.h
@@ -0,0 +1,72 @@
+/* local.h
+
+Some manifest constants for the particular implementation
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _local_h
+#define _local_h
+
+#include <common.h>
+
+#define RCBASE ".DttSPrc"
+#define PARMPATH  "/dev/shm/SDRcommands"
+#define SPECPATH  "/dev/shm/SDRspectrum"
+#define METERPATH "/dev/shm/SDRmeter"
+#define REPLAYPATH ".replay"
+#define WISDOMPATH ".wisdom"
+
+extern struct _loc {
+  char name[MAXPATHLEN];
+  struct {
+    char rcfile[MAXPATHLEN],
+         parm[MAXPATHLEN],
+         echo[MAXPATHLEN],
+         meter[MAXPATHLEN],
+         replay[MAXPATHLEN],
+         spec[MAXPATHLEN],
+         wisdom[MAXPATHLEN];
+  } path;
+  struct {
+    REAL rate, chan;
+    int size, bufl, nrx, spec, comp;
+    SDRMODE mode;
+  } def;
+  struct {
+    int ring;
+  } mult;
+  struct {
+    int offs;
+  } skew;
+} loc;
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/ovsv.h
@@ -0,0 +1,69 @@
+/* ovsv.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _ovsv_h
+#define _ovsv_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <update.h>
+#include <lmadf.h>
+#include <fftw3.h>
+
+typedef struct _filt_ov_sav {
+  int buflen, fftlen;
+  COMPLEX *zfvec, *zivec, *zovec, *zrvec;
+  fftwf_plan pfwd, pinv;
+  REAL scale;
+} filt_ov_sv, *FiltOvSv;
+
+extern FiltOvSv newFiltOvSv(COMPLEX *coefs, int ncoef, int pbits);
+extern void delFiltOvSv(FiltOvSv p);
+
+extern COMPLEX *FiltOvSv_initpoint(FiltOvSv pflt);
+extern int FiltOvSv_initsize(FiltOvSv pflt);
+
+extern COMPLEX *FiltOvSv_fetchpoint(FiltOvSv pflt);
+extern int FiltOvSv_fetchsize(FiltOvSv pflt);
+
+extern COMPLEX *FiltOvSv_storepoint(FiltOvSv pflt);
+extern int FiltOvSv_storesize(FiltOvSv pflt);
+
+extern void filter_OvSv(FiltOvSv pflt);
+extern void reset_OvSv(FiltOvSv pflt);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/halfband.c
@@ -0,0 +1,553 @@
+/** 
+* @file halfband.c
+* @brief Functions to calculate halfband
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+			   
+//------------------------------------------------------------------
+#include <halfband.h>
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a Half Band function 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+HalfBandit(HalfBander h) {
+  int i;
+  for (i = 0; i < CXBhave(h->buf.i); i++)
+    CXBdata(h->buf.o, i) = Cmplx(hb_filt_proc(h->filt.gen.re,
+					      CXBreal(h->buf.i, i)),
+				 hb_filt_proc(h->filt.gen.im,
+					      CXBimag(h->buf.i, i)));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new Halfbander 
+* 
+* @param ord 
+* @param steep 
+* @param ibuf 
+* @param obuf 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+HalfBander
+newHalfBander(int ord, BOOLEAN steep, CXB ibuf, CXB obuf) {
+  HalfBander h = (HalfBander) safealloc(1, sizeof(HalfBandInfo), "HalfBander wrapper");
+  h->filt.gen.re = new_hb_filt(ord, steep);
+  h->filt.gen.im = new_hb_filt(ord, steep);
+  h->buf.i = newCXB(CXBsize(ibuf), CXBbase(ibuf), "HalfBander input");
+  h->buf.o = newCXB(CXBsize(obuf), CXBbase(obuf), "HalfBander output");
+  return h;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy Halfbander 
+* 
+* @param h 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delHalfBander(HalfBander h) {
+  if (h) {
+    del_hb_filt(h->filt.gen.re);
+    del_hb_filt(h->filt.gen.im);
+    delCXB(h->buf.i);
+    delCXB(h->buf.o);
+    safefree((char *) h);
+  }
+}
+
+//------------------------------------------------------------------
+
+static void _bail(int);
+static char *_safealloc(int, int, int);
+static void _safefree(char *);
+
+//------------------------------------------------------------------
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Half bander filter process 
+* 
+* @param this 
+* @param inp 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+hb_filt_proc(hb_filt_t *this, REAL inp) {
+  REAL out = (hb_ap_casc_proc(this->a, inp) + this->old) * 0.5;
+  this->old = hb_ap_casc_proc(this->b, inp);
+  return out;
+}
+
+//..................................................................
+
+/* -------------------------------------------------------------------------- */
+/** @brief _hb_ap_proc 
+* 
+* @param this 
+* @param inp 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+static inline REAL
+_hb_ap_proc(hb_ap_t *this, REAL inp) {
+  this->x[2] = this->x[1], this->x[1] = this->x[0], this->x[0] = inp;
+  this->y[2] = this->y[1], this->y[1] = this->y[0],
+    this->y[0] = this->x[2] + (this->c * (inp - this->y[2]));
+  return this->y[0];
+}
+
+//..................................................................
+
+/* -------------------------------------------------------------------------- */
+/** @brief hb_ap_casc_proc 
+* 
+* @param this 
+* @param inp 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+hb_ap_casc_proc(hb_ap_casc_t *this, REAL inp) {
+  int i;
+  REAL out = inp;
+  for (i = 0; i < this->numf; i++) out = _hb_ap_proc(this->apf[i], out);
+  return out;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief hb_ap_proc 
+* 
+* @param this 
+* @param inp 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+hb_ap_proc(hb_ap_t *this, REAL inp) {
+  this->x[2] = this->x[1], this->x[1] = this->x[0], this->x[0] = inp;
+  this->y[2] = this->y[1], this->y[1] = this->y[0],
+    this->y[0] = this->x[2] + (this->c * (inp - this->y[2]));
+  return this->y[0];
+}
+
+//------------------------------------------------------------------
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief new_hb_ap 
+* 
+* @param coef 
+* @return hb_ap_t *
+*/
+/* ---------------------------------------------------------------------------- */
+hb_ap_t *
+new_hb_ap(REAL coef) {
+  hb_ap_t *this = (hb_ap_t *) _safealloc(1, sizeof(hb_ap_t), __LINE__);
+  this->c = coef;
+  return this;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief del_hb_ap 
+* 
+* @param this 
+* @param  
+* @param this 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_hb_ap(hb_ap_t *this) { _safefree((char *) this); }
+
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief bh_ap_casc_t 
+* 
+* @param coef 
+* @param n 
+* @return hb_ap_casc_t *
+*/
+/* ---------------------------------------------------------------------------- */
+hb_ap_casc_t *
+new_hb_ap_casc(REAL *coef, int n) {
+  hb_ap_casc_t *this = (hb_ap_casc_t *) _safealloc(1,
+						   sizeof(hb_ap_casc_t),
+						   __LINE__);
+  this->numf = n;
+  this->apf = (hb_ap_t **) _safealloc(this->numf, sizeof(hb_ap_t *), __LINE__);
+  {
+    int i;
+    for (i = 0; i < this->numf; i++) this->apf[i] = new_hb_ap(coef[i]);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief del_hb_ap_casc 
+* 
+* @param this 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_hb_ap_casc(hb_ap_casc_t *this) {
+  if (this) {
+    int i;
+    for (i = 0; i < this->numf; i++) del_hb_ap(this->apf[i]);
+    _safefree(( char*) this->apf);
+    _safefree((char *) this);
+  }
+}
+
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief new_hb_filt 
+* 
+* @param ord 
+* @param steep 
+* @return hb_filt_t
+*/
+/* ---------------------------------------------------------------------------- */
+hb_filt_t *
+new_hb_filt(int ord, int steep) {
+  hb_filt_t *this= (hb_filt_t *) _safealloc(1,sizeof(hb_filt_t),__LINE__);
+
+  if (steep) {
+
+    switch (ord) {
+
+      // rejection = 104dB, transition band = 0.01
+    case 12: {
+      REAL a[6] = {
+	0.036681502163648017,
+	0.274631759379454100,
+	0.561098969787919480,
+	0.769741833862266000,
+	0.892260818003878900,
+	0.962094548378084000
+      };
+      REAL b[6] = {
+	0.136547624631957710,
+	0.423138617436566670,
+	0.677540049974161600,
+	0.839889624849638000,
+	0.931541959963183900,
+	0.987816370732897100
+      };
+
+      this->a = new_hb_ap_casc(a, 6);
+      this->b = new_hb_ap_casc(b, 6);
+      break;
+    }
+
+      // rejection = 86dB, transition band = 0.01
+    case 10: {
+      REAL a[5] = {
+	0.051457617441190984,
+	0.359786560705670170,
+	0.672547593103469300,
+	0.859088492824993900,
+	0.954020986786078700
+      };
+      REAL b[5] = {
+	0.18621906251989334,
+	0.52995137284796400,
+	0.78102575274895140,
+	0.91418156876053080,
+	0.98547502301490700
+      };
+	  
+      this->a = new_hb_ap_casc(a, 5);
+      this->b = new_hb_ap_casc(b, 5);
+      break;
+    }
+
+      // rejection = 69dB, transition band = 0.01
+    case 8: {
+      REAL a[4] = {
+	0.07711507983241622,
+	0.48207062506104720,
+	0.79682047133157970,
+	0.94125142777404710
+      };
+      REAL b[4] = {
+	0.2659685265210946,
+	0.6651041532634957,
+	0.8841015085506159,
+	0.9820054141886075
+      };
+	  
+      this->a = new_hb_ap_casc(a, 4);
+      this->b = new_hb_ap_casc(b, 4);
+      break;
+    }
+
+      // rejection = 51dB, transition band = 0.01
+    case 6: {
+      REAL a[3] = {
+	0.1271414136264853,
+	0.6528245886369117,
+	0.9176942834328115
+      };
+      REAL b[3] = {
+	0.40056789819445626,
+	0.82041638919233430,
+	0.97631145158367730
+      };
+      
+      this->a = new_hb_ap_casc(a, 3);
+      this->b = new_hb_ap_casc(b, 3);
+      break;
+    }
+
+      // rejection = 53dB,transition band = 0.05
+    case 4: {
+      REAL a[2] = {
+	0.12073211751675449,
+	0.66320202241939950
+      };
+      REAL b[2] = {
+	0.3903621872345006,
+	0.8907868326534970
+      };
+
+      this->a = new_hb_ap_casc(a, 2);
+      this->b = new_hb_ap_casc(b, 2);
+      break;
+    }
+
+      // rejection = 36dB, transition band = 0.1
+    case 2: {
+      REAL a[1] = { 0.23647102099689224 };
+      REAL b[1] = { 0.71454214971260010 };
+
+      this->a = new_hb_ap_casc(a, 1);
+      this->b = new_hb_ap_casc(b, 1);
+      break;
+    }
+
+    default:
+      _bail(__LINE__);
+    }
+
+  } else {
+
+    switch (ord) {
+
+      // rejection = 150dB, transition band = 0.05
+    case 12: {
+      REAL a[6] = {
+	0.01677466677723562,
+	0.13902148819717805,
+	0.33250111173947310,
+	0.53766105314488000,
+	0.72141840242158050,
+	0.88218584020781550
+      };
+      REAL b[6] = {
+	0.06501319274445962,
+	0.23094129990840923,
+	0.43649423484203550,
+	0.06329609551399348,
+	0.80378086794111226,
+	0.95996874048006940
+      };
+
+      this->a = new_hb_ap_casc(a, 6);
+      this->b = new_hb_ap_casc(b, 6);
+      break;
+    }
+
+      // rejection = 133dB, transition band = 0.05
+    case 10: {
+      REAL a[5] = {
+	0.02366831419883467,
+	0.18989476227180174,
+	0.43157318062118555,
+	0.66320202241939950,
+	0.86001554249958200
+      };
+      REAL b[5] = {
+	0.09056555904993387,
+	0.30785757237490430,
+	0.55167824025079340,
+	0.76521468637798080,
+	0.95247728378667541
+      };
+
+      this->a = new_hb_ap_casc(a, 5);
+      this->b = new_hb_ap_casc(b, 5);
+      break;
+    }
+
+      // rejection = 106dB, transition band = 0.05
+    case 8: {
+      REAL a[4] = {
+	0.03583278843106211,
+	0.27204014339645760,
+	0.57205719723570030,
+	0.82712476199732400
+      };
+      REAL b[4] = {
+	0.1340901419430669,
+	0.4243248712718685,
+	0.7062921421386394,
+	0.9415030941737551
+      };
+	  
+      this->a = new_hb_ap_casc(a, 4);
+      this->b = new_hb_ap_casc(b, 4);
+      break;
+    }
+
+      // rejection = 80dB, transition band = 0.05
+    case 6: {
+      REAL a[3] = {
+	0.06029739095712437,
+	0.41259072036105630,
+	0.77271565374292340
+      };
+      REAL b[3] = {
+	0.21597144456092948,
+	0.6043586264658363,
+	0.9238861386532906
+      };
+
+      this->a = new_hb_ap_casc(a, 3);
+      this->b = new_hb_ap_casc(b, 3);
+      break;
+    }
+
+      // rejection = 70dB, transition band = 0.1
+    case 4: {
+      REAL a[2] = {
+	0.07986642623635751,
+	0.54535365107113220
+      };
+      REAL b[2] = {
+	0.28382934487410993,
+	0.83441189148073790
+      };
+
+      this->a = new_hb_ap_casc(a, 2);
+      this->b = new_hb_ap_casc(b, 2);
+      break;
+    }
+
+      // rejection = 36dB, transition band = 0.1
+    case 2: {
+      REAL a[1] = { 0.23647102099689224 };
+      REAL b[1] = { 0.71454214971260010 };
+
+      this->a = new_hb_ap_casc(a, 1);
+      this->b = new_hb_ap_casc(b, 1);
+      break;
+    }
+
+    default:
+      _bail(__LINE__);
+    }
+  }
+
+  this->old = 0.0;
+
+  return this;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief del_hb_filt 
+* 
+* @param this 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_hb_filt(hb_filt_t *this) {
+  del_hb_ap_casc(this->a);
+  del_hb_ap_casc(this->b);
+  _safefree((char *) this);
+}
+
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief _bail
+* 
+* @param where 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+static void
+_bail(int where) {
+  fprintf(stderr, "halfband _bailed at line %d\n", where);
+  exit(1);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief _safealloc
+* 
+* @param num 
+* @param size 
+* @param where 
+* @return *char
+*/
+/* ---------------------------------------------------------------------------- */
+static char *
+_safealloc(int num, int size, int where) {
+  char *p = calloc(num, size);
+  if (!p) _bail(where);
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief _safefree 
+* 
+* @param p 
+* @param if(p 
+* @param free(p 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+static void
+_safefree(char *p) { if (p) free(p); }
--- /dev/null
+++ dttsp-0~svn675/spottone.c
@@ -0,0 +1,224 @@
+/** 
+* @file spottone.c
+* @brief Functions to gerenate spot tones 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <spottone.h>
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Function to generate a spot tone 
+* 
+*  An ASR envelope on a complex phasor,
+*  with asynchronous trigger for R stage.
+*  A/R use sine shaping.
+* @param st 
+*/
+/* ---------------------------------------------------------------------------- */
+BOOLEAN
+SpotTone(SpotToneGen st) {
+  int i, n = st->size;
+
+  ComplexOSC(st->osc.gen);
+
+  for (i = 0; i < n; i++) {
+
+    // in an envelope stage?
+
+    if (st->stage == SpotTone_RISE) {
+
+      // still going?
+      if (st->rise.have++ < st->rise.want) {
+	st->curr += st->rise.incr;
+	st->mul = (REAL) (st->scl * sin(st->curr * M_PI / 2.0));
+      } else {
+	// no, assert steady-state, force level
+	st->curr = 1.0;
+	st->mul = st->scl;
+	st->stage = SpotTone_STDY;
+	// won't come back into envelopes
+	// until FALL asserted from outside
+      }
+
+    } else if (st->stage == SpotTone_FALL) {
+
+      // still going?
+      if (st->fall.have++ < st->fall.want) {
+	st->curr -= st->fall.incr;
+	st->mul = (REAL) (st->scl * sin(st->curr * M_PI / 2.0));
+      } else {
+	// no, assert trailing, force level
+	st->curr = 0.0;
+	st->mul = 0.0;
+	st->stage = SpotTone_HOLD;
+	// won't come back into envelopes hereafter
+      }
+    }
+    // apply envelope
+    // (same base as osc.gen internal buf)
+    CXBdata(st->buf, i) = Cscl(CXBdata(st->buf, i), st->mul);
+  }
+
+  // indicate whether it's turned itself off
+  // sometime during this pass
+
+  return st->stage != SpotTone_HOLD;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Turn on spot tone 
+* 
+* turn spotting on with current settings
+*
+* @param st 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+SpotToneOn(SpotToneGen st) {
+
+  // gain is in dB
+
+  st->scl = (REAL) pow(10.0, st->gain / 20.0);
+  st->curr = st->mul = 0.0;
+
+  // A/R times are in msec
+
+  st->rise.want = (int) (0.5 + st->sr * (st->rise.dur / 1e3));
+  st->rise.have = 0;
+  if (st->rise.want <= 1)
+    st->rise.incr = 1.0;
+  else
+    st->rise.incr = (REAL) (1.0 / (st->rise.want - 1));
+
+  st->fall.want = (int) (0.5 + st->sr * (st->fall.dur / 1e3));
+  st->fall.have = 0;
+  if (st->fall.want <= 1)
+    st->fall.incr = 1.0;
+  else
+    st->fall.incr = (REAL) (1.0 / (st->fall.want - 1));
+
+  // freq is in Hz
+
+  OSCfreq(st->osc.gen) = 2.0 * M_PI * st->osc.freq / st->sr;
+  OSCphase(st->osc.gen) = 0.0;
+
+  st->stage = SpotTone_RISE;
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Turn off spot tone
+* 
+* initiate turn-off
+*
+* @param st 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+SpotToneOff(SpotToneGen st) {
+  st->stage = SpotTone_FALL;
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the spot tone general values 
+* 
+* @param st 
+* @param gain 
+* @param freq 
+* @param rise 
+* @param fall 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+setSpotToneGenVals(SpotToneGen st, REAL gain, REAL freq, REAL rise, REAL fall) {
+  st->gain = gain;
+  st->osc.freq = freq;
+  st->rise.dur = rise;
+  st->fall.dur = fall;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new spot tone with values 
+* 
+* @param gain dB 
+* @param freq ms 
+* @param rise ms 
+* @param fall ms 
+* @param size 
+* @param samplerate 
+*/
+/* ---------------------------------------------------------------------------- */
+SpotToneGen
+newSpotToneGen(REAL gain,	// dB
+	       REAL freq, REAL rise,	// ms
+	       REAL fall,	// ms
+	       int size, REAL samplerate) {
+
+  SpotToneGen st = (SpotToneGen) safealloc(1,
+					   sizeof(SpotToneGenDesc),
+					   "SpotToneGenDesc");
+
+  setSpotToneGenVals(st, gain, freq, rise, fall);
+  st->size = size;
+  st->sr = samplerate;
+
+  st->osc.gen = newOSC(st->size,
+		       ComplexTone,
+		       st->osc.freq, 0.0, st->sr, "SpotTone osc");
+
+  // overload oscillator buf
+  st->buf = newCXB(st->size, OSCCbase(st->osc.gen), "SpotToneGen buf");
+
+  return st;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete spot tone generation structures 
+* 
+* @param st 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delSpotToneGen(SpotToneGen st) {
+  if (st) {
+    delCXB(st->buf);
+    delOSC(st->osc.gen);
+    safefree((char *) st);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/graphiceq.c
@@ -0,0 +1,100 @@
+/** 
+* @file graphiceq.c
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+* @brief  PCM frequency domain equalizer
+
+ This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+*/
+
+#include <graphiceq.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief graphiceq 
+* 
+* @param a 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+graphiceq(EQ a) {
+  int sigsize = CXBhave(a->data), sigidx = 0;
+
+  do {
+    memcpy(CXBbase(a->in),
+	   &CXBdata(a->data, sigidx),
+	   256 * sizeof (COMPLEX));
+    filter_OvSv(a->p);
+    memcpy(&CXBdata (a->data, sigidx),
+	   CXBbase (a->out),
+	   256 * sizeof (COMPLEX));
+    sigidx += 256;
+  } while (sigidx < sigsize);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief new_EQ 
+* 
+* @param d 
+* @param samplerate 
+* @param pbits 
+*/
+/* ---------------------------------------------------------------------------- */
+EQ
+new_EQ (CXB d, REAL samplerate, int pbits) {
+  ComplexFIR BP;
+  EQ a = (EQ) safealloc(1, sizeof (eq), "new eq state");
+
+  BP = newFIR_Bandpass_COMPLEX(-6000.0, 6000.0, samplerate, 257);
+  a->p = newFiltOvSv(BP->coef, 257, pbits);
+  a->in = newCXB(256, FiltOvSv_fetchpoint(a->p), "EQ input CXB");
+  a->out = newCXB(256, FiltOvSv_storepoint(a->p), "EQ output CXB");
+  a->data = d;
+  delFIR_Bandpass_COMPLEX(BP);
+  return a;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief delEQ 
+* 
+* @param a 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delEQ (EQ a) {
+  if (a) {
+    delCXB(a->in);
+    delCXB(a->out);
+    delFiltOvSv (a->p);
+    safefree ((char *) a);
+  }
+}
+
--- /dev/null
+++ dttsp-0~svn675/iambic-keyer.c
@@ -0,0 +1,1029 @@
+/** 
+* @file iambic-keyer.c
+* @brief Function to implement a iambic keyer
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+The code in this file is derived from routines originally written by
+Pierre-Philippe Coupard for his CWirc X-chat program. That program
+is issued under the GPL and is
+Copyright (C) Pierre-Philippe Coupard - 18/06/2003
+
+This derived version is
+Copyright (C) 2004-2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <linux/rtc.h>
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <oscillator.h>
+#include <cwtones.h>
+
+//========================================================================
+
+#define L_KEY_DOWN	  (01 << 00)
+#define R_KEY_DOWN	  (01 << 01)
+
+#define NO_TIME_LEFTS_SCHED	(-2)
+#define NO_ELEMENT		(-1)
+#define DIT			 (0)
+#define DAH			 (1)
+#define MODE_A			 (0)
+#define MODE_B			 (1)
+#define NO_PADDLE_SQUEEZE	 (0)
+#define PADDLES_SQUEEZED	 (1)
+#define PADDLES_RELEASED	 (2)
+#define NO_DELAY		 (0)
+#define CHAR_SPACING_DELAY	 (1)
+#define WORD_SPACING_DELAY	 (2)
+#define DEBOUNCE_BUF_MAX_SIZE	(30)
+
+//========================================================================
+
+typedef
+struct _keyer_state {
+  struct {
+    BOOLEAN iambic,	// iambic or straight
+      	    mdlmdB,	// set true if mode B
+            revpdl;	// paddles reversed
+    struct {
+      BOOLEAN dit, dah;
+    } memory;		// set both true for mode B
+    struct {
+      BOOLEAN khar, word;
+    } autospace;
+  } flag;
+  int debounce,	// # seconds to read paddles
+      mode,	// 0 = mode A, 1 = mode B
+      weight;	// 15 -> 85%
+  double wpm;	// for iambic keyer
+} KeyerStateInfo, *KeyerState;
+
+extern KeyerState newKeyerState(void);
+extern void delKeyerState(KeyerState ks);
+
+//------------------------------------------------------------------------
+
+typedef
+struct _keyer_logic {
+  struct {
+    BOOLEAN init;
+    struct {
+      BOOLEAN dit, dah;
+    } prev;
+  } flag;
+  struct {
+    BOOLEAN altrn, // insert alternate element
+            psqam; // paddles squeezed after mid-element
+    int curr, // -1 = nothing, 0 = dit, 1 = dah
+        iamb, //  0 = none, 1 = squeezed, 2 = released
+        last; // -1 = nothing, 0 = dit, 1 = dah
+  } element;
+  struct {
+    double beep, dlay, elem, midl;
+  } time_left;
+  int dlay_type; // 0 = none, 1 = interchar, 2 = interword
+} KeyerLogicInfo, *KeyerLogic;
+
+extern KeyerLogic newKeyerLogic(void);
+extern void delKeyerLogic(KeyerLogic kl);
+
+extern BOOLEAN klogic(KeyerLogic kl,
+		      BOOLEAN dit,
+		      BOOLEAN dah,
+		      double wpm,
+		      int iambicmode,
+		      BOOLEAN need_midelemodeB,
+		      BOOLEAN want_dit_mem,
+		      BOOLEAN want_dah_mem,
+		      BOOLEAN autocharspacing,
+		      BOOLEAN autowordspacing,
+		      int weight,
+		      double ticklen);
+
+//========================================================================
+//========================================================================
+//========================================================================
+
+#define SAMP_RATE (48000)
+
+/// # times key is sampled per sec
+// #define RTC_RATE (64)
+#define RTC_RATE (1024)
+
+/// # samples generated during 1 clock tick at RTC_RATE
+#define TONE_SIZE (SAMP_RATE / RTC_RATE)
+
+/// ring buffer size
+#define RING_SIZE (01 << 022)
+
+KeyerState ks;
+KeyerLogic kl;
+
+pthread_t poller, play, key, update;
+sem_t poll_action, clock_fired, keyer_started, update_ok;
+int poll_status;
+
+int fdser, fdrtc;
+
+jack_client_t *client;
+jack_port_t *lport, *rport;
+jack_ringbuffer_t *lring, *rring;
+jack_nframes_t size;
+
+CWToneGen gen;
+BOOLEAN playing = FALSE, iambic = FALSE;
+double wpm = 18.0, freq = 700.0, ramp = 5.0, gain = -3.0;
+
+//========================================================================
+//========================================================================
+//========================================================================
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read a straight key 
+* 
+* Get most recent input port status,
+* do debouncing,
+* then return the key state 
+*
+* @param ks 
+* @return BOOLEAN
+*/
+/* ---------------------------------------------------------------------------- */
+BOOLEAN
+read_straight_key(KeyerState ks) {
+  int i, j, status;
+  static BOOLEAN keystate = 0;
+  static int debounce_buf_i = 0,
+             debounce_buf[DEBOUNCE_BUF_MAX_SIZE];
+
+  /* Get the key state */
+  sem_wait(&poll_action);
+  status = poll_status;
+  poll_status = 0;
+
+  debounce_buf[debounce_buf_i] = status & (L_KEY_DOWN | R_KEY_DOWN);
+  debounce_buf_i++;
+
+  /* If the debounce buffer is full,
+     determine the state of the key */
+  if (debounce_buf_i >= ks->debounce) {
+    debounce_buf_i = 0;
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (debounce_buf[i])
+	j++;
+    keystate = (j > ks->debounce / 2) ? 1 : 0;
+  }
+
+  return keystate;
+}
+
+//------------------------------------------------------------------------
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read an iambic key 
+* 
+* Get most recent input port status,
+* do debouncing,
+* emulate a straight key,
+* then return the emulated key state 
+*   
+* @param ks 
+* @param kl 
+* @param ticklen 
+* @return BOOLEAN
+*/
+/* ---------------------------------------------------------------------------- */
+BOOLEAN
+read_iambic_key(KeyerState ks, KeyerLogic kl, double ticklen) {
+  int i, j, status;
+  static BOOLEAN dah_debounce_buf[DEBOUNCE_BUF_MAX_SIZE],
+                 dit_debounce_buf[DEBOUNCE_BUF_MAX_SIZE];
+  static int dah = 0, debounce_buf_i = 0, dit = 0;
+
+  /* Get the key states */
+  sem_wait(&poll_action);
+  status = poll_status;
+  poll_status = 0;
+
+  if (ks->flag.revpdl) {
+    dah_debounce_buf[debounce_buf_i] = status & L_KEY_DOWN;
+    dit_debounce_buf[debounce_buf_i] = status & R_KEY_DOWN;
+  } else {
+    dit_debounce_buf[debounce_buf_i] = status & R_KEY_DOWN;
+    dah_debounce_buf[debounce_buf_i] = status & L_KEY_DOWN;
+  }
+  debounce_buf_i++;
+
+  /* If the debounce buffer is full, determine the state of the keys */
+  if (debounce_buf_i >= ks->debounce) {
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (dah_debounce_buf[i]) j++;
+    dah = (j > ks->debounce / 2) ? 1 : 0;
+
+    j = 0;
+    for (i = 0; i < ks->debounce; i++)
+      if (dit_debounce_buf[i]) j++;
+    dit = (j > ks->debounce / 2) ? 1 : 0;
+
+    debounce_buf_i = 0;
+  }
+
+  return klogic(kl,
+		dit,
+		dah,
+		ks->wpm,
+		ks->mode,
+		ks->flag.mdlmdB,
+		ks->flag.memory.dit,
+		ks->flag.memory.dah,
+		ks->flag.autospace.khar,
+		ks->flag.autospace.word,
+		ks->weight,
+		ticklen);
+}
+
+//========================================================================
+/* -------------------------------------------------------------------------- */
+/** @brief Function of the keyer logic 
+* 
+* @param kl 
+* @param dit 
+* @param dah 
+* @param wpm 
+* @param iambicmode 
+* @param need_midlemodeB 
+* @param want_dit_mem 
+* @param want_dah_mem 
+* @param autocharspacing 
+* @param autowordspacing 
+* @param weight 
+* @param ticklen 
+* @return BOOLEAN
+*/
+/* ---------------------------------------------------------------------------- */
+
+BOOLEAN
+klogic(KeyerLogic kl,
+       BOOLEAN dit,
+       BOOLEAN dah,
+       double wpm,
+       int iambicmode,
+       BOOLEAN need_midelemodeB,
+       BOOLEAN want_dit_mem,
+       BOOLEAN want_dah_mem,
+       BOOLEAN autocharspacing,
+       BOOLEAN autowordspacing,
+       int weight,
+       double ticklen) {
+
+  double ditlen = 1200 / wpm;
+  int set_which_ele_time_left = NO_TIME_LEFTS_SCHED;
+
+  /** Do we need to initialize the keyer? */
+  if (!kl->flag.init) {
+    kl->flag.prev.dit = dit;
+    kl->flag.prev.dah = dah;
+    kl->element.last = kl->element.curr = NO_ELEMENT;
+    kl->element.iamb = NO_PADDLE_SQUEEZE;
+    kl->element.psqam = 0;
+    kl->element.altrn = 0;
+    kl->time_left.midl = kl->time_left.beep = kl->time_left.elem = 0;
+    kl->time_left.dlay = 0;
+    kl->dlay_type = NO_DELAY;
+    kl->flag.init = 1;
+  }
+
+  /** Decrement the time_lefts */
+  kl->time_left.dlay -= kl->time_left.dlay > 0 ? ticklen : 0;
+  if (kl->time_left.dlay <= 0) {
+    /* If nothing is scheduled to play,
+       and we just did a character space delay,
+       and we're doing auto word spacing,
+       then pause for a word space,
+       otherwise resume the normal element time_left countdowns */
+    if (kl->time_left.elem <= 0 &&
+	kl->dlay_type == CHAR_SPACING_DELAY &&
+	autowordspacing) {
+      kl->time_left.dlay = ditlen * 4;
+      kl->dlay_type = WORD_SPACING_DELAY;
+    } else {
+      kl->dlay_type = NO_DELAY;
+      kl->time_left.midl -= kl->time_left.midl > 0 ? ticklen : 0;
+      kl->time_left.beep -= kl->time_left.beep > 0 ? ticklen : 0;
+      kl->time_left.elem -= kl->time_left.elem > 0 ? ticklen : 0;
+    }
+  }
+
+  /** Are both paddles squeezed? */
+  if (dit && dah) {
+    kl->element.iamb = PADDLES_SQUEEZED;
+    /* Are the paddles squeezed past the middle of the element? */
+    if (kl->time_left.midl <= 0)
+      kl->element.psqam = 1;
+  } else if (!dit && !dah && kl->element.iamb == PADDLES_SQUEEZED)
+    /* Are both paddles released and we had gotten a squeeze in this element? */
+    kl->element.iamb = PADDLES_RELEASED;
+
+  /** Is the current element finished? */
+  if (kl->time_left.elem <= 0 && kl->element.curr != NO_ELEMENT) {
+    kl->element.last = kl->element.curr;
+
+    /** Should we insert an alternate element? */
+    if (((dit && dah) ||
+	 (kl->element.altrn &&
+	  kl->element.iamb != PADDLES_RELEASED) ||
+	 (kl->element.iamb == PADDLES_RELEASED &&
+	  iambicmode == MODE_B &&
+	  (!need_midelemodeB || kl->element.psqam)))) {
+      if (kl->element.last == DAH)
+	set_which_ele_time_left = kl->element.curr = DIT;
+      else
+	set_which_ele_time_left = kl->element.curr = DAH;
+
+    } else {
+      /* No more element */
+      kl->element.curr = NO_ELEMENT;
+      /* Do we do automatic character spacing? */
+      if (autocharspacing && !dit && !dah) {
+	kl->time_left.dlay = ditlen * 2;
+	kl->dlay_type = CHAR_SPACING_DELAY;
+      }
+    }
+
+    kl->element.altrn = 0;
+    kl->element.iamb = NO_PADDLE_SQUEEZE;
+    kl->element.psqam = 0;
+  }
+
+  /** Is an element not currently being played? */
+  if (kl->element.curr == NO_ELEMENT) {
+    if (dah)		/* Dah paddle down? */
+      set_which_ele_time_left = kl->element.curr = DAH;
+    else if (dit)	/* Dit paddle down? */
+      set_which_ele_time_left = kl->element.curr = DIT;
+  }
+
+  /** Take the dah memory request into account */
+  if (kl->element.curr == DIT &&
+      !kl->flag.prev.dah &&
+      dah &&
+      want_dah_mem)
+    kl->element.altrn = 1;
+
+  /** Take the dit memory request into account */
+  if (kl->element.curr == DAH &&
+      !kl->flag.prev.dit &&
+      dit &&
+      want_dit_mem)
+    kl->element.altrn = 1;
+
+  /** If we had a dit or dah scheduled for after a delay,
+     and both paddles are up before the end of the delay,
+     and we have not requested dit or dah memory,
+     forget it
+     NB can't happen in full mode B */
+
+  if (kl->time_left.dlay > 0 && !dit && !dah &&
+      ((kl->element.curr == DIT && !want_dit_mem) ||
+       (kl->element.curr == DAH && !want_dah_mem)))
+    set_which_ele_time_left = kl->element.curr = NO_ELEMENT;
+
+  /** Set element time_lefts, if needed */
+  switch (set_which_ele_time_left) {
+  case NO_ELEMENT:		/* Cancel any element */
+    kl->time_left.beep = 0;
+    kl->time_left.midl = 0;
+    kl->time_left.elem = 0;
+    break;
+
+  case DIT:			/* Schedule a dit */
+    kl->time_left.beep = (ditlen * (double) weight) / 50;
+    kl->time_left.midl = kl->time_left.beep / 2;
+    kl->time_left.elem = ditlen * 2;
+    break;
+
+  case DAH:			/* Schedule a dah */
+    kl->time_left.beep = (ditlen * (double) weight) / 50 + ditlen * 2;
+    kl->time_left.midl = kl->time_left.beep / 2;
+    kl->time_left.elem = ditlen * 4;
+    break;
+  }
+
+  kl->flag.prev.dit = dit;
+  kl->flag.prev.dah = dah;
+
+  return kl->time_left.beep > 0 && kl->time_left.dlay <= 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new KeyerState 
+* @return KeyerState
+*/
+/* ---------------------------------------------------------------------------- */
+KeyerState
+newKeyerState(void) {
+  return (KeyerState) safealloc(1, sizeof(KeyerStateInfo), "newKeyerState");
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a KeyerState 
+* 
+* @param ks 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delKeyerState(KeyerState ks) {
+  safefree((char *) ks);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create new Keyer Logic 
+* @return KeyerState
+*/
+/* ---------------------------------------------------------------------------- */
+KeyerLogic
+newKeyerLogic(void) {
+  return (KeyerLogic) safealloc(1, sizeof(KeyerLogicInfo), "newKeyerLogic");
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy Keyer Logic 
+* 
+* @param kl 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delKeyerLogic(KeyerLogic kl) {
+  safefree((char *) kl);
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief Clear a jack ring buffer 
+* 
+* @param ring 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+jack_ringbuffer_clear(jack_ringbuffer_t *ring, int nbytes) {
+  int i;
+  char zero = 0;
+  for (i = 0; i < nbytes; i++)
+    jack_ringbuffer_write(ring, &zero, 1);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief jack_ringbuffer_restart
+* 
+* @param ring 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+jack_ringbuffer_restart(jack_ringbuffer_t *ring, int nbytes) {
+  jack_ringbuffer_reset(ring);
+  jack_ringbuffer_clear(ring, nbytes);
+}
+
+//------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Send a tone 
+*
+* generated tone -> output ringbuffer
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+send_tone(void) {
+  if (jack_ringbuffer_write_space(lring) < TONE_SIZE * sizeof(float)) {
+    write(2, "overrun tone\n", 13);
+    jack_ringbuffer_restart(lring, TONE_SIZE * sizeof(float));
+    jack_ringbuffer_restart(rring, TONE_SIZE * sizeof(float));
+  } else {
+    int i;
+    for (i = 0; i < gen->size; i++) {
+      float l = CXBreal(gen->buf, i),
+	    r = CXBimag(gen->buf, i);
+      jack_ringbuffer_write(lring, (char *) &l, sizeof(float));
+      jack_ringbuffer_write(rring, (char *) &r, sizeof(float));
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Send silence 
+*
+* silence -> output ringbuffer
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+send_silence(void) {
+  if (jack_ringbuffer_write_space(lring) < TONE_SIZE * sizeof(float)) {
+    write(2, "overrun zero\n", 13);
+    jack_ringbuffer_restart(lring, TONE_SIZE * sizeof(float));
+    jack_ringbuffer_restart(rring, TONE_SIZE * sizeof(float));
+  } else {
+    int i;
+    for (i = 0; i < gen->size; i++) {
+      float zero = 0.0;
+      jack_ringbuffer_write(lring, (char *) &zero, sizeof(float));
+      jack_ringbuffer_write(rring, (char *) &zero, sizeof(float));
+    }
+  }
+}
+
+//------------------------------------------------------------------------
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run sound thread  
+*
+* sound/silence generation
+* tone turned on/off asynchronously
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+sound_thread(void) {
+  for (;;) {
+    sem_wait(&clock_fired);
+
+    if (playing) {
+      // CWTone keeps playing for awhile after it's turned off,
+      // in order to allow for a decay envelope;
+      // returns FALSE when it's actually done.
+      playing = CWTone(gen);
+      send_tone();
+    } else {
+      send_silence();
+      // only let updates run when we've just generated silence
+      sem_post(&update_ok);
+    }
+  }
+
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Poll the sound thread 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+poll_thread(void) {
+  struct timespec req, rem;
+  req.tv_sec = 0;
+  req.tv_nsec = 1000000;
+  for (;;) {
+    int status;
+    nanosleep(&req, &rem);
+    if (ioctl(fdser, TIOCMGET, &status) != -1) {
+      if (status & TIOCM_DSR)
+	poll_status |= L_KEY_DOWN;
+      if (status & TIOCM_CTS)
+	poll_status |= R_KEY_DOWN;
+      sem_post(&poll_action);
+    }
+  }
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a timed delay on buffer read 
+*
+* basic heartbeat
+* returns actual dur in msec since last tick;
+* uses Linux rtc interrupts.
+* other strategies will work too, so long as they
+* provide a measurable delay in msec.
+*
+* @return double
+*/
+/* ---------------------------------------------------------------------------- */
+double
+timed_delay(void) {
+  double del;
+  unsigned long data;
+  if (read(fdrtc, &data, sizeof(unsigned long)) == -1) {
+    perror("read");
+    exit(1);
+  }
+  del = (data >> 010) * 1000 / (double) RTC_RATE;
+  return del;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read a key condtions 
+*
+* key down? (real or via keyer logic)
+* 
+* @param del 
+* @return BOOLEAN
+*
+*/
+/* ---------------------------------------------------------------------------- */
+BOOLEAN
+read_key(double del) {
+  if (iambic)
+    return read_iambic_key(ks, kl, del);
+  else
+    return read_straight_key(ks);
+}
+
+//------------------------------------------------------------------------
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run key thread 
+*
+* main keyer loop
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+key_thread(void) {
+
+  sem_wait(&keyer_started);
+
+  for (;;) {
+    double del = timed_delay();
+    BOOLEAN keydown = read_key(del);
+
+    if (!playing && keydown)
+      CWToneOn(gen), playing = TRUE;
+    else if (playing && !keydown)
+      CWToneOff(gen);
+
+    sem_post(&clock_fired);
+  }
+
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+
+#define MAX_ESC (512)
+#define ESC_L '<'
+#define ESC_R '>'
+
+/* -------------------------------------------------------------------------- */
+/** @brief update thread,  update keyer parameters via text input from stdin
+*
+* @param<wpm xxx>  -> set keyer speed to xxx
+* @param<gain xxx> -> set gain to xxx (dB)
+* @param<freq xxx> -> set freq to xxx
+* @param <ramp xxx> -> set attack/decay times to xxx ms
+* @param <quit>     -> terminate keyer
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+update_thread(void) {
+  for (;;) {
+    int c;
+
+    // get or wait for next input char
+    if ((c = getchar()) == EOF) goto finish;
+
+    // if we see the beginning of a command,
+    if (c == ESC_L) {
+      int i = 0;
+      char buf[MAX_ESC];
+
+      // gather up the remainder
+      while ((c = getchar()) != EOF) {
+	if (c == ESC_R) break;
+	buf[i] = c;
+	if (++i >= (MAX_ESC - 1)) break;
+      }
+      if (c == EOF) goto finish;
+      buf[i] = 0;
+
+      // wait until changes are safe
+      sem_wait(&update_ok);
+
+      if (!strncmp(buf, "wpm", 3))
+	ks->wpm = wpm = atof(buf + 3);
+      else if (!strncmp(buf, "ramp", 4)) {
+	ramp = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "freq", 4)) {
+	freq = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "gain", 4)) {
+	gain = atof(buf + 4);
+	setCWToneGenVals(gen, gain, freq, ramp, ramp);
+      } else if (!strncmp(buf, "quit", 4))
+	goto finish;
+
+    } // otherwise go around again
+  }
+
+  // we saw an EOF or quit; kill other threads and exit neatly
+
+ finish:
+  pthread_cancel(poller);
+  pthread_cancel(play);
+  pthread_cancel(key);
+  pthread_exit(0);
+}
+
+//------------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief private jack_xrun 
+* 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_xrun(void *arg) {
+  char *str = "xrun";
+  write(2, str, strlen(str));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief jack_shutdown 
+* 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_shutdown(void *arg) {}
+
+/* -------------------------------------------------------------------------- */
+/** @brief jack_callback 
+* 
+* @param nframes 
+* @param arg 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_callback(jack_nframes_t nframes, void *arg) {
+  float *lp, *rp;
+  int nbytes = nframes * sizeof(float);
+  if (nframes == size) {
+    // output: copy from ring to port
+    lp = (float *) jack_port_get_buffer(lport, nframes);
+    rp = (float *) jack_port_get_buffer(rport, nframes);
+    if (jack_ringbuffer_read_space(lring) >= nbytes) {
+      jack_ringbuffer_read(lring, (char *) lp, nbytes);
+      jack_ringbuffer_read(rring, (char *) rp, nbytes);
+    } else { // rb pathology
+      memset((char *) lp, 0, nbytes);
+      memset((char *) rp, 0, nbytes);
+      jack_ringbuffer_reset(lring);
+      jack_ringbuffer_reset(rring);
+      jack_ringbuffer_clear(lring, TONE_SIZE * sizeof(float));
+      jack_ringbuffer_clear(rring, TONE_SIZE * sizeof(float));
+      //write(2, "underrun\n", 9); 
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief main 
+* 
+* @param argc 
+* @param *argv 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+main(int argc, char **argv) {
+  int i;
+  char *serialdev = "/dev/ttyS0",
+       *clockdev = "/dev/rtc";
+  int serstatus;
+
+  for (i = 1; i < argc; i++)
+    if (argv[i][0] == '-')
+      switch (argv[i][1]) {
+      case 'f':
+	freq = atof(argv[++i]);
+	break;
+      case 'i':
+	iambic = TRUE;
+	break;
+      case 'g':
+	gain = atof(argv[++i]);
+	break;
+      case 'r':
+	ramp = atof(argv[++i]);
+	break;
+      case 'w':
+	wpm = atof(argv[++i]);
+	break;
+      default:
+	fprintf(stderr,
+		"iambic-keyer [-i] [-w wpm] [-g gain_dB] [-r ramp_ms]\n");
+	exit(1);
+      }
+    else break;
+
+  if (i < argc) {
+    if (!freopen(argv[i], "r", stdin))
+      perror(argv[i]), exit(1);
+    i++;
+  }
+
+  //------------------------------------------------------------
+
+  gen = newCWToneGen(gain, freq, ramp, ramp, TONE_SIZE, 48000.0);
+
+  //------------------------------------------------------------
+
+  kl = newKeyerLogic();
+  ks = newKeyerState();
+  ks->flag.iambic = TRUE;
+  ks->flag.revpdl = TRUE;
+  // set On by default; straight key never sees them,
+  // mode A users are on their own
+  ks->flag.mdlmdB = ks->flag.memory.dit = ks->flag.memory.dah = TRUE;
+  ks->flag.autospace.khar = ks->flag.autospace.word = FALSE;
+  ks->debounce = 1;
+  ks->mode = MODE_B;
+  ks->weight = 50;
+  ks->wpm = wpm;
+
+  //------------------------------------------------------------
+
+  if (!(client = jack_client_new("ikyr")))
+    fprintf(stderr, "can't make client -- jack not running?\n"), exit(1);
+  jack_set_process_callback(client, (void *) jack_callback, 0);
+  jack_on_shutdown(client, (void *) jack_shutdown, 0);
+  jack_set_xrun_callback(client, (void *) jack_xrun, 0);
+  size = jack_get_buffer_size(client);
+  lport = jack_port_register(client,
+			     "ol",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  rport = jack_port_register(client,
+			     "or",
+			     JACK_DEFAULT_AUDIO_TYPE,
+			     JackPortIsOutput,
+			     0);
+  lring = jack_ringbuffer_create(RING_SIZE);
+  rring = jack_ringbuffer_create(RING_SIZE);
+  jack_ringbuffer_clear(lring, TONE_SIZE * sizeof(float));
+  jack_ringbuffer_clear(rring, TONE_SIZE * sizeof(float));
+  
+  //------------------------------------------------------------
+
+  // key
+  if ((fdser = open(serialdev, O_WRONLY)) == -1) {
+    fprintf(stderr, "cannot open serial device %s", serialdev);
+    exit(1);
+  }
+  if (ioctl(fdser, TIOCMGET, &serstatus) == -1) {
+    close(fdser);
+    fprintf(stderr, "cannot get serial device status");
+    exit(1);
+  }
+  serstatus |= TIOCM_DTR;
+  if (ioctl(fdser, TIOCMSET, &serstatus) == -1) {
+    close(fdser);
+    fprintf(stderr, "cannot set serial device status");
+    exit(1);
+  }
+
+  // rtc
+  if ((fdrtc = open(clockdev, O_RDONLY)) == -1) {
+    perror(clockdev);
+    exit(1);
+  }
+  if (ioctl(fdrtc, RTC_IRQP_SET, RTC_RATE) == -1) {
+    perror("ioctl irqp");
+    exit(1);
+  }
+  if (ioctl(fdrtc, RTC_PIE_ON, 0) == -1) {
+    perror("ioctl pie on");
+    exit(1);
+  }
+
+  //------------------------------------------------------------
+
+  sem_init(&poll_action, 0, 0);
+  sem_init(&clock_fired, 0, 0);
+  sem_init(&keyer_started, 0, 0);
+  sem_init(&update_ok, 0, 0);
+  pthread_create(&poller, 0, (void *) poll_thread, 0);
+  pthread_create(&play, 0, (void *) sound_thread, 0);
+  pthread_create(&key, 0, (void *) key_thread, 0);
+  pthread_create(&update, 0, (void *) update_thread, 0);
+
+  //------------------------------------------------------------
+
+  jack_activate(client);
+  {
+    const char **ports;
+    if (!(ports = jack_get_ports(client, 0, 0, JackPortIsPhysical | JackPortIsInput))) {
+      fprintf(stderr, "can't find any physical playback ports\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(lport), ports[0])) {
+      fprintf(stderr, "can't connect left output\n");
+      exit(1);
+    }
+    if (jack_connect(client, jack_port_name(rport), ports[1])) {
+      fprintf(stderr, "can't connect right output\n");
+      exit(1);
+    }
+    free(ports);
+  }
+
+  sem_post(&keyer_started);
+
+  pthread_join(poller, 0);
+  pthread_join(play, 0);
+  pthread_join(key, 0);
+  pthread_join(update, 0);
+  jack_client_close(client);
+
+  //------------------------------------------------------------
+
+  if (ioctl(fdrtc, RTC_PIE_OFF, 0) == -1) {
+    perror("ioctl pie off");
+    exit(1);
+  }
+  close(fdrtc);
+  close(fdser);
+
+  jack_ringbuffer_free(lring);
+  jack_ringbuffer_free(rring);
+
+  sem_destroy(&poll_action);
+  sem_destroy(&clock_fired);
+  sem_destroy(&keyer_started);
+
+  delCWToneGen(gen);
+  delKeyerState(ks);
+  delKeyerLogic(kl);
+
+  //------------------------------------------------------------
+
+  exit(0);
+}
--- /dev/null
+++ dttsp-0~svn675/sdr.c
@@ -0,0 +1,1407 @@
+/** 
+* @file sdr.c
+* @brief 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY.
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <common.h>
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the meters 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reset_meters(void) {
+  if (uni->meter.flag) {		// reset metering completely
+    int i, k;
+    for (i = 0; i < RXMETERPTS; i++)
+      for (k = 0; k < MAXRX; k++)
+	uni->meter.rx.val[k][i] = -KINDA;
+    for (i = 0; i < TXMETERPTS; i++)
+      uni->meter.tx.val[i] = -KINDA;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset te spectrum 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reset_spectrum(void) {
+  if (uni->spec.flag)
+    reinit_spectrum(&uni->spec);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the counters 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+reset_counters(void) {
+  int k;
+  for (k = 0; k < uni->multirx.nrx; k++)
+    rx[k]->tick = 0;
+  tx->tick = 0;
+}
+
+//========================================================================
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Setup all values for FFT 
+* 
+* global and general info,
+* not specifically attached to
+* tx, rx, or scheduling 
+*
+* @param samplerate 
+* @param buflen 
+* @param mode 
+* @param wisdom 
+* @param specsize 
+* @param numrecv 
+* @param cpdsize 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_all(REAL samplerate,
+	  int buflen,
+	  SDRMODE mode,
+	  char *wisdom, 
+	  int specsize, 
+	  int numrecv, 
+	  int cpdsize) {
+
+  uni->rate.sample = samplerate;
+  uni->buflen = buflen;
+  uni->mode.sdr = mode;
+  uni->mode.trx = RX;
+
+  uni->wisdom.path = wisdom;
+  uni->wisdom.bits = FFTW_ESTIMATE;
+  {
+    FILE *f = fopen(uni->wisdom.path, "r");
+    if (f) {
+      if (fftwf_import_wisdom_from_file(f) != 0)
+	uni->wisdom.bits = FFTW_MEASURE;
+      fclose(f);
+    }
+  }
+
+  if (uni->meter.flag)
+    reset_meters();
+
+  uni->spec.rxk = 0;
+  uni->spec.buflen = uni->buflen;
+  uni->spec.scale = SPEC_PWR;
+  uni->spec.type = SPEC_POST_FILT;
+  uni->spec.size = specsize;
+  uni->spec.planbits = uni->wisdom.bits;
+  init_spectrum(&uni->spec);
+
+  // set which receiver is listening to commands
+  uni->multirx.lis = 0;
+  uni->multirx.nrx = numrecv;
+
+  uni->cpdlen = cpdsize;
+
+  uni->tick = 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Setup receive parameters
+* 
+* purely rx 
+*
+* @param k 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_rx(int k) {
+
+  rx[k]->len = uni->buflen;
+
+  /* conditioning */
+  rx[k]->iqfix = newCorrectIQ(0.0, 1.0);
+  rx[k]->filt.coef = newFIR_Bandpass_COMPLEX(-4800.0,
+					     4800.0,
+					     uni->rate.sample,
+					     rx[k]->len + 1);
+  rx[k]->filt.ovsv = newFiltOvSv(FIRcoef(rx[k]->filt.coef),
+				 FIRsize(rx[k]->filt.coef),
+				 uni->wisdom.bits);
+  normalize_vec_COMPLEX(rx[k]->filt.ovsv->zfvec, rx[k]->filt.ovsv->fftlen);
+
+  // hack for EQ
+  rx[k]->filt.save = newvec_COMPLEX(rx[k]->filt.ovsv->fftlen,
+				    "RX filter cache");
+  memcpy((char *) rx[k]->filt.save,
+	 (char *) rx[k]->filt.ovsv->zfvec,
+	 rx[k]->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  /* buffers */
+  /* note we overload the internal filter buffers we just created */
+  rx[k]->buf.i = newCXB(rx[k]->len,
+			FiltOvSv_fetchpoint(rx[k]->filt.ovsv),
+			"init rx[k]->buf.i");
+
+  rx[k]->buf.o = newCXB(rx[k]->len,
+			FiltOvSv_storepoint(rx[k]->filt.ovsv),
+			"init rx[k]->buf.o");
+
+  /* conversion */
+  rx[k]->osc.freq = -11025.0;
+  rx[k]->osc.phase = 0.0;
+  rx[k]->osc.gen = newOSC(rx[k]->len,
+			  ComplexTone,
+			  rx[k]->osc.freq,
+			  rx[k]->osc.phase,
+			  uni->rate.sample,
+			  "SDR RX Oscillator");
+
+  rx[k]->dttspagc.gen = newDttSPAgc(1,	// mode kept around for control reasons alone
+				    CXBbase(rx[k]->buf.o),	// input buffer
+				    rx[k]->len,
+				    1.0,	// Target output 
+				    2.0,	// Attack time constant in ms
+				    500,	// Decay time constant in ms
+				    1.0,	// Slope
+				    500,	//Hangtime in ms
+				    uni->rate.sample,	// Sample rate
+				    31622.8,	// Maximum gain as a multipler, linear not dB
+				    0.00001,	// Minimum gain as a multipler, linear not dB
+				    1.0,	// Set the current gain
+				    "AGC");	// Set a tag for an error message if the memory allocation fails
+
+  rx[k]->dttspagc.flag = TRUE;
+
+  rx[k]->grapheq.gen = new_EQ(rx[k]->buf.o, uni->rate.sample, uni->wisdom.bits);
+  rx[k]->grapheq.flag = FALSE;
+
+  /* demods */
+  rx[k]->am.gen = newAMD(uni->rate.sample,	// REAL samprate
+			 0.0,	// REAL f_initial
+			 -2000.0,	// REAL f_lobound,
+			 2000.0,	// REAL f_hibound,
+			 300.0,	// REAL f_bandwid,
+			 rx[k]->len,	// int size,
+			 CXBbase(rx[k]->buf.o),	// COMPLEX *ivec,
+			 CXBbase(rx[k]->buf.o),	// COMPLEX *ovec,
+			 AMdet,	// AM Mode AMdet == rectifier,
+			 //         SAMdet == synchronous detector
+			 "AM detector blew");	// char *tag
+  rx[k]->fm.gen = newFMD(uni->rate.sample,	// REAL samprate
+			 0.0,	// REAL f_initial
+			 -6000.0,	// REAL f_lobound
+			 6000.0,	// REAL f_hibound
+			 5000.0,	// REAL f_bandwid
+			 rx[k]->len,	// int size,
+			 CXBbase(rx[k]->buf.o),	// COMPLEX *ivec
+			 CXBbase(rx[k]->buf.o),	// COMPLEX *ovec
+			 "New FM Demod structure");	// char *error message;
+
+  /* noise reduction */
+  rx[k]->anf.gen = new_lmsr(rx[k]->buf.o,	// CXB signal,
+			    rx[k]->len,
+			    64,	// int delay,
+			    0.01,	// REAL adaptation_rate,
+			    0.00001,	// REAL leakage,
+			    45,	// int adaptive_filter_size,
+			    LMADF_INTERFERENCE);
+  rx[k]->anf.flag = FALSE;
+  rx[k]->banf.gen = new_blms(rx[k]->buf.o,
+			     0.00001,
+			     0.005,
+			     LMADF_INTERFERENCE,
+			     uni->wisdom.bits);
+  rx[k]->banf.flag = FALSE;
+
+  rx[k]->anr.gen = new_lmsr(rx[k]->buf.o,	// CXB signal,
+			    rx[k]->len,
+			    64,	// int delay,
+			    0.01,	// REAL adaptation_rate,
+			    0.00001,	// REAL leakage,
+			    45,	// int adaptive_filter_size,
+			    LMADF_NOISE);
+  rx[k]->anr.flag = FALSE;
+  rx[k]->banr.gen = new_blms(rx[k]->buf.o,
+			     0.00001,
+			     0.005,
+			     LMADF_NOISE,
+			     uni->wisdom.bits);
+  rx[k]->banr.flag = FALSE;
+
+  rx[k]->nb.thresh = 3.3;
+  rx[k]->nb.gen = new_noiseblanker(rx[k]->buf.i, rx[k]->nb.thresh);
+  rx[k]->nb.flag = FALSE;
+
+  rx[k]->nb_sdrom.thresh = 2.5;
+  rx[k]->nb_sdrom.gen = new_noiseblanker(rx[k]->buf.i, rx[k]->nb_sdrom.thresh);
+  rx[k]->nb_sdrom.flag = FALSE;
+
+  rx[k]->spot.gen = newSpotToneGen(-12.0,	// gain
+				   700.0,	// freq
+				   5.0,	// ms rise
+				   5.0,	// ms fall
+				   rx[k]->len,
+				   uni->rate.sample);	// sample rate
+
+  memset((char *) &rx[k]->squelch, 0, sizeof(rx[k]->squelch));
+  rx[k]->squelch.thresh = -150.0;
+  rx[k]->squelch.power = 0.0;
+  rx[k]->squelch.flag = rx[k]->squelch.running = rx[k]->squelch.set = FALSE;
+  rx[k]->squelch.num = rx[k]->len - 48;
+
+  rx[k]->cpd.gen = newWSCompander(uni->cpdlen, 0.0, rx[k]->buf.o);
+  rx[k]->cpd.flag = FALSE;
+
+  rx[k]->mode = uni->mode.sdr;
+  rx[k]->bin.flag = FALSE;
+
+  rx[k]->gain.i = rx[k]->gain.o = 1.0;
+
+  {
+    REAL pos = 0.5,		// 0 <= pos <= 1, left->right
+         theta = ((1.0 - pos) * M_PI / 2.0);
+    rx[k]->azim = Cmplx(cos(theta), sin(theta));
+  }
+
+  rx[k]->tick = 0;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Setup the transmit parameters 
+*
+* purely tx 
+*
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_tx(void) {
+
+  tx->len = uni->buflen;
+
+  /* conditioning */
+  tx->iqfix = newCorrectIQ(0.0, 1.0);
+  tx->filt.coef = newFIR_Bandpass_COMPLEX(300.0,
+					  3000.0,
+					  uni->rate.sample,
+					  tx->len + 1);
+  tx->filt.ovsv = newFiltOvSv(FIRcoef(tx->filt.coef),
+			      FIRsize(tx->filt.coef),
+			      uni->wisdom.bits);
+  normalize_vec_COMPLEX(tx->filt.ovsv->zfvec, tx->filt.ovsv->fftlen);
+
+  // hack for EQ
+  tx->filt.save = newvec_COMPLEX(tx->filt.ovsv->fftlen, "TX filter cache");
+  memcpy((char *) tx->filt.save,
+	 (char *) tx->filt.ovsv->zfvec,
+	 tx->filt.ovsv->fftlen * sizeof(COMPLEX));
+
+  /* buffers */
+  tx->buf.i = newCXB(tx->len,
+		     FiltOvSv_fetchpoint(tx->filt.ovsv),
+		     "init tx->buf.i");
+  tx->buf.o = newCXB(tx->len,
+		     FiltOvSv_storepoint(tx->filt.ovsv),
+		     "init tx->buf.o");
+
+  /***/
+  // experimental waveshaping/pre-distortion
+
+  tx->wvs.gen = newWaveShaper(tx->buf.i);
+  tx->wvs.flag = FALSE;
+
+  /***/
+
+  tx->dcb.flag = FALSE;
+  tx->dcb.gen = newDCBlocker(tx->buf.i);
+
+  /* conversion */
+  tx->osc.freq = 0.0;
+  tx->osc.phase = 0.0;
+  tx->osc.gen = newOSC(tx->len,
+		       ComplexTone,
+		       tx->osc.freq,
+		       tx->osc.phase,
+		       uni->rate.sample,
+		       "SDR TX Oscillator");
+
+  tx->am.carrier_level = 0.5;
+  tx->fm.cvtmod2freq = 2500.0 * TWOPI / uni->rate.sample;//5 kHz deviation
+
+  tx->leveler.gen = newDttSPAgc(1,	// mode kept around for control reasons
+				CXBbase(tx->buf.i),	// input buffer
+				tx->len,
+				1.1,	// Target output
+				2,	// Attack time constant in ms
+				500,	// Decay time constant in ms
+				1,	// Slope
+				500,	//Hangtime in ms
+				uni->rate.sample,
+				5.62,	// Maximum gain as a multiplier, linear not dB
+				1.0,	// Minimum gain as a multiplier, linear not dB
+				1.0,	// Set the current gain
+				"LVL");	// Set a tag for an error message if the memory allocation fails
+  tx->leveler.flag = TRUE;
+
+  tx->grapheq.gen = new_EQ(tx->buf.i, uni->rate.sample, uni->wisdom.bits);
+  tx->grapheq.flag = FALSE;
+
+  memset((char *) &tx->squelch, 0, sizeof(tx->squelch));
+  tx->squelch.thresh = -40.0;
+  tx->squelch.power = 0.0;
+  tx->squelch.flag = FALSE;
+  tx->squelch.running = tx->squelch.set = FALSE;
+  tx->squelch.num = uni->buflen - 48;
+
+  tx->spr.gen = newSpeechProc(0.4, 3.0, CXBbase(tx->buf.i), tx->len);
+  tx->spr.flag = FALSE;
+
+  tx->cpd.gen = newWSCompander(uni->cpdlen, -3.0, tx->buf.o);
+  tx->cpd.flag = FALSE;
+
+  memset((char *) &tx->sav, 0, sizeof(tx->sav));
+
+  tx->gain.i = tx->gain.o = 1.0;
+
+  tx->mode = uni->mode.sdr;
+
+  tx->tick = 0;
+  /* not much else to do for TX */
+}
+
+/* how the outside world sees it */
+
+/* -------------------------------------------------------------------------- */
+/** @brief Setup the SDR workspace 
+* 
+* @param samplerate 
+* @param buflen 
+* @param mode 
+* @param wisdom 
+* @param specsize 
+* @param numrecv 
+* @param cpdsize 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+setup_workspace(REAL samplerate,
+		int buflen,
+		SDRMODE mode,
+		char *wisdom,
+		int specsize,
+		int numrecv,
+		int cpdsize) {
+  int k;
+
+  setup_all(samplerate, buflen, mode, wisdom, specsize, numrecv, cpdsize);
+
+  for (k = 0; k < uni->multirx.nrx; k++) {
+    setup_rx(k);
+    uni->multirx.act[k] = FALSE;
+  }
+  uni->multirx.act[0] = TRUE;
+  uni->multirx.nac = 1;
+
+  setup_tx();
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy the SDR workspace 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+destroy_workspace(void) {
+  int k;
+
+  /* TX */
+  delWaveShaper(tx->wvs.gen);
+  delWSCompander(tx->cpd.gen);
+  delSpeechProc(tx->spr.gen);
+  delDttSPAgc(tx->leveler.gen);
+  delOSC(tx->osc.gen);
+  delDCBlocker(tx->dcb.gen);
+  delvec_COMPLEX(tx->filt.save);
+  delFiltOvSv(tx->filt.ovsv);
+  delFIR_Bandpass_COMPLEX(tx->filt.coef);
+  delCorrectIQ(tx->iqfix);
+  delCXB(tx->buf.o);
+  delCXB(tx->buf.i);
+
+  /* RX */
+  for (k = 0; k < uni->multirx.nrx; k++) {
+    delWSCompander(rx[k]->cpd.gen);
+    delSpotToneGen(rx[k]->spot.gen);
+    delDttSPAgc(rx[k]->dttspagc.gen);
+    del_nb(rx[k]->nb_sdrom.gen);
+    del_nb(rx[k]->nb.gen);
+    del_lmsr(rx[k]->anf.gen);
+    del_lmsr(rx[k]->anr.gen);
+    del_blms(rx[k]->banf.gen);
+    del_blms(rx[k]->banr.gen);
+    delAMD(rx[k]->am.gen);
+    delFMD(rx[k]->fm.gen);
+    delOSC(rx[k]->osc.gen);
+    delvec_COMPLEX(rx[k]->filt.save);
+    delFiltOvSv(rx[k]->filt.ovsv);
+    delFIR_Bandpass_COMPLEX(rx[k]->filt.coef);
+    delCorrectIQ(rx[k]->iqfix);
+    delCXB(rx[k]->buf.o);
+    delCXB(rx[k]->buf.i);
+  }
+
+  /* all */
+  finish_spectrum(&uni->spec);
+}
+
+//////////////////////////////////////////////////////////////////////////
+// execution
+//////////////////////////////////////////////////////////////////////////
+
+//========================================================================
+// util
+
+/* -------------------------------------------------------------------------- */
+/** @brief private CXBscl 
+* 
+* @param buff 
+* @param scl 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+CXBscl(CXB buff, REAL scl) {
+  int i;
+  for (i = 0; i < CXBhave(buff); i++)
+    CXBdata(buff, i) = Cscl(CXBdata(buff, i), scl);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private CXBnorm 
+* 
+* @param buff 
+ * @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+CXBnorm(CXB buff) {
+  int i;
+  REAL sum = 0.0;
+  for (i = 0; i < CXBhave(buff); i++)
+    sum += Csqrmag(CXBdata(buff, i));
+  return sqrt(sum / CXBhave(buff));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private CXBnormsqr 
+* 
+* @param buff 
+ * @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+CXBnormsqr(CXB buff) {
+  int i;
+  REAL sum = 0.0;
+  for (i = 0; i < CXBhave(buff); i++)
+    sum += Csqrmag(CXBdata(buff, i));
+  return sum;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private CXBpeak 
+* 
+* @param buff 
+ * @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+CXBpeak(CXB buff) {
+  int i;
+  REAL maxsam = 0.0;
+  for (i = 0; i < CXBhave(buff); i++)
+    maxsam = max(Cmag(CXBdata(buff, i)), maxsam);
+  return maxsam;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private CXBpeakpwr 
+* 
+* @param buff 
+ * @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+CXBpeakpwr(CXB buff) {
+  int i;
+  REAL maxpwr = 0.0;
+  for (i = 0; i < CXBhave(buff); i++)
+    maxpwr = max(Csqrmag(CXBdata(buff, i)), maxpwr);
+  return maxpwr;
+}
+
+//========================================================================
+/* all */
+
+/// unfortunate duplication here, due to
+/// multirx vs monotx
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_meter 
+* 
+* @param k 
+* @param buf 
+* @param tap 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_meter(int k, CXB buf, int tap) {
+  COMPLEX *vec = CXBbase(buf);
+  int i, len = CXBhave(buf);
+  REAL tmp;
+
+  switch (tap) {
+
+  case RXMETER_PRE_CONV:
+    tmp = -1;
+    for (i = 0; i < len; i++)
+      tmp = max(fabs(vec[i].re), tmp);
+    uni->meter.rx.val[k][ADC_REAL] = dBP(tmp);
+    tmp = -1;
+    for (i = 0; i < len; i++)
+      tmp = max(fabs(vec[i].im), tmp);
+    uni->meter.rx.val[k][ADC_IMAG] = dBP(tmp);
+    break;
+
+  case RXMETER_POST_FILT:
+    tmp = 0;
+    for (i = 0; i < len; i++)
+      tmp += Csqrmag(vec[i]);
+    rx[k]->norm = tmp / (REAL) len;
+    uni->meter.rx.val[k][SIGNAL_STRENGTH] = Log10P(tmp);
+    if (uni->meter.rx.mode[k] == SIGNAL_STRENGTH)
+      uni->meter.rx.val[k][AVG_SIGNAL_STRENGTH] = uni->meter.rx.val[k][SIGNAL_STRENGTH];
+    uni->meter.rx.val[k][AVG_SIGNAL_STRENGTH] =
+      DamPlus(uni->meter.rx.val[k][AVG_SIGNAL_STRENGTH], uni->meter.rx.val[k][SIGNAL_STRENGTH]);
+    break;
+
+  case RXMETER_POST_AGC:
+    uni->meter.rx.val[k][AGC_GAIN] = dBP(rx[k]->dttspagc.gen->gain.now);
+    break;
+
+  default:
+    break;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_spectrum 
+* 
+* @param k 
+* @param buf 
+* @param type 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_spectrum(int k, CXB buf, int type) {
+  if (uni->spec.flag && k == uni->spec.rxk && type == uni->spec.type) {
+    if ((uni->spec.type == SPEC_POST_DET) && (!rx[k]->bin.flag)) {
+      int i;
+      for (i = 0; i < CXBhave(rx[k]->buf.o); i++)
+	CXBdata(uni->spec.accum, uni->spec.fill + i) =
+	  Cmplx(CXBreal(rx[k]->buf.o, i) * M_SQRT2, 0.0);
+    } else {
+      memcpy((char *) &CXBdata(uni->spec.accum, uni->spec.fill),
+	     (char *) CXBbase(buf),
+	     CXBhave(buf) * sizeof(COMPLEX));
+    }
+    uni->spec.fill = (uni->spec.fill + CXBhave(buf)) & uni->spec.mask;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_spectrum 
+* 
+* @param buf 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_spectrum(CXB buf) {
+  if (uni->spec.type == SPEC_PREMOD) {
+    int i;
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      CXBdata(uni->spec.accum, uni->spec.fill + i) =
+	Cmplx(CXBreal(tx->buf.i, i), 0.0);
+  } else {
+    memcpy((char *) &CXBdata(uni->spec.accum, uni->spec.fill),
+	   (char *) CXBbase(buf),
+	   CXBhave(buf) * sizeof(COMPLEX));
+  }
+  uni->spec.fill = (uni->spec.fill + CXBhave(buf)) & uni->spec.mask;
+}
+
+//========================================================================
+/* RX processing */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private should_do_rx_squelch 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE BOOLEAN
+should_do_rx_squelch(int k) {
+  if (rx[k]->squelch.flag) {
+    int i, n = CXBhave(rx[k]->buf.o);
+    rx[k]->squelch.power = 0.0;
+
+    for (i = 0; i < n; i++)
+      rx[k]->squelch.power += Csqrmag(CXBdata(rx[k]->buf.o, i));
+
+    return Log10P(rx[k]->squelch.power) < rx[k]->squelch.thresh;
+
+  } else
+    return rx[k]->squelch.set = FALSE;
+}
+
+// located here for symmetry
+
+/* -------------------------------------------------------------------------- */
+/** @brief private should_do_tx_squelch 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE BOOLEAN
+should_do_tx_squelch(void) {
+  if (tx->squelch.flag) {
+    int i, n = CXBhave(tx->buf.i);
+    tx->squelch.power = 0.0;
+
+    for (i = 0; i < n; i++)
+      tx->squelch.power += Csqrmag(CXBdata(tx->buf.i, i));
+
+    return (-30 + Log10P(tx->squelch.power)) < tx->squelch.thresh;
+
+  } else
+    return tx->squelch.set = FALSE;
+}
+
+// apply squelch
+// slew into silence first time
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_squelch
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+do_rx_squelch(int k) {
+  rx[k]->squelch.set = TRUE;
+
+  if (!rx[k]->squelch.running) {
+    int i, m = rx[k]->squelch.num, n = CXBhave(rx[k]->buf.o) - m;
+
+    for (i = 0; i < m; i++)
+      CXBdata(rx[k]->buf.o, i) =
+	Cscl(CXBdata(rx[k]->buf.o, i), (1.0 - (REAL) i / m));
+
+    memset((void *) (CXBbase(rx[k]->buf.o) + m), 0, n * sizeof(COMPLEX));
+    rx[k]->squelch.running = TRUE;
+
+  } else
+    memset((void *) CXBbase(rx[k]->buf.o), 0, CXBhave(rx[k]->buf.o) * sizeof(COMPLEX));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_squelch 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_squelch(void) {
+  tx->squelch.set = TRUE;
+
+  if (!tx->squelch.running) {
+    int i, m = tx->squelch.num, n = CXBhave(tx->buf.i) - m;
+
+    for (i = 0; i < m; i++)
+      CXBdata(tx->buf.i, i) =
+	Cscl(CXBdata(tx->buf.i, i), (1.0 - (REAL) i / m));
+
+    memset((void *) (CXBbase(tx->buf.i) + m), 0, n * sizeof(COMPLEX));
+    tx->squelch.running = TRUE;
+
+  } else
+    memset((void *) CXBbase(tx->buf.i), 0, CXBhave(tx->buf.i) * sizeof(COMPLEX));
+}
+
+// lift squelch
+// slew out from silence to full scale
+
+/* -------------------------------------------------------------------------- */
+/** @brief 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+no_rx_squelch(int k) {
+  if (rx[k]->squelch.running) {
+    int i, m = rx[k]->squelch.num;
+
+    for (i = 0; i < m; i++)
+      CXBdata(rx[k]->buf.o, i) = Cscl(CXBdata(rx[k]->buf.o, i), (REAL) i / m);
+
+    rx[k]->squelch.running = FALSE;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private no_tx_squelch 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+no_tx_squelch(void) {
+  if (tx->squelch.running) {
+    int i, m = tx->squelch.num;
+
+    for (i = 0; i < m; i++)
+      CXBdata(tx->buf.i, i) = Cscl(CXBdata(tx->buf.i, i), (REAL) i / m);
+
+    tx->squelch.running = FALSE;
+  }
+}
+
+// pre-condition for (nearly) all RX modes
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_pre 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_pre(int k) {
+  int i, n = CXBhave(rx[k]->buf.i);
+
+  if (rx[k]->gain.i != 1.0)
+    CXBscl(rx[k]->buf.i, rx[k]->gain.i);
+
+  // active signal is in buf.i
+
+  do_rx_spectrum(k, rx[k]->buf.i, SPEC_SEMI_RAW);
+
+  if (rx[k]->nb.flag)
+    noiseblanker(rx[k]->nb.gen);
+  if (rx[k]->nb_sdrom.flag)
+    SDROMnoiseblanker(rx[k]->nb_sdrom.gen);
+
+  // metering for uncorrected values here
+
+  do_rx_meter(k, rx[k]->buf.i, RXMETER_PRE_CONV);
+
+  correctIQ(rx[k]->buf.i, rx[k]->iqfix);
+
+  /* 2nd IF conversion happens here */
+
+  if (rx[k]->osc.gen->Frequency != 0.0) {
+    ComplexOSC(rx[k]->osc.gen);
+    for (i = 0; i < n; i++)
+      CXBdata(rx[k]->buf.i, i) = Cmul(CXBdata(rx[k]->buf.i, i),
+				      OSCCdata(rx[k]->osc.gen, i));
+  }
+
+  // filtering, metering, spectrum, squelch, & AGC
+
+  do_rx_spectrum(k, rx[k]->buf.i, SPEC_PRE_FILT);
+
+#if 0
+  fprintf(stdout, " %9.6f", CXBnorm(rx[k]->buf.i));
+#endif
+
+  if (rx[k]->mode != SPEC) {
+    if (rx[k]->tick == 0)
+      reset_OvSv(rx[k]->filt.ovsv);
+    filter_OvSv(rx[k]->filt.ovsv);
+  } else
+    memcpy(CXBbase(rx[k]->buf.o),
+	   CXBbase(rx[k]->buf.i),
+	   sizeof(COMPLEX) * CXBhave(rx[k]->buf.i));
+
+  // active signal is now in buf.o
+
+  CXBhave(rx[k]->buf.o) = CXBhave(rx[k]->buf.i);
+
+#if 0
+  fprintf(stdout, " %9.6f", CXBnorm(rx[k]->buf.o));
+  fprintf(stdout, "\n");
+  fflush(stdout);
+#endif
+
+  do_rx_meter(k, rx[k]->buf.o, RXMETER_POST_FILT);
+  do_rx_spectrum(k, rx[k]->buf.o, SPEC_POST_FILT);
+
+  if (rx[k]->cpd.flag)
+    WSCompand(rx[k]->cpd.gen);
+
+  CXBhave(rx[k]->dttspagc.gen->buff) = CXBhave(rx[k]->buf.o);
+  DttSPAgc(rx[k]->dttspagc.gen, rx[k]->tick);
+
+  do_rx_meter(k, rx[k]->buf.o, RXMETER_POST_AGC);
+  do_rx_spectrum(k, rx[k]->buf.o, SPEC_POST_AGC);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_post 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_post(int k) {
+  int i, n = CXBhave(rx[k]->buf.o);
+
+  if (rx[k]->squelch.set)
+    do_rx_squelch(k);
+  else {
+    no_rx_squelch(k);
+    // spotting tone
+    if (rx[k]->spot.flag) {
+      // remember whether it's turned itself off during this pass
+      rx[k]->spot.flag = SpotTone(rx[k]->spot.gen);
+      for (i = 0; i < n; i++)
+	CXBdata(rx[k]->buf.o, i) = Cadd(CXBdata(rx[k]->buf.o, i),
+					CXBdata(rx[k]->spot.gen->buf, i));
+    }
+  }
+
+  if (rx[k]->grapheq.flag)
+    graphiceq(rx[k]->grapheq.gen);
+
+  do_rx_spectrum(k, rx[k]->buf.o, SPEC_POST_DET);
+
+  // apply individual rx gain
+
+  if (rx[k]->gain.o != 1.0)
+    CXBscl(rx[k]->buf.o, rx[k]->gain.o);
+
+  // not binaural?
+  // position in stereo field
+
+  if (!rx[k]->bin.flag)
+    for (i = 0; i < n; i++)
+      CXBdata(rx[k]->buf.o, i) = Cscl(rx[k]->azim,
+				      M_SQRT2 * CXBreal(rx[k]->buf.o, i));
+
+  // active signal now in buf.o
+}
+
+/* demod processing */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_SBCW 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_SBCW(int k) {
+
+  if (rx[k]->bin.flag) {
+    if ((rx[k]->banr.flag) && (rx[k]->anr.flag))
+      blms_adapt(rx[k]->banr.gen);
+    if ((rx[k]->banf.flag) && (rx[k]->anf.flag))
+      blms_adapt(rx[k]->banf.gen);
+
+  } else {
+    int i;
+    if (rx[k]->anr.flag)
+      if (rx[k]->banr.flag)
+	blms_adapt(rx[k]->banr.gen);
+      else
+	lmsr_adapt(rx[k]->anr.gen);
+    if (rx[k]->anf.flag)
+      if (rx[k]->banf.flag)
+	blms_adapt(rx[k]->banf.gen);
+      else
+	lmsr_adapt(rx[k]->anf.gen);
+    for (i = 0; i < CXBhave(rx[k]->buf.o); i++)
+      CXBimag(rx[k]->buf.o, i) = CXBreal(rx[k]->buf.o, i);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_AM 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_AM(int k) {
+  AMDemod(rx[k]->am.gen);
+  if (rx[k]->anf.flag)
+    if (!rx[k]->banf.flag)
+      lmsr_adapt(rx[k]->anf.gen);
+    else
+      blms_adapt(rx[k]->banf.gen);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_FM 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_FM(int k) { FMDemod(rx[k]->fm.gen); }
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_DRM
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_DRM(int k) {}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_SPEC 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_SPEC(int k) {}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx_NIL 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx_NIL(int k) {
+  int i, n = min(CXBhave(rx[k]->buf.i), uni->buflen);
+  for (i = 0; i < n; i++)
+    CXBdata(rx[k]->buf.o, i) = cxzero;
+}
+
+/* overall dispatch for RX processing */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_rx 
+* 
+* @param k 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_rx(int k) {
+  do_rx_pre(k);
+  switch (rx[k]->mode) {
+  case DIGU:
+  case DIGL:
+  case USB:
+  case LSB:
+  case CWU:
+  case CWL:
+  case DSB: do_rx_SBCW(k); break;
+  case AM:
+  case SAM: do_rx_AM(k); break;
+  case FMN: do_rx_FM(k); break;
+  case DRM: do_rx_DRM(k); break;
+  case SPEC:
+  default:  do_rx_SPEC(k); break;
+  }
+  do_rx_post(k);
+}
+
+//==============================================================
+/* TX processing */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_meter 
+* 
+* @param buf 
+* @param mt 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_meter(CXB buf, TXMETERTYPE mt) {
+  int i, len = CXBhave(buf);
+  REAL tmp;
+  switch (mt) {
+
+  case TX_MIC:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.mic = DamPlus(tx->sav.mic, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_MIC] = Log10Q(tx->sav.mic);
+    break;
+
+  case TX_PWR:
+    tmp = 0;
+    for (i = 0, uni->meter.tx.val[TX_PWR] = BITSY; i < CXBhave(tx->buf.o); i++)
+      tmp += Csqrmag(CXBdata(tx->buf.o, i));
+    uni->meter.tx.val[TX_PWR] = tmp/ (REAL) len;
+    break;
+
+  case TX_EQtap:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.eqtap = DamPlus(tx->sav.eqtap, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_EQtap] = Log10Q(tx->sav.eqtap);
+    break;
+
+  case TX_LEVELER:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.lvlr = DamPlus(tx->sav.lvlr, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_LEVELER] = Log10Q(tx->sav.lvlr);
+    uni->meter.tx.val[TX_LVL_G]   = dBP(tx->leveler.gen->gain.now);
+    break;
+
+  case TX_COMP:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.comp = DamPlus(tx->sav.comp, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_COMP] = Log10Q(tx->sav.comp);
+    break;
+
+  case TX_CPDR:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.cpdr = DamPlus(tx->sav.cpdr, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_CPDR] = Log10Q(tx->sav.cpdr);
+    break;
+
+    /***/
+  case TX_WAVS:
+    for (i = 0; i < CXBhave(tx->buf.i); i++)
+      tx->sav.cpdr = DamPlus(tx->sav.cpdr, Csqrmag(CXBdata(tx->buf.i, i)));
+    uni->meter.tx.val[TX_WAVS] = Log10Q(tx->sav.cpdr);
+    break;
+    /***/
+
+  default:
+    break;
+  }
+}
+
+/* pre-condition for (nearly) all TX modes */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_pre 
+*
+* pre-condition for (nearly) all TX modes 
+* @return void
+*
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_pre(void) {
+  int i;
+
+  if (tx->gain.i != 1.0)
+    CXBscl(tx->buf.i, tx->gain.i);
+
+  // active sig in buf.i
+
+  /***/
+  // experimental placement for pre-distortion/linearization
+
+  if (tx->wvs.flag)
+    WaveShape(tx->wvs.gen);
+  do_tx_meter(tx->buf.i, TX_WAVS);
+
+  /***/
+
+#if 0
+  for (i = 0; i < CXBhave(tx->buf.i); i++)
+    CXBdata(tx->buf.i, i) = Cmplx(CXBimag(tx->buf.i, i), 0.0);
+#endif
+
+  for (i = 0; i < CXBhave(tx->buf.i); i++) 
+    CXBreal(tx->buf.i, i) = CXBimag(tx->buf.i, i),
+    CXBimag(tx->buf.i, i) = 0.0;
+
+  if (tx->dcb.flag)
+    DCBlock(tx->dcb.gen);
+
+  do_tx_meter(tx->buf.i, TX_MIC);
+
+  if (should_do_tx_squelch())
+    do_tx_squelch();
+  else {
+    if (!tx->squelch.set)
+      no_tx_squelch();
+    if ((tx->mode != DIGU) && (tx->mode != DIGL)) {
+      if (tx->grapheq.flag)
+	graphiceq(tx->grapheq.gen);
+      do_tx_meter(tx->buf.i, TX_EQtap);
+      if (tx->leveler.flag)
+	DttSPAgc(tx->leveler.gen, tx->tick);
+      do_tx_meter(tx->buf.i, TX_LEVELER);
+      if (tx->spr.flag)
+	SpeechProcessor(tx->spr.gen);
+      do_tx_meter(tx->buf.i, TX_COMP);
+    } else {
+      do_tx_meter(tx->buf.i, TX_EQtap);
+      do_tx_meter(tx->buf.i, TX_LEVELER);
+      do_tx_meter(tx->buf.i, TX_LVL_G);
+      do_tx_meter(tx->buf.i, TX_COMP);
+      do_tx_meter(tx->buf.i, TX_CPDR);
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_post 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_post(void) {
+
+  // active signal still in buf.i
+
+  CXBhave(tx->buf.o) = CXBhave(tx->buf.i);
+  
+  if (tx->tick == 0)
+    reset_OvSv(tx->filt.ovsv);
+  filter_OvSv(tx->filt.ovsv);
+
+  // active signal now in buf.o
+
+  if (tx->cpd.flag)
+    WSCompand(tx->cpd.gen);
+  do_tx_meter(tx->buf.o, TX_CPDR);
+  
+  if (uni->spec.flag)
+    do_tx_spectrum(tx->buf.o);
+	    
+  if (tx->osc.gen->Frequency != 0.0) {
+    int i;
+    ComplexOSC(tx->osc.gen);
+    for (i = 0; i < CXBhave(tx->buf.o); i++) {
+      CXBdata(tx->buf.o, i) = Cmul(CXBdata(tx->buf.o, i),
+				   OSCCdata(tx->osc.gen, i));
+    }
+  }
+
+  correctIQ(tx->buf.o, tx->iqfix);
+
+  if (tx->gain.o != 1.0)
+    CXBscl(tx->buf.o, tx->gain.o);
+
+  do_tx_meter(tx->buf.o, TX_PWR);
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_SBCW 
+*
+* modulator processing 
+*
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_SBCW(void) {
+  if (tx->mode != DSB)
+    CXBscl(tx->buf.i, 2.0);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_AM 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_AM(void) {
+  int i;
+  for (i = 0; i < CXBhave(tx->buf.i); i++) {
+    REAL re =
+      tx->am.carrier_level +
+      (1.0 - tx->am.carrier_level) * CXBreal(tx->buf.i, i);
+    CXBdata(tx->buf.i, i) = Cmplx(re, 0.0);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_FM 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_FM(void) {
+  int i;
+  for (i = 0; i < CXBhave(tx->buf.i); i++) {
+    tx->osc.phase += CXBreal(tx->buf.i, i) * tx->fm.cvtmod2freq;
+    CXBdata(tx->buf.i, i) = Cmplx(cos(tx->osc.phase), sin(tx->osc.phase));
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx_NIL
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx_NIL(void) {
+  int i;
+  for (i = 0; i < CXBhave(tx->buf.i); i++)
+    CXBdata(tx->buf.i, i) = cxzero;
+}
+
+/* general TX processing dispatch */
+
+/* -------------------------------------------------------------------------- */
+/** @brief private do_tx 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+do_tx(void) {
+  do_tx_pre();
+  switch (tx->mode) {
+  case USB:
+  case LSB:
+  case CWU:
+  case CWL:
+  case DIGU:
+  case DIGL:
+  case DSB:  do_tx_SBCW(); break;
+  case AM:
+  case SAM:  do_tx_AM();   break;
+  case FMN:  do_tx_FM();   break;
+  case DRM:
+  case SPEC:
+  default:   do_tx_NIL();  break;
+  }
+  do_tx_post();
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief process_samples 
+* 
+* overall buffer processing;
+*   come here when there are buffers to work on 
+
+* @param bufl 
+* @param bufr 
+* @param n 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+process_samples(float *bufl, float *bufr, int n) {
+  int i, k;
+
+  switch (uni->mode.trx) {
+
+  case RX:
+
+    // make copies of the input for all receivers
+    for (k = 0; k < uni->multirx.nrx; k++)
+      if (uni->multirx.act[k]) {
+	for (i = 0; i < n; i++)
+	  CXBimag(rx[k]->buf.i, i) = bufl[i],
+	  CXBreal(rx[k]->buf.i, i) = bufr[i];
+	CXBhave(rx[k]->buf.i) = n;
+      }
+
+    // prepare buffers for mixing
+    memset((char *) bufl, 0, n * sizeof(float));
+    memset((char *) bufr, 0, n * sizeof(float));
+
+    // run all receivers
+    for (k = 0; k < uni->multirx.nrx; k++)
+      if (uni->multirx.act[k]) {
+	do_rx(k), rx[k]->tick++;
+	// mix
+	for (i = 0; i < n; i++)
+	  bufl[i] += CXBimag(rx[k]->buf.o, i),
+	  bufr[i] += CXBreal(rx[k]->buf.o, i);
+	CXBhave(rx[k]->buf.o) = n;
+      }
+
+    break;
+
+  case TX:
+
+    for (i = 0; i < n; i++)
+      CXBimag(tx->buf.i, i) = bufl[i],
+      CXBreal(tx->buf.i, i) = bufr[i];
+    CXBhave(tx->buf.i) = n;
+    tx->norm = CXBpeak(tx->buf.i);
+
+    do_tx(), tx->tick++;
+
+    for (i = 0; i < n; i++)
+      bufl[i] = CXBimag(tx->buf.o, i),
+      bufr[i] = CXBreal(tx->buf.o, i);
+    CXBhave(tx->buf.o) = n;
+
+    break;
+  }
+
+  uni->tick++;
+}
--- /dev/null
+++ dttsp-0~svn675/banal.h
@@ -0,0 +1,115 @@
+/* banal.h
+   stuff we're too embarrassed to declare otherwise
+   
+   This file is part of a program that implements a Software-Defined Radio.
+   
+   Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+   
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+   
+   The authors can be reached by email at
+   
+   ab2kt@arrl.net
+   or
+   rwmcgwier@gmail.com
+   
+   or by paper mail at
+   
+   The DTTS Microwave Society
+   6 Kathleen Place
+   Bridgewater, NJ 08807
+*/
+
+#ifndef _banal_h
+
+#define _banal_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <datatypes.h>
+
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+#ifndef max
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#endif
+#ifndef abs
+#define abs(a) ((a) >= 0 ? (a) : -(a))
+#endif
+
+#define MONDO 1e16
+#define BITSY 1e-16
+#define KINDA 2.56e2
+
+#define TRUE 1
+#define FALSE 0
+
+extern void nilfunc(void);
+extern int popcnt(int);
+extern int npoof2(int);
+extern int nblock2(int);
+extern int in_blocks(int count, int block_size);
+
+/*
+extern INLINE REAL sqr(REAL);
+extern INLINE REAL Log10(REAL);
+extern INLINE REAL Log10P(REAL);
+extern INLINE REAL Log10Q(REAL);
+extern INLINE REAL dBP(REAL);
+extern INLINE REAL DamPlus(REAL, REAL); */
+
+static INLINE REAL
+sqr(REAL x) { return x * x; }
+
+static INLINE REAL
+Log10(REAL x) { return log10(x + BITSY); }
+
+static INLINE REAL
+Log10P(REAL x) { return +10.0f * log10(x + BITSY); }
+
+static INLINE REAL
+Log10Q(REAL x) { return -10.0f * log10(x + BITSY); }
+
+static INLINE REAL
+dBP(REAL x) { return 20.0f * log10(x + BITSY); }
+
+static INLINE REAL
+DamPlus(REAL x0, REAL x1) { return 0.9995f * x0 + 0.0005 * x1; }
+
+extern FILE *efopen(char *path, char *mode);
+extern FILE *efreopen(char *path, char *mode, FILE * strm);
+extern size_t filesize(char *path);
+extern size_t fdsize(int fd);
+
+extern struct timeval now_tv(void);
+extern struct timeval diff_tv(struct timeval *, struct timeval *);
+extern struct timeval sum_tv(struct timeval *, struct timeval *);
+extern char *fmt_tv(struct timeval *);
+extern char *since(struct timeval *);
+extern struct timeval now_tv(void);
+
+extern int hinterp_vec(REAL *, int, REAL *, int);
+
+extern void status_message(char *msg);
+
+extern FILE *find_rcfile(char *base);
+
+extern unsigned long hash(unsigned char *str);
+
+extern int gcd(int u, int v);
+extern int lcm(int u, int v);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/fastrig.h
@@ -0,0 +1,102 @@
+/* fastrig.h
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _fastrig_h
+#define _fastrig_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+
+#ifdef notdef
+#include <cxops.h>
+#endif
+
+#define SIN_TABLE_SIZE 4096
+#define SIN_TABLE_SIZE_M1 4095
+
+/* ********************************************** 
+ * TRIG_SPEED: 
+ * 0 = normal (slow); 
+ * 1 = table look up with interpolation (medium);
+ * 2 = table look up (fast) 
+ * ***********************************************/
+
+/* Interpolation is ALWAYS done on atan2.  The setting
+   only applies to sin and cos */
+
+#ifndef TRIG_SPEED
+#define TRIG_SPEED 0
+#endif
+
+#if (TRIG_SPEED == 2)
+#define SIN(x)     fast_sin(x)
+#define COS(x)     fast_cos(x)
+#define ATAN2(x,y) fast_atan2((x),(y))
+
+#elif (TRIG_SPEED == 1)
+
+#define SIN(x)     fast_sin(x)
+#define COS(x)     fast_cos(x)
+#define ATAN2(x,y) fast_atan2((x),(y))
+
+#elif (TRIG_SPEED == 0)
+
+#define SIN(x)     (REAL)sin((REAL)x)
+#define COS(x)     (REAL)cos((REAL)x)
+#define ATAN2(x,y) (REAL)atan2((REAL)(x),(REAL)(y))
+
+#endif
+
+#ifndef PI
+#define PI M_PI
+#endif /* PI */
+
+#ifndef TWOPI
+#define TWOPI    (2.0 * PI)
+#endif
+
+#ifndef ONE_OVER_TWOPI
+#define ONE_OVER_TWOPI (0.159154943091895)
+#endif
+
+#if (TRIG_SPEED != 0)
+
+extern void InitSPEEDTRIG(void);
+extern REAL fast_sin(REAL);
+extern REAL fast_cos(REAL);
+extern REAL fast_atan2(REAL, REAL);
+
+#endif
+#endif
--- /dev/null
+++ dttsp-0~svn675/waveshape.c
@@ -0,0 +1,111 @@
+// waveshape.c
+// bipolar waveshaping
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <waveshape.h>
+
+// Sample is assumed to be (0+jx),
+//  ie, a real signal with signal in Q.
+// Waveshaping function is initialized at nil,
+//  so default result is identity.  
+// Original table should have odd length.
+// Table *as stored* is extended by 1 point
+//  with duplicate of last point to simplify
+//  interpolation logic.
+//  So wvs->tbl is actually wvs->npts+1 long,
+//   but wvs->npts represents original length.
+
+void
+WaveShape(WaveShaper wvs) {
+  REAL *tbl = wvs->tbl;
+  if (tbl) {
+    int i,
+        half = wvs->npts / 2,
+        n = CXBhave(wvs->buff);
+    
+    for (i = 0; i < n; i++) {
+      int j;
+      REAL d, x, xn, y;
+      
+      x = CXBimag(wvs->buff, i);
+      if (x < -1.0) x = -1.0;
+      if (x > +1.0) x = +1.0;
+      
+      xn = half * (x + 1.0),
+      j = xn,
+      d = xn - j,
+      y = tbl[j] + d * (tbl[j + 1] - tbl[j]);
+      
+      CXBimag(wvs->buff, i) = y;
+    }
+  }
+}
+
+void
+setWaveShaper(WaveShaper wvs, int npts, REAL *tbl) {
+  if (npts < 1) {
+    if (wvs->tbl)
+      delvec_REAL(wvs->tbl);
+    wvs->npts = 0;
+  } else {
+    if (wvs->tbl)
+      delvec_REAL(wvs->tbl);
+    wvs->tbl = newvec_REAL(npts + 1, "setWaveShaper table");
+    memcpy((char *) wvs->tbl, (char *) tbl, npts * sizeof(REAL));
+    wvs->tbl[npts] = wvs->tbl[npts - 1];
+    wvs->npts = npts;
+  }
+}
+
+WaveShaper
+newWaveShaper(CXB buff) {
+  WaveShaper wvs;
+
+  wvs = (WaveShaper) safealloc(1,
+			       sizeof(WaveShaper),
+			       "WaveShaper struct");
+  wvs->npts = 0;
+  wvs->tbl = 0;
+  wvs->buff = newCXB(CXBsize(buff), CXBbase(buff), "WaveShaper buff");
+  return wvs;
+}
+
+void
+delWaveShaper(WaveShaper wvs) {
+  if (wvs) {
+    if (wvs->tbl)
+      delvec_REAL(wvs->tbl);
+    delCXB(wvs->buff);
+    safefree((char *) wvs);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/sdr-main.c
@@ -0,0 +1,1098 @@
+/** 
+* @file sdr-main.c
+* @brief Software Defined Radio Main Module 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+///////////////////////////////////////////////////////////////////////
+
+#include <common.h>
+
+/// elementary defaults
+
+struct _loc loc;
+
+/////////////////////////////////////////////////////////////////////////
+/// most of what little we know here about the inner loop,
+/// functionally speaking
+
+extern void reset_meters(void);
+extern void reset_spectrum(void);
+extern void reset_counters(void);
+extern void process_samples(float *, float *, int);
+extern void setup_workspace(REAL samplerate,
+			    int buflen,
+			    SDRMODE mode,
+			    char *wisdom,
+			    int specsize,
+			    int numrecv,
+			    int cpdsize);
+extern void destroy_workspace(void);
+extern int reset_for_buflen(int new_buflen);
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private spectrum thread 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+spectrum_thread(void) {
+  while (top->running) {
+    sem_wait(top->sync.pws.sem);
+    sem_wait(top->sync.upd.sem);
+
+    if (fwrite((char *) &uni->spec.label, sizeof(int), 1, top->meas.spec.fp)
+	!= 1) {
+      fprintf(stderr, "error writing spectrum label\n");
+      exit(1);
+    }
+
+    if (fwrite((char *) &uni->spec.stamp, sizeof(int), 1, top->meas.spec.fp)
+	!= 1) {
+      fprintf(stderr, "error writing spectrum timestamp\n");
+      exit(1);
+    }
+
+    // spec points or waveform?
+    if (uni->spec.last == SPEC_LAST_FREQ) {
+      compute_spectrum(&uni->spec);
+      if (fwrite((char *) uni->spec.output, sizeof(float), uni->spec.size, top->meas.spec.fp)
+	  != uni->spec.size) {
+	fprintf(stderr, "error writing spectrum\n");
+	exit(1);
+      }
+
+    } else {
+      if (fwrite((char *) uni->spec.oscope, sizeof(float), uni->spec.size, top->meas.spec.fp)
+	  != uni->spec.size) {
+	fprintf(stderr, "error writing oscope\n");
+	exit(1);
+      }
+    }
+
+    fflush(top->meas.spec.fp);
+    sem_post(top->sync.upd.sem);
+  }
+
+  pthread_exit(0);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private meter thread 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+meter_thread(void) {
+  while (top->running) {
+    sem_wait(top->sync.mtr.sem);
+    sem_wait(top->sync.upd.sem);
+
+    if (fwrite((char *) &uni->meter.label, sizeof(int), 1, top->meas.mtr.fp)
+	!= 1) {
+      fprintf(stderr, "error writing meter label\n");
+      exit(1);
+    }
+
+    // RX or TX?
+    if (uni->meter.last == METER_LAST_RX) {
+      if (fwrite((char *) uni->meter.snap.rx,
+		 sizeof(REAL),
+		 MAXRX * RXMETERPTS,
+		 top->meas.mtr.fp)
+	  != MAXRX * RXMETERPTS) {
+	fprintf(stderr, "error writing rx meter\n");
+	exit(1);
+      }
+    } else {
+      if (fwrite((char *) uni->meter.snap.tx,
+		 sizeof(REAL),
+		 TXMETERPTS,
+		 top->meas.mtr.fp)
+	  != TXMETERPTS) {
+	fprintf(stderr, "error writing tx meter\n");
+	exit(1);
+      }
+    }
+
+    fflush(top->meas.mtr.fp);
+    sem_post(top->sync.upd.sem);
+  }
+
+  pthread_exit(0);
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private process update thread 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+process_updates_thread(void) {
+  while (top->running) {
+    pthread_testcancel();
+
+    while (fgets(top->parm.buff, sizeof(top->parm.buff), top->parm.fp)) {
+#if 0
+      fprintf(stderr, "command seen: %s", top->parm.buff);
+      fflush(stderr);
+#endif
+      do_update(top->parm.buff, top->verbose ? top->echo.fp : 0);
+    }
+  }
+
+  pthread_exit(0);
+}
+
+//========================================================================
+
+PRIVATE void
+run_mute(void) {
+  memset((char *) top->hold.buf.l, 0, top->hold.size.bytes);
+  memset((char *) top->hold.buf.r, 0, top->hold.size.bytes);
+  uni->tick++;
+}
+
+PRIVATE void
+run_pass(void) { uni->tick++; }
+
+PRIVATE void
+run_play(void) {
+#if 0
+  {
+    int i;
+    float sum = 0.0;
+    for (i = 0; i < top->hold.size.frames; i++)
+      sum += sqr(top->hold.buf.l[i]) + sqr(top->hold.buf.r[i]);
+    fprintf(stdout, "%9d %9.6f",
+	    uni->tick, sqrt(sum / top->hold.size.frames));
+  }
+#endif
+
+  process_samples(top->hold.buf.l, top->hold.buf.r, top->hold.size.frames);
+
+#if 0
+  {
+    int i;
+    float sum = 0.0;
+    for (i = 0; i < top->hold.size.frames; i++)
+      sum += sqr(top->hold.buf.l[i]) + sqr(top->hold.buf.r[i]);
+    fprintf(stdout, " %9.6f\n", sqrt(sum / top->hold.size.frames));
+  }
+  fflush(stdout);
+#endif
+}
+
+
+// NB do not set RUN_SWCH directly via setRunState;
+// use setSWCH instead
+
+PRIVATE void
+run_swch(void) {
+  int i, n = top->hold.size.frames;
+  REAL w;
+
+  process_samples(top->hold.buf.l, top->hold.buf.r, top->hold.size.frames);
+
+  for (i = 0; i < n; i++) {
+
+    if (top->swch.env.curr.type == SWCH_FALL) {
+      top->swch.env.curr.val += top->swch.env.fall.incr;
+      w = sin(top->swch.env.curr.val * M_PI /  2.0);
+      top->hold.buf.l[i] *= w, top->hold.buf.r[i] *= w;
+
+      if (++top->swch.env.curr.cnt >= top->swch.env.fall.size) {
+	top->swch.env.curr.type = SWCH_STDY;
+	top->swch.env.curr.cnt = 0;
+	top->swch.env.curr.val = 0.0;
+      }
+
+    } else if (top->swch.env.curr.type == SWCH_STDY) {
+      top->hold.buf.l[i]= top->hold.buf.r[i] = 0.0;
+
+      if (++top->swch.env.curr.cnt >= top->swch.env.stdy.size) {
+	top->swch.env.curr.type = SWCH_RISE;
+	top->swch.env.curr.cnt = 0;
+	top->swch.env.curr.val = 0.0;
+      }
+
+    } else if (top->swch.env.curr.type == SWCH_RISE) {
+      top->swch.env.curr.val += top->swch.env.rise.incr;
+      w = sin(top->swch.env.curr.val * M_PI /  2.0);
+      top->hold.buf.l[i] *= w, top->hold.buf.r[i] *= w;
+
+      if (++top->swch.env.curr.cnt >= top->swch.env.rise.size) {
+	uni->mode.trx = top->swch.trx.next;
+	top->state = top->swch.run.last;
+	break;
+      }
+    }
+  }
+}
+
+PRIVATE void
+run_test(void) {
+  int i;
+
+  switch (top->test.mode) {
+
+  case TEST_TONE:
+    ComplexOSC(top->test.tone.gen); // 1000
+    for (i = 0; i < top->hold.size.frames; i++)
+      top->hold.buf.l[i] = OSCreal(top->test.tone.gen, i) * top->test.tone.amp,
+      top->hold.buf.r[i] = OSCimag(top->test.tone.gen, i) * top->test.tone.amp;
+    break;
+
+  case TEST_2TONE:
+    ComplexOSC(top->test.twotone.a.gen); // 700
+    ComplexOSC(top->test.twotone.b.gen); // 1900
+    for (i = 0; i < top->hold.size.frames; i++)
+      top->hold.buf.l[i] =
+	OSCreal(top->test.twotone.a.gen, i) * top->test.twotone.a.amp +
+	OSCreal(top->test.twotone.b.gen, i) * top->test.twotone.b.amp,
+      top->hold.buf.r[i] =
+	OSCimag(top->test.twotone.a.gen, i) * top->test.twotone.a.amp +
+	OSCimag(top->test.twotone.b.gen, i) * top->test.twotone.b.amp;
+    break;
+
+#define ransig(x) ((drand48() * 0.5 - 1.0) * (x))
+  case TEST_NOISE:
+    for (i = 0; i < top->hold.size.frames; i++)
+      top->hold.buf.l[i] = ransig(top->test.noise.amp),
+      top->hold.buf.r[i] = ransig(top->test.noise.amp);
+    break;
+#undef ransig
+
+  default:
+    memset((char *) top->hold.buf.l, 0, top->hold.size.bytes);
+    memset((char *) top->hold.buf.r, 0, top->hold.size.bytes);
+    break;
+  }
+
+#if 0
+  {
+    int i;
+    float sum = 0.0;
+    for (i = 0; i < top->hold.size.frames; i++)
+      sum += sqr(top->hold.buf.l[i]) + sqr(top->hold.buf.r[i]);
+    fprintf(stdout, "%9d %9.6f",
+	    uni->tick, sqrt(sum / top->hold.size.frames));
+  }
+#endif
+
+  if (!top->test.thru)
+    process_samples(top->hold.buf.l, top->hold.buf.r, top->hold.size.frames);
+
+#if 0
+  {
+    int i;
+    float sum = 0.0;
+    for (i = 0; i < top->hold.size.frames; i++)
+      sum += sqr(top->hold.buf.l[i]) + sqr(top->hold.buf.r[i]);
+    fprintf(stdout, " %9.6f\n", sqrt(sum / top->hold.size.frames));
+  }
+  fflush(stdout);
+#endif
+}
+
+//========================================================================
+
+PRIVATE void
+audio_callback(jack_nframes_t nframes, void *arg) {
+  float *lp, *rp;
+  int nbytes = nframes * sizeof(float);
+
+  if (top->snds.doin) {
+    int i;
+    const float zero = 0.0;
+    
+    ringb_float_reset(top->snds.ring.i.l);
+    ringb_float_reset(top->snds.ring.i.r);
+    
+    for (i = top->offs; i < 0; i++)
+      ringb_float_write(top->snds.ring.i.l, &zero, 1);
+
+    for (i = 0; i < top->offs; i++)
+      ringb_float_write(top->snds.ring.i.r, &zero, 1);
+    
+    ringb_float_restart(top->snds.ring.o.r, nframes);
+    ringb_float_restart(top->snds.ring.o.l, nframes);
+    
+    top->snds.doin = FALSE;
+  }
+
+  if (top->susp) {
+    lp = (float *) jack_port_get_buffer(top->snds.port.o.l, nframes);
+    rp = (float *) jack_port_get_buffer(top->snds.port.o.r, nframes);
+    memset((char *) lp, 0, nbytes);
+    memset((char *) rp, 0, nbytes);
+    return;
+  }
+  
+  // output: copy from ring to port
+  
+  lp = (float *) jack_port_get_buffer(top->snds.port.o.l, nframes);
+  rp = (float *) jack_port_get_buffer(top->snds.port.o.r, nframes);
+  
+  if ((ringb_float_read_space(top->snds.ring.o.l) >= nframes) &&
+      (ringb_float_read_space(top->snds.ring.o.r) >= nframes)) {
+    ringb_float_read(top->snds.ring.o.l, lp, nframes);
+    ringb_float_read(top->snds.ring.o.r, rp, nframes);
+  } else {
+    memset((char *) lp, 0, nbytes);
+    memset((char *) rp, 0, nbytes);
+  }
+  
+  // input: copy from port to ring
+  if ((ringb_float_write_space(top->snds.ring.i.l) >= nframes) &&
+      (ringb_float_write_space(top->snds.ring.i.l) >= nframes)) {
+    lp = (float *) jack_port_get_buffer(top->snds.port.i.l, nframes);
+    rp = (float *) jack_port_get_buffer(top->snds.port.i.r, nframes);
+    ringb_float_write(top->snds.ring.i.l, lp, nframes);
+    ringb_float_write(top->snds.ring.i.r, rp, nframes);
+  } else
+    top->snds.doin = TRUE;
+  
+  // fire dsp
+  sem_post(top->sync.buf.sem);
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private gethold
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE BOOLEAN
+gethold(void) {
+  if ((ringb_float_read_space(top->snds.ring.i.l) >= top->hold.size.frames) &&
+      (ringb_float_read_space(top->snds.ring.i.r) >= top->hold.size.frames)) {
+    ringb_float_read(top->snds.ring.i.l, top->hold.buf.l, top->hold.size.frames);
+    ringb_float_read(top->snds.ring.i.r, top->hold.buf.r, top->hold.size.frames);
+    return TRUE;
+  } else
+    return FALSE;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private puthold 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+puthold(void) {
+  if ((ringb_float_write_space(top->snds.ring.o.l) >= top->hold.size.frames) &&
+      (ringb_float_write_space(top->snds.ring.o.r) >= top->hold.size.frames)) {
+    ringb_float_write(top->snds.ring.o.l,
+		      top->hold.buf.l,
+		      top->hold.size.frames);
+    ringb_float_write(top->snds.ring.o.r,
+		      top->hold.buf.r,
+		      top->hold.size.frames);
+  }
+}
+
+//========================================================================
+
+/* -------------------------------------------------------------------------- */
+/** @brief private run mute 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+process_samples_thread(void) {
+  while (top->running) {
+    sem_wait(top->sync.buf.sem);
+    while (gethold()) {
+      sem_wait(top->sync.upd.sem);
+      // run synchronous updates here
+      switch (top->state) {
+      case RUN_MUTE: run_mute(); break;
+      case RUN_PASS: run_pass(); break;
+      case RUN_PLAY: run_play(); break;
+      case RUN_SWCH: run_swch(); break;
+      case RUN_TEST: run_test(); break;
+      }
+      sem_post(top->sync.upd.sem);
+      puthold();
+    }
+  }
+}
+
+//========================================================================
+
+PRIVATE void
+execute(void) {
+  // let updates run
+  sem_post(top->sync.upd.sem);
+  
+  // rcfile
+  {
+    FILE *frc = find_rcfile(loc.path.rcfile);
+    if (frc) {
+      while (fgets(top->parm.buff, sizeof(top->parm.buff), frc))
+	do_update(top->parm.buff, top->echo.fp ? stderr : 0);
+      fclose(frc);
+    }
+  }
+
+  // start audio processing
+  if (jack_activate(top->snds.client))
+    fprintf(stderr, "cannot activate jack client"), exit(1);
+
+  // final shutdown always starts in update thread,
+  // so join it first
+  pthread_join(top->thrd.upd.id, 0);
+
+  // issue cancellation notices
+  pthread_cancel(top->thrd.trx.id);
+  if (uni->meter.flag)
+    pthread_cancel(top->thrd.mtr.id);
+  if (uni->spec.flag)
+    pthread_cancel(top->thrd.pws.id);
+
+  // wait for remaining threads to finish
+  pthread_join(top->thrd.trx.id, 0);
+  if (uni->meter.flag)
+    pthread_join(top->thrd.mtr.id, 0);
+  if (uni->spec.flag)
+    pthread_join(top->thrd.pws.id, 0);
+  
+  // stop audio processing
+  jack_client_close(top->snds.client);
+}
+
+//........................................................................
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief private run test 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_local_audio(void) {
+  top->offs = loc.skew.offs;
+  top->hold.size.frames = uni->buflen;
+  top->hold.size.bytes = top->hold.size.frames * sizeof(float);
+  top->hold.buf.l = (float *) safealloc(top->hold.size.frames,
+					sizeof(float),
+					"main hold buffer left");
+  top->hold.buf.r = (float *) safealloc(top->hold.size.frames,
+					sizeof(float),
+					"main hold buffer right");
+
+  // test generators
+
+  top->test.mode = TEST_TONE;
+  top->test.thru = FALSE;
+
+  // single tone
+  top->test.tone.gen = newOSC(top->hold.size.frames,
+			      ComplexTone,
+			      1000.0,
+			      0.0,
+			      uni->rate.sample,
+			      "test mode single tone");
+  // expressed in dB in update
+  top->test.tone.amp = 0.5;
+
+  // two tone
+  // top->test.mode = TEST_2TONE;
+  top->test.twotone.a.gen = newOSC(top->hold.size.frames,
+				   ComplexTone,
+				   700.0,
+				   0.0,
+				   uni->rate.sample,
+				   "test mode two tone A");
+  top->test.twotone.b.gen = newOSC(top->hold.size.frames,
+				   ComplexTone,
+				   1900.0,
+				   0.0,
+				   uni->rate.sample,
+				   "test mode two tone B");
+  // expressed in dB in update
+  top->test.twotone.a.amp = top->test.twotone.b.amp = 0.5;
+
+  // noise
+  // top->test.mode = TEST_NOISE;
+  srand48(time(0));
+  top->test.noise.amp = 0.5;
+}
+
+PRIVATE void 
+setup_updates(void) {
+  top->parm.path = loc.path.parm;
+  if ((top->parm.fd = open(top->parm.path, O_RDWR)) == -1)
+    perror(top->parm.path), exit(1);
+  if (!(top->parm.fp = fdopen(top->parm.fd, "r+"))) {
+    fprintf(stderr, "can't fdopen parm pipe %s\n", loc.path.parm);
+    exit(1);
+  }
+
+  // do this here 'cuz the update thread is controlling the action
+  if (uni->meter.flag) {
+    top->meas.mtr.path = loc.path.meter;
+    top->meas.mtr.fp = efopen(top->meas.mtr.path, "r+");
+  }
+  if (uni->spec.flag) {
+    top->meas.spec.path = loc.path.spec;
+    top->meas.spec.fp = efopen(top->meas.spec.path, "r+");
+  }
+
+  if (uni->update.path = loc.path.replay) {
+    uni->update.flag = TRUE;
+    uni->update.fp = efopen(uni->update.path, "w+");
+  }
+
+  if (top->verbose) {
+    if (loc.path.echo[0]) {
+      top->echo.path = loc.path.echo;
+      if ((top->echo.fd = open(top->echo.path, O_RDWR)) == -1)
+	perror(top->echo.path), exit(1);
+      if (!(top->echo.fp = fdopen(top->echo.fd, "r+"))) {
+	fprintf(stderr, "can't fdopen echo file %s\n", loc.path.echo);
+	exit(1);
+      }
+    } else {
+      top->echo.path = 0;
+      top->echo.fp = stderr;
+      top->echo.fd = fileno(top->echo.fp);
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private audio callback 
+* 
+* @param nframes 
+* @param arg 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+jack_xrun(void *arg) {}
+
+PRIVATE void
+jack_shutdown(void *arg) {}
+
+PRIVATE void
+setup_system_audio(void) {
+  if (loc.name[0])
+    strcpy(top->snds.name, loc.name);
+  else
+    sprintf(top->snds.name, "sdr-%d", top->pid);
+  
+  if (!(top->snds.client = jack_client_new(top->snds.name)))
+    perror("can't make client -- jack not running?"), exit(1);
+
+  if ((jack_nframes_t) loc.def.rate != jack_get_sample_rate(top->snds.client)) {
+    fprintf(stderr, "There's a sample rate mismatch.\n");
+    fprintf(stderr, "dttsp rate is %d.\n", (jack_nframes_t) loc.def.rate);
+    fprintf(stderr, "jackd rate is %d.\n", jack_get_sample_rate(top->snds.client));
+    fprintf(stderr, "Time to exit so you can straighten this out.\n");
+    exit(1);
+  }
+
+  jack_set_process_callback(top->snds.client, (void *) audio_callback, 0);
+  jack_on_shutdown(top->snds.client, (void *) jack_shutdown, 0);
+  jack_set_xrun_callback(top->snds.client, (void *) jack_xrun, 0);
+  top->snds.size = jack_get_buffer_size(top->snds.client);
+
+  top->snds.port.i.l = jack_port_register(top->snds.client,
+                                          "il",
+					  JACK_DEFAULT_AUDIO_TYPE,
+					  JackPortIsInput,
+					  0);
+  top->snds.port.i.r = jack_port_register(top->snds.client,
+					  "ir",
+					  JACK_DEFAULT_AUDIO_TYPE,
+					  JackPortIsInput,
+					  0);
+  top->snds.port.o.l = jack_port_register(top->snds.client,
+					  "ol",
+					  JACK_DEFAULT_AUDIO_TYPE,
+					  JackPortIsOutput,
+					  0);
+  top->snds.port.o.r = jack_port_register(top->snds.client,
+					  "or",
+					  JACK_DEFAULT_AUDIO_TYPE,
+					  JackPortIsOutput,
+					  0);
+
+  {
+    int nr = nblock2(max(top->hold.size.frames, top->snds.size) * loc.mult.ring);
+    top->snds.ring.i.l = ringb_float_create(nr);
+    top->snds.ring.i.r = ringb_float_create(nr);
+    top->snds.ring.o.l = ringb_float_create(nr);
+    top->snds.ring.o.r = ringb_float_create(nr);
+  }
+
+  top->snds.doin = TRUE;
+}
+
+PRIVATE sem_t *
+make_sem(char *id, char *path) {
+  sem_t *s;
+
+  sprintf(path, "%s.%s", top->snds.name, id);
+  sem_unlink(path);
+  if ((s = sem_open(path, O_CREAT | O_EXCL, 0600, 0))
+      == (sem_t *) -1) {
+    fprintf(stderr, "Failed to open semaphore %s\n", path);
+    exit(1);
+  }
+  //sem_unlink(path);
+  return s;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private process samples 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_threading(void) {
+  top->sync.upd.sem = make_sem("update", top->sync.upd.name);
+  pthread_create(&top->thrd.upd.id, 0, (void *) process_updates_thread, 0);
+
+  top->sync.buf.sem = make_sem("buffer", top->sync.buf.name);
+  pthread_create(&top->thrd.trx.id, 0, (void *) process_samples_thread, 0);
+
+  top->susp = FALSE;
+
+  if (uni->meter.flag) {
+    top->sync.mtr.sem = make_sem("meter", top->sync.mtr.name);
+    pthread_create(&top->thrd.mtr.id, 0, (void *) meter_thread, 0);
+  }
+
+  if (uni->spec.flag) {
+    top->sync.pws.sem = make_sem("spectrum", top->sync.pws.name);
+    pthread_create(&top->thrd.pws.id, 0, (void *) spectrum_thread, 0);
+  }
+}
+
+//========================================================================
+// hard defaults, then environment
+
+/* -------------------------------------------------------------------------- */
+/** @brief private execute 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_defaults(void) {
+  // no env vars for these
+  loc.name[0] = 0; // no default for client name, period
+  loc.path.echo[0] = 0;  // file defaults to stderr
+
+  strcpy(loc.path.meter,  METERPATH);
+  strcpy(loc.path.parm,   PARMPATH);
+  strcpy(loc.path.rcfile, RCBASE);
+  strcpy(loc.path.replay, REPLAYPATH);
+  strcpy(loc.path.spec,   SPECPATH);
+  strcpy(loc.path.wisdom, WISDOMPATH);
+
+  loc.def.comp =  DEFCOMP;
+  loc.def.mode =  DEFMODE;
+  loc.def.nrx =   MAXRX;
+  loc.def.rate =  DEFRATE;
+  loc.def.size =  DEFSIZE;
+  loc.def.spec =  DEFSPEC;
+  loc.mult.ring = RINGMULT;
+  loc.skew.offs = DEFOFFS;
+
+  {
+    char *ep;
+    if ((ep = getenv("SDR_DEFMODE")))    loc.def.mode = atoi(ep);
+    if ((ep = getenv("SDR_DEFRATE")))    loc.def.rate = atof(ep);
+    if ((ep = getenv("SDR_DEFSIZE")))    loc.def.size = atoi(ep);
+    if ((ep = getenv("SDR_RINGMULT")))   loc.mult.ring = atoi(ep);
+    if ((ep = getenv("SDR_SKEWOFFS")))   loc.skew.offs = atoi(ep);
+    if ((ep = getenv("SDR_METERPATH")))  strcpy(loc.path.meter, ep);
+    if ((ep = getenv("SDR_NAME")))       strcpy(loc.name, ep);
+    if ((ep = getenv("SDR_PARMPATH")))   strcpy(loc.path.parm, ep);
+    if ((ep = getenv("SDR_RCBASE")))     strcpy(loc.path.rcfile, ep);
+    if ((ep = getenv("SDR_REPLAYPATH"))) strcpy(loc.path.replay, ep);
+    if ((ep = getenv("SDR_SPECPATH")))   strcpy(loc.path.spec, ep);
+    if ((ep = getenv("SDR_WISDOMPATH"))) strcpy(loc.path.wisdom, ep);
+  }
+}
+
+//========================================================================
+
+int
+reset_for_buflen(int new_buflen) {
+
+  // make sure new size is power of 2
+  if (popcnt(new_buflen) != 1)
+    return -1;
+
+  safefree((char *) top->hold.buf.r);
+  safefree((char *) top->hold.buf.l);
+
+  destroy_workspace();
+
+  //  fprintf(stderr, "safemem %d\n", safememcurrcount());
+  safememreset();
+
+  setup_workspace(loc.def.rate,
+		  loc.def.size = new_buflen,
+		  loc.def.mode,
+		  loc.path.wisdom, 
+		  loc.def.spec, 
+		  loc.def.nrx, 
+		  loc.def.size);
+
+  setup_local_audio();
+
+  reset_meters();
+  reset_spectrum();
+  reset_counters();
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setup local _audio 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+destroy_globals(void) {
+  int i;
+  safefree((char *) tx);
+  for (i = 0; i < MAXRX; i++)
+    safefree((char *) rx[i]);
+  safefree((char *) uni);
+  safefree((char *) top);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setup updates 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void 
+closeup(void) {
+  ringb_float_free(top->snds.ring.o.r);
+  ringb_float_free(top->snds.ring.o.l);
+  ringb_float_free(top->snds.ring.i.r);
+  ringb_float_free(top->snds.ring.i.l);
+
+  safefree((char *) top->hold.buf.r);
+  safefree((char *) top->hold.buf.l);
+
+  delOSC(top->test.tone.gen);
+  delOSC(top->test.twotone.a.gen);
+  delOSC(top->test.twotone.b.gen);
+
+  fclose(top->parm.fp);
+
+  if (top->verbose && top->echo.fp != stderr)
+    fclose(top->echo.fp);
+
+  sem_close(top->sync.buf.sem);
+  sem_unlink(top->sync.buf.name);
+  sem_close(top->sync.upd.sem);
+  sem_unlink(top->sync.upd.name);
+
+  if (uni->meter.flag) {
+    fclose(top->meas.mtr.fp);
+    sem_close(top->sync.mtr.sem);
+    sem_unlink(top->sync.mtr.name);
+  }
+
+  if (uni->spec.flag) {
+    fclose(top->meas.spec.fp);
+    sem_close(top->sync.pws.sem);
+    sem_unlink(top->sync.pws.name);
+  }
+
+  if (uni->update.flag)
+    fclose(uni->update.fp);
+
+  destroy_workspace();
+
+  destroy_globals();
+
+  //  fprintf(stderr, "safemem %d\n", safememcurrcount());
+
+  exit(0);
+}
+
+//========================================================================
+// commandline processing
+
+PRIVATE struct option long_options[] = {
+  {"verbose",       no_argument,       0,  0},
+  {"spectrum",      no_argument,       0,  1},
+  {"metering",      no_argument,       0,  2},
+  {"load",          required_argument, 0,  3},
+  {"mode",          required_argument, 0,  4},
+  {"buffsize",      required_argument, 0,  5},
+  {"ringmult",      required_argument, 0,  6},
+  {"meter-path",    required_argument, 0,  8},
+  {"client-name",   required_argument, 0,  9},
+  {"command-path",  required_argument, 0, 10},
+  {"init-path",     required_argument, 0, 11},
+  {"replay-path",   required_argument, 0, 12},
+  {"spectrum-path", required_argument, 0, 13},
+  {"wisdom-path",   required_argument, 0, 14},
+  {"echo-path",     required_argument, 0, 15},
+  {"skewoffs",      required_argument, 0, 16},
+  {"help",          no_argument,       0, 99},
+  {0,               0,                 0,  0}
+};
+PRIVATE char *short_options = "vmsl:h?";
+PRIVATE int option_index;
+
+PRIVATE void usage(void);
+
+/* -------------------------------------------------------------------------- */
+/** @brief private setup threading 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup_from_commandline(int argc, char **argv) {
+  int c;
+  while ((c = getopt_long(argc, argv,
+			  short_options,
+			  long_options,
+			  &option_index)) != EOF) {
+    switch (c) {
+    case 0:
+    case 'v':
+      top->verbose = TRUE;
+      break;
+
+    case 1:
+    case 's':
+      uni->spec.flag = TRUE;
+      break;
+
+    case 2:
+    case 'm':
+      uni->meter.flag = TRUE;
+      break;
+
+    case 3:
+    case 'l':
+      strcpy(loc.path.rcfile, optarg);
+      break;
+
+    case 4:
+      loc.def.mode = atoi(optarg);
+      break;
+
+    case 5:
+      loc.def.size = atoi(optarg);
+      break;
+
+    case 6:
+      loc.mult.ring = atoi(optarg);
+      break;
+
+    case 8:
+      strcpy(loc.path.meter, optarg);
+      break;
+
+    case 9:
+      strcpy(loc.name, optarg);
+      break;
+
+    case 10:
+      strcpy(loc.path.parm, optarg);
+      break;
+
+    case 11:
+      strcpy(loc.path.rcfile, optarg);
+      break;
+
+    case 12:
+      strcpy(loc.path.replay, optarg);
+      break;
+
+    case 13:
+      strcpy(loc.path.spec, optarg);
+      break;
+
+    case 14:
+      strcpy(loc.path.wisdom, optarg);
+      break;
+
+    case 15:
+      strcpy(loc.path.echo, optarg);
+      break;
+
+    case 16:
+      loc.skew.offs = atoi(optarg);
+      break;
+
+    case 99:
+    case 'h':
+    default:
+      usage();
+    }
+  }
+}  
+
+//========================================================================
+
+PRIVATE void
+create_globals(void) {
+  int i;
+  top = (struct _top *) safealloc(1, sizeof(struct _top), "top global");
+  uni = (struct _uni *) safealloc(1, sizeof(struct _uni), "uni global");
+  for (i = 0; i < MAXRX; i++)
+    rx[i] = (struct _rx *) safealloc(1, sizeof(struct _rx), "rx global");
+  tx = (struct _tx *) safealloc(1, sizeof(struct _tx), "tx global");
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief private destroy globals 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+setup(int argc, char **argv) {
+  create_globals();
+
+  top->pid = getpid();
+  top->uid = getuid();
+  top->start_tv = now_tv();
+  top->running = TRUE;
+  top->verbose = FALSE;
+  top->state = RUN_PLAY;
+  top->offs = DEFOFFS;
+  top->snds.doin = FALSE;
+  top->snds.rsiz = DEFSIZE;
+
+  //  fprintf(stderr, "safemem %d\n", safememcurrcount());
+  safememreset();
+
+  setup_defaults();
+
+  setup_from_commandline(argc, argv);
+
+  setup_workspace(loc.def.rate,
+		  loc.def.size,
+		  loc.def.mode,
+		  loc.path.wisdom,
+		  loc.def.spec,
+		  loc.def.nrx,
+		  loc.def.comp);
+
+  setup_updates();
+
+  setup_local_audio();
+  setup_system_audio();
+
+  setup_threading();
+
+  reset_meters();
+  reset_spectrum();
+  reset_counters();
+}
+
+//========================================================================
+
+int 
+main(int argc, char **argv) { setup(argc, argv), execute(), closeup(); } 
+
+/* -------------------------------------------------------------------------- */
+/** @brief private create globals 
+ * @return void
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+usage(void) {
+  fprintf(stderr, "--verbose\n");
+  fprintf(stderr, " -v\n");
+  fprintf(stderr, "	Turn on verbose mode (echo commands, etc.)\n");
+  fprintf(stderr, "--spectrum\n");
+  fprintf(stderr, " -s\n");
+  fprintf(stderr, "	Turn on spectrum computation\n");
+  fprintf(stderr, "--metering\n");
+  fprintf(stderr, " -m\n");
+  fprintf(stderr, "	Turn on meter computation\n");
+  fprintf(stderr, "--load=<load-file>\n");
+  fprintf(stderr, " -l <load-file>\n");
+  fprintf(stderr, "	Read update commands from <load-file> at startup\n");
+  fprintf(stderr, "--mode=<mode>\n");
+  fprintf(stderr, "	Start radio in mode <mode>\n");
+  fprintf(stderr, "--buffsize=<power-of-2>\n");
+  fprintf(stderr, "	Use <power-of-2> as DSP buffersize\n");
+  fprintf(stderr, "--ringmult=<num>\n");
+  fprintf(stderr, "	Use <num> * <buffsize> for ring buffer length\n");
+  fprintf(stderr, "--meter-path=<pipe-path>\n");
+  fprintf(stderr, "	Use named pipe <pipe-path> as conduit for meter data\n");
+  fprintf(stderr, "--command-path=<pipe-path>\n");
+  fprintf(stderr, "	Use named pipe <pipe-path> as a conduit for update commands\n");
+  fprintf(stderr, "--init-path=<init-file>\n");
+  fprintf(stderr, "	Read update commands from <init-file> at startup. Like -l.\n");
+  fprintf(stderr, "--replay-path=<path>\n");
+  fprintf(stderr, "	Write/reread saved update commands to/from <path>\n");
+  fprintf(stderr, "--spectrum-path=<pipe-path>\n");
+  fprintf(stderr, "	Use named pipe <pipe-path> as conduit for spectrum data\n");
+  fprintf(stderr, "--wisdom-path=<path>\n");
+  fprintf(stderr, "	fftw3 wisdom is in <path>\n");
+  fprintf(stderr, "--echo-path=<path>\n");
+  fprintf(stderr, "	Write update command processor output to <path>\n");
+  fprintf(stderr, "--skewoffs=<+/-num>\n");
+  fprintf(stderr, "	Correct for audio channel skew by <num>\n");
+  fprintf(stderr, "--help\n");
+  fprintf(stderr, " -h\n");
+  fprintf(stderr, "	Write this message and exit.\n");
+  fprintf(stderr, "Environment variables:\n");
+  fprintf(stderr, "\tSDR_DEFMODE\n");
+  fprintf(stderr, "\tSDR_DEFRATE\n");
+  fprintf(stderr, "\tSDR_DEFSIZE\n");
+  fprintf(stderr, "\tSDR_RINGMULT\n");
+  fprintf(stderr, "\tSDR_SKEWOFFS\n");
+  fprintf(stderr, "\tSDR_METERPATH\n");
+  fprintf(stderr, "\tSDR_NAME\n");
+  fprintf(stderr, "\tSDR_PARMPATH\n");
+  fprintf(stderr, "\tSDR_RCBASE\n");
+  fprintf(stderr, "\tSDR_REPLAYPATH\n");
+  fprintf(stderr, "\tSDR_SPECPATH\n");
+  fprintf(stderr, "\tSDR_WISDOMPATH\n");
+
+  exit(1);
+}  
--- /dev/null
+++ dttsp-0~svn675/fastrig.c
@@ -0,0 +1,300 @@
+/** 
+* @file fastrig.c
+* @brief Fast trigonometric Routines  
+* @author Bob McGwier, N4HY 
+
+** **************************************************************
+ *   Fast Trigonometric Routines Used for Embedded Systems      *
+ *   Programmer:  Bob McGwier, IDA CCR-P, June, 2000            *
+ ************************************************************** *
+** This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The author can be reached by email at
+
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+Robert W McGwier, N4HY
+64 Brooktree Road
+East Windsor, NJ 08520
+*/
+
+#include <fastrig.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Phase modulation 
+* 
+* @param angle 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+phasemod(REAL angle) {
+  while (angle >= TWOPI)
+    angle -= (REAL) TWOPI;
+  while (angle < 0.0)
+    angle += (REAL) TWOPI;
+  return angle;
+}
+
+//REAL phasemod(REAL angle)
+//{
+ // return (angle - floor(angle/TWOPI)*TWOPI);
+//}
+
+#if (TRIG_SPEED != 0)
+
+static REAL TABLE_FACTOR;
+static REAL *sinT, *cosT;
+
+/** ************************************************************************ */
+/* Constant definitions                                                    */
+/** ************************************************************************ */
+#define TAN_MAP_RES     0.003921569	/* (smallest non-zero value in table) */
+#define RAD_PER_DEG     0.017453293
+#define TAN_MAP_SIZE    256
+
+/* arctangents from 0 to pi/4 radians */
+static REAL fast_atan_table[257] = {
+  0.000000e+00, 3.921549e-03, 7.842976e-03, 1.176416e-02,
+  1.568499e-02, 1.960533e-02, 2.352507e-02, 2.744409e-02,
+  3.136226e-02, 3.527947e-02, 3.919560e-02, 4.311053e-02,
+  4.702413e-02, 5.093629e-02, 5.484690e-02, 5.875582e-02,
+  6.266295e-02, 6.656816e-02, 7.047134e-02, 7.437238e-02,
+  7.827114e-02, 8.216752e-02, 8.606141e-02, 8.995267e-02,
+  9.384121e-02, 9.772691e-02, 1.016096e-01, 1.054893e-01,
+  1.093658e-01, 1.132390e-01, 1.171087e-01, 1.209750e-01,
+  1.248376e-01, 1.286965e-01, 1.325515e-01, 1.364026e-01,
+  1.402496e-01, 1.440924e-01, 1.479310e-01, 1.517652e-01,
+  1.555948e-01, 1.594199e-01, 1.632403e-01, 1.670559e-01,
+  1.708665e-01, 1.746722e-01, 1.784728e-01, 1.822681e-01,
+  1.860582e-01, 1.898428e-01, 1.936220e-01, 1.973956e-01,
+  2.011634e-01, 2.049255e-01, 2.086818e-01, 2.124320e-01,
+  2.161762e-01, 2.199143e-01, 2.236461e-01, 2.273716e-01,
+  2.310907e-01, 2.348033e-01, 2.385093e-01, 2.422086e-01,
+  2.459012e-01, 2.495869e-01, 2.532658e-01, 2.569376e-01,
+  2.606024e-01, 2.642600e-01, 2.679104e-01, 2.715535e-01,
+  2.751892e-01, 2.788175e-01, 2.824383e-01, 2.860514e-01,
+  2.896569e-01, 2.932547e-01, 2.968447e-01, 3.004268e-01,
+  3.040009e-01, 3.075671e-01, 3.111252e-01, 3.146752e-01,
+  3.182170e-01, 3.217506e-01, 3.252758e-01, 3.287927e-01,
+  3.323012e-01, 3.358012e-01, 3.392926e-01, 3.427755e-01,
+  3.462497e-01, 3.497153e-01, 3.531721e-01, 3.566201e-01,
+  3.600593e-01, 3.634896e-01, 3.669110e-01, 3.703234e-01,
+  3.737268e-01, 3.771211e-01, 3.805064e-01, 3.838825e-01,
+  3.872494e-01, 3.906070e-01, 3.939555e-01, 3.972946e-01,
+  4.006244e-01, 4.039448e-01, 4.072558e-01, 4.105574e-01,
+  4.138496e-01, 4.171322e-01, 4.204054e-01, 4.236689e-01,
+  4.269229e-01, 4.301673e-01, 4.334021e-01, 4.366272e-01,
+  4.398426e-01, 4.430483e-01, 4.462443e-01, 4.494306e-01,
+  4.526070e-01, 4.557738e-01, 4.589307e-01, 4.620778e-01,
+  4.652150e-01, 4.683424e-01, 4.714600e-01, 4.745676e-01,
+  4.776654e-01, 4.807532e-01, 4.838312e-01, 4.868992e-01,
+  4.899573e-01, 4.930055e-01, 4.960437e-01, 4.990719e-01,
+  5.020902e-01, 5.050985e-01, 5.080968e-01, 5.110852e-01,
+  5.140636e-01, 5.170320e-01, 5.199904e-01, 5.229388e-01,
+  5.258772e-01, 5.288056e-01, 5.317241e-01, 5.346325e-01,
+  5.375310e-01, 5.404195e-01, 5.432980e-01, 5.461666e-01,
+  5.490251e-01, 5.518738e-01, 5.547124e-01, 5.575411e-01,
+  5.603599e-01, 5.631687e-01, 5.659676e-01, 5.687566e-01,
+  5.715357e-01, 5.743048e-01, 5.770641e-01, 5.798135e-01,
+  5.825531e-01, 5.852828e-01, 5.880026e-01, 5.907126e-01,
+  5.934128e-01, 5.961032e-01, 5.987839e-01, 6.014547e-01,
+  6.041158e-01, 6.067672e-01, 6.094088e-01, 6.120407e-01,
+  6.146630e-01, 6.172755e-01, 6.198784e-01, 6.224717e-01,
+  6.250554e-01, 6.276294e-01, 6.301939e-01, 6.327488e-01,
+  6.352942e-01, 6.378301e-01, 6.403565e-01, 6.428734e-01,
+  6.453808e-01, 6.478788e-01, 6.503674e-01, 6.528466e-01,
+  6.553165e-01, 6.577770e-01, 6.602282e-01, 6.626701e-01,
+  6.651027e-01, 6.675261e-01, 6.699402e-01, 6.723452e-01,
+  6.747409e-01, 6.771276e-01, 6.795051e-01, 6.818735e-01,
+  6.842328e-01, 6.865831e-01, 6.889244e-01, 6.912567e-01,
+  6.935800e-01, 6.958943e-01, 6.981998e-01, 7.004964e-01,
+  7.027841e-01, 7.050630e-01, 7.073330e-01, 7.095943e-01,
+  7.118469e-01, 7.140907e-01, 7.163258e-01, 7.185523e-01,
+  7.207701e-01, 7.229794e-01, 7.251800e-01, 7.273721e-01,
+  7.295557e-01, 7.317307e-01, 7.338974e-01, 7.360555e-01,
+  7.382053e-01, 7.403467e-01, 7.424797e-01, 7.446045e-01,
+  7.467209e-01, 7.488291e-01, 7.509291e-01, 7.530208e-01,
+  7.551044e-01, 7.571798e-01, 7.592472e-01, 7.613064e-01,
+  7.633576e-01, 7.654008e-01, 7.674360e-01, 7.694633e-01,
+  7.714826e-01, 7.734940e-01, 7.754975e-01, 7.774932e-01,
+  7.794811e-01, 7.814612e-01, 7.834335e-01, 7.853983e-01,
+  7.853983e-01
+};
+
+/* -------------------------------------------------------------------------- */
+/** @brief Initialization of speed trigonometry 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+InitSPEEDTRIG(void) {
+  int i, SIZE;
+  TABLE_FACTOR = ONE_OVER_TWOPI * SIN_TABLE_SIZE;
+  SIZE = sizeof(REAL) * (SIN_TABLE_SIZE + 1);
+  sinT = (REAL *) safealloc(SIZE + (SIZE >> 2) + 1, 1, "InitSPEEDTRIG");
+  for (i = 0; i < SIN_TABLE_SIZE + (SIN_TABLE_SIZE >> 2) + 1; i++)
+    sinT[i] = sin((REAL) i * TWOPI / (REAL) SIN_TABLE_SIZE);
+  cosT = sinT + (SIN_TABLE_SIZE >> 2);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Fast sine 
+* 
+* @param x 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+fast_sin(REAL x) {
+#if (TRIG_SPEED==2)
+  x = (x * TABLE_FACTOR) + 0.5;
+  return sinT[((int) x) & (SIN_TABLE_SIZE_M1)];
+#else
+  int i, ip1;
+  REAL frac;
+  x = (x * TABLE_FACTOR);
+  i = (int) (frac = floor(x));
+  ip1 = i + 1;
+  frac = x - frac;
+  return (1.0 - frac) * sinT[i] + frac * sinT[ip1];
+#endif
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Fast cosine 
+* 
+* @param x 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+fast_cos(REAL x) {
+#if (TRIG_SPEED==2)
+  x = (x * TABLE_FACTOR) + 0.5;
+  return cosT[((int) x) & (SIN_TABLE_SIZE - 1)];
+#else
+  int i, ip1;
+  REAL frac;
+  x = (x * TABLE_FACTOR);
+  i = (int) (frac = floor(x));
+  ip1 = i + 1;
+  frac = x - frac;
+  return (1.0 - frac) * cosT[i] + frac * cosT[ip1];
+#endif
+}
+
+/** ***************************************************************************
+ Function:      Arc tangent
+
+ Syntax:        angle = fast_atan2(y, x);
+                    REAL   y       y component of input vector
+                    REAL   x       x component of input vector
+                    REAL   angle   angle of vector (x, y) in radians
+              
+ Description:   This function calculates the angle of the vector (x,y) based
+                on a table lookup and linear interpolation. The table uses
+                a 256 point table covering -45 to +45 degrees and uses
+                symetry to determine the final angle value in the range of
+                -180 to 180 degrees. Note that this function uses the small
+                angle approximation for values close to zero. This routine
+                calculates the arc tangent with an average  error of
+                +/- 0.045 degrees.
+**************************************************************************** */
+
+/* -------------------------------------------------------------------------- */
+/** @brief fast arc tangent 
+* 
+* @param y 
+* @param x 
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+fast_atan2(REAL y, REAL x) {
+  REAL x_abs, y_abs, z;
+  REAL alpha, angle, base_angle;
+  int index;
+
+  /* don't divide by zero! */
+  if ((y == 0.0) && (x == 0.0))
+    angle = 0.0;
+  else {
+    /* normalize to +/- 45 degree range */
+    y_abs = fabs(y);
+    x_abs = fabs(x);
+    //z = (y_abs < x_abs ? y_abs / x_abs : x_abs / y_abs);
+    if (y_abs < x_abs)
+      z = y_abs / x_abs;
+    else
+      z = x_abs / y_abs;
+    /* when ratio approaches the table resolution, the angle is */
+    /*      best approximated with the argument itself...       */
+    if (z < TAN_MAP_RES)
+      base_angle = z;
+    else {
+      /* find index and interpolation value */
+      alpha = z * (REAL) TAN_MAP_SIZE - .5;
+      index = (int) alpha;
+      alpha -= (REAL) index;
+      /* determine base angle based on quadrant and */
+      /* add or subtract table value from base angle based on quadrant */
+      base_angle = fast_atan_table[index];
+      base_angle +=
+	(fast_atan_table[index + 1] - fast_atan_table[index]) * alpha;
+    }
+
+    if (x_abs > y_abs) {	/* -45 -> 45 or 135 -> 225 */
+      if (x >= 0.0) {		/* -45 -> 45 */
+	if (y >= 0.0)
+	  angle = base_angle;	/* 0 -> 45, angle OK */
+	else
+	  angle = -base_angle;	/* -45 -> 0, angle = -angle */
+      } else {			/* 135 -> 180 or 180 -> -135 */
+	angle = 3.14159265358979323846;
+	if (y >= 0.0)
+	  angle -= base_angle;	/* 135 -> 180, angle = 180 - angle */
+	else
+	  angle = base_angle - angle;	/* 180 -> -135, angle = angle - 180 */
+      }
+    } else {			/* 45 -> 135 or -135 -> -45 */
+      if (y >= 0.0) {		/* 45 -> 135 */
+	angle = 1.57079632679489661923;
+	if (x >= 0.0)
+	  angle -= base_angle;	/* 45 -> 90, angle = 90 - angle */
+	else
+	  angle += base_angle;	/* 90 -> 135, angle = 90 + angle */
+      } else {			/* -135 -> -45 */
+	angle = -1.57079632679489661923;
+	if (x >= 0.0)
+	  angle += base_angle;	/* -90 -> -45, angle = -90 + angle */
+	else
+	  angle -= base_angle;	/* -135 -> -90, angle = -90 - angle */
+      }
+    }
+  }
+#ifdef ZERO_TO_TWOPI
+  if (angle < 0)
+    return (angle + TWOPI);
+  else
+    return (angle);
+#else
+  return (angle);
+#endif
+}
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/dttspagc.c
@@ -0,0 +1,269 @@
+/** 
+* @file dttspagc.c
+* @brief Functions to implement automatic gain control  
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <dttspagc.h>
+
+#ifdef min
+#undef min
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief min 
+* 
+* @param a 
+* @param b 
+*/
+/* ---------------------------------------------------------------------------- */
+static INLINE REAL
+min(REAL a, REAL b) { return a < b ? a : b; }
+
+#ifdef max
+#undef max
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief 
+* 
+* @param a 
+* @param b 
+*/
+/* ---------------------------------------------------------------------------- */
+static INLINE REAL
+max(REAL a, REAL b) { return a > b ? a : b; }
+
+/* -------------------------------------------------------------------------- */
+/** @brief DttSPAgc 
+* 
+* @param mode 
+* @param Vec 
+* @param BufSize 
+* @param Limit 
+* @param attack 
+* @param decay 
+* @param slope 
+* @param hangtime 
+* @param samprate 
+* @param MaxGain 
+* @param MinGain 
+* @param CurGain 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+DTTSPAGC
+newDttSPAgc(AGCMODE mode,
+	    COMPLEX *Vec,
+	    int BufSize,
+	    REAL Limit,
+	    REAL attack,
+	    REAL decay,
+	    REAL slope,
+	    REAL hangtime,
+	    REAL samprate,
+	    REAL MaxGain,
+	    REAL MinGain,
+	    REAL CurGain,
+	    char *tag) {
+  DTTSPAGC a;
+
+  a = (DTTSPAGC) safealloc(1, sizeof(dttspagc), tag);
+  a->mode = mode;
+
+  a->attack = (REAL) (1.0 - exp(-1000.0 / (attack * samprate)));
+  a->one_m_attack = (REAL) exp(-1000.0 / (attack * samprate));
+
+  a->decay = (REAL) (1.0 - exp(-1000.0 / (decay * samprate)));
+  a->one_m_decay = (REAL) exp(-1000.0 / (decay * samprate));
+
+  a->fastattack = (REAL) (1.0 - exp(-1000.0 / (0.2 * samprate)));
+  a->one_m_fastattack = (REAL) exp(-1000.0 / (0.2 * samprate));
+
+  a->fastdecay = (REAL) (1.0 - exp(-1000.0 / (3.0 * samprate)));
+  a->one_m_fastdecay = (REAL) exp(-1000.0 / (3.0 * samprate));
+
+  strcpy(a->tag, tag);
+  a->mask = 2 * BufSize;
+
+  a->hangindex = a->indx = 0;
+  a->hangtime = hangtime * 0.001;
+  a->hangthresh = 0.0;
+  a->sndx = (int) (samprate * attack * 0.003);
+  a->fastindx = FASTLEAD;
+  a->gain.fix = 10.0;
+
+  a->slope = slope;
+  a->gain.top = MaxGain;
+  a->hangthresh = a->gain.bottom = MinGain;
+  a->gain.fastnow = a->gain.old = a->gain.now = CurGain;
+
+  a->gain.limit = Limit;
+
+  a->buff = newCXB(BufSize, Vec, "agc in buffer");
+  a->circ = newvec_COMPLEX(a->mask, "circular agc buffer");
+  a->mask -= 1;
+
+  a->fasthang = 0;
+  a->fasthangtime = 48 * 0.001;
+  a->samprate = samprate;
+
+  return a;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief DttSPAgc 
+* 
+* @param a 
+* @param tick 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+DttSPAgc(DTTSPAGC a, int tick) {
+  int i,
+      hangtime = (int) (a->samprate * a->hangtime),
+      fasthangtime = (int) (a->samprate * a->fasthangtime);
+  REAL hangthresh;
+
+  if (a->hangthresh > 0)
+    hangthresh =
+      a->gain.top * a->hangthresh +
+      a->gain.bottom * (REAL) (1.0 - a->hangthresh);
+  else
+    hangthresh = 0.0;
+
+  if (a->mode == 0) {
+#ifdef __SSE3__
+    SSEScaleCOMPLEX(a->buff, a->buff, a->gain.fix, CXBhave(a->buff));
+#else
+    for (i = 0; i < CXBhave(a->buff); i++)
+      CXBdata(a->buff, i) = Cscl(CXBdata(a->buff, i), a->gain.fix);
+#endif
+    return;
+  }
+
+  for (i = 0; i < CXBhave(a->buff); i++) {
+    REAL tmp;
+
+    a->circ[a->indx] = CXBdata(a->buff, i);	/* Drop sample into circular buffer */
+    tmp = 1.1 * Cmag(a->circ[a->indx]);
+
+    if (tmp != 0.0)
+      tmp = a->gain.limit / tmp;	// if not zero sample, calculate gain
+    else
+      tmp = a->gain.now;	// update. If zero, then use old gain
+
+    if (tmp < hangthresh)
+      a->hangindex = hangtime;
+
+    if (tmp >= a->gain.now) {
+      a->gain.raw = a->one_m_decay * a->gain.now + a->decay * tmp;
+      if (a->hangindex++ > hangtime)
+	a->gain.now =
+	  a->one_m_decay * a->gain.now + a->decay * min(a->gain.top, tmp);
+    } else {
+      a->hangindex = 0;
+      a->gain.raw = a->one_m_attack * a->gain.now + a->attack * tmp;
+      a->gain.now =
+	a->one_m_attack * a->gain.now + a->attack * max(tmp, a->gain.bottom);
+    }
+
+    tmp = 1.2f * Cmag(a->circ[a->fastindx]);
+    if (tmp != 0.0)
+      tmp = a->gain.limit / tmp;
+    else
+      tmp = a->gain.fastnow;
+
+    if (tmp > a->gain.fastnow) {
+      if (a->fasthang++ > fasthangtime) {
+	a->gain.fastnow =
+	  min(a->one_m_fastdecay * a->gain.fastnow +
+	      a->fastdecay * min(a->gain.top, tmp), a->gain.top);
+      }
+    } else {
+      a->fasthang = 0;
+      a->gain.fastnow =
+	max(a->one_m_fastattack * a->gain.fastnow +
+	    a->fastattack * max(tmp, a->gain.bottom),
+	    a->gain.bottom);
+    }
+
+    a->gain.fastnow = max(min(a->gain.fastnow, a->gain.top), a->gain.bottom);
+    a->gain.now = max(min(a->gain.now, a->gain.top), a->gain.bottom);
+    CXBdata(a->buff, i) =
+      Cscl(a->circ[a->sndx], min(a->gain.fastnow,
+				 min(a->slope * a->gain.now, a->gain.top)));
+
+    a->indx = (a->indx + a->mask) & a->mask;
+    a->sndx = (a->sndx + a->mask) & a->mask;
+    a->fastindx = (a->fastindx + a->mask) & a->mask;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief delDttSPAgc 
+* 
+* @param a 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delDttSPAgc(DTTSPAGC a) {
+  if (a) {
+    delCXB(a->buff);
+    delvec_COMPLEX(a->circ);
+    safefree((char *) a);
+  }
+}
+
+#if 0
+gain = 1e-3;
+spoint = 1.0;
+for (;;) {
+  /* Voltage controlled amplifier is just a multiplier here */
+  yout = yin * iout;
+
+  /* error */
+  err = spoint - abs(yout);
+
+  /* Integrate */
+  iout1 = iout;
+  iout = iout1 + gain * err;
+}
+
+if (signal_too_big())
+  decrease_gain_quickly();
+else if (signal_below_threshold() && gain_not_too_high_already())
+  increase_gain_slowly();
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/wscompand.c
@@ -0,0 +1,152 @@
+/** 
+* @file wscompand.c
+* @brief Functions to control the WS compander 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+ waveshaping compander, mostly for speech
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <wscompand.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Lookup values in the WS compander 
+* 
+* @param wsc 
+* @param x 
+* @return REAL 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE INLINE REAL
+WSCLookup(WSCompander wsc, REAL x) {
+  if (x > 0.0) {
+    REAL d, xn, y, *tbl;
+    int end, i;
+    
+    xn = x * wsc->npts, i = xn, d = xn - i;
+    tbl = wsc->tbl, end = wsc->nend;
+    
+    if (i < end)
+      y = tbl[i] + d * (tbl[i + 1] - tbl[i]);
+    else
+      y = tbl[end];
+    return y / x;
+  } else
+    return 0.0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run the WS compander 
+* 
+* @param wsc 
+* @return void 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+WSCompand(WSCompander wsc) {
+  int i, n = CXBhave(wsc->buff);
+
+  for (i = 0; i < n; i++) {
+    COMPLEX val = CXBdata(wsc->buff, i);
+    REAL mag = Cmag(val), scl = WSCLookup(wsc, mag);
+    CXBdata(wsc->buff, i) = Cscl(val, scl);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the WS compander 
+* 
+* @param wsc 
+* @param fac 
+* @return void 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+WSCReset(WSCompander wsc, REAL fac) {
+  int i;
+  REAL *tbl = wsc->tbl;
+
+  if (fac == 0.0)		/// just linear
+    for (i = 0; i < wsc->npts; i++)
+      tbl[i] = i / (REAL) wsc->nend;
+
+  else {			/// exponential
+    REAL del = fac / wsc->nend, scl = 1.0 - exp(fac);
+    for (i = 0; i < wsc->npts; i++)
+      tbl[i] = (1.0 - exp(i * del)) / scl;
+  }
+  wsc->fac = fac;
+}
+
+/// fac < 0: compression
+/// fac > 0: expansion
+
+/* -------------------------------------------------------------------------- */
+/** @brief create a new WS Compander 
+* 
+* @param npts 
+* @param fac 
+* @param buff 
+* @return WSCompander 
+*/
+/* ---------------------------------------------------------------------------- */
+WSCompander
+newWSCompander(int npts, REAL fac, CXB buff) {
+  WSCompander wsc;
+
+  wsc = (WSCompander) safealloc(1,
+				sizeof(WSCompanderInfo),
+				"WSCompander struct");
+  wsc->npts = npts;
+  wsc->nend = npts - 1;
+  wsc->tbl = newvec_REAL(npts, "WSCompander table");
+  wsc->buff = newCXB(CXBsize(buff), CXBbase(buff), "WSCompander buff");
+  WSCReset(wsc, fac);
+  return wsc;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief destroy a WS compander 
+* 
+* @param wsc 
+* @return void 
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delWSCompander(WSCompander wsc) {
+  if (wsc) {
+    delvec_REAL(wsc->tbl);
+    delCXB(wsc->buff);
+    safefree((char *) wsc);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/lmadf.h
@@ -0,0 +1,129 @@
+/* lmadf.h 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _lmadf_h
+#define _lmadf_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <fftw3.h>
+
+#define LMADF_INTERFERENCE 0
+#define LMADF_NOISE 1
+#define LMADF_NOSIG (-1)
+#define LMADF_NOLINE (-2)
+#define LMADF_NOFILT (-3)
+
+extern int lmadf_err;
+
+#define REALLMS
+typedef struct _BlockLMS {
+  CXB signal;
+  COMPLEX *delay_line;
+  COMPLEX *y;
+  COMPLEX *Xhat;
+  COMPLEX *What;
+  COMPLEX *Y;
+  COMPLEX *Yhat;
+  COMPLEX *error;
+  COMPLEX *Errhat;
+  COMPLEX *Update;
+  COMPLEX *update;
+  REAL adaptation_rate;
+  REAL leak_rate;
+  int filter_type;
+  fftwf_plan Xplan, Yplan, Wplan, Errhatplan, UPDplan;
+} _blocklms, *BLMS;
+
+#ifdef REALLMS
+
+typedef struct _LMSR {
+  CXB signal;			/* Signal Buffer */
+  int signal_size;		/* Number of samples in signal buffer */
+  REAL *delay_line;		/* Delay Line circular buffer for holding samples */
+  REAL *adaptive_filter;	/* Filter coefficients */
+  REAL adaptation_rate;		/* Adaptation rate for the LMS stochastic gradient */
+  REAL leakage;			/* Exponential decay constant for filter coefficients */
+  int adaptive_filter_size;	/* number taps in adaptive filter */
+  int filter_type;		/* Filter type */
+  int delay;			/* Total delay between current sample and filter */
+  int delay_line_ptr;		/* Pointer for next sample into the delay line */
+  int size;			/* Delay line size */
+  int mask;			/* Mask for circular buffer */
+} *LMSR, _lmsstate;
+
+#else
+
+typedef struct _LMSR {
+  CXB signal;			/* Signal Buffer */
+  int signal_size;		/* Number of samples in signal buffer */
+  COMPLEX *delay_line;		/* Delay Line circular buffer for holding samples */
+  COMPLEX *adaptive_filter;	/* Filter coefficients */
+  REAL adaptation_rate;		/* Adaptation rate for the LMS stochastic gradient */
+  REAL leakage;			/* Exponential decay constant for filter coefficients */
+  int adaptive_filter_size;	/* number taps in adaptive filter */
+  int filter_type;		/* Filter type */
+  int delay;			/* Total delay between current sample and filter */
+  int delay_line_ptr;		/* Pointer for next sample into the delay line */
+  int size;			/* Delay line size */
+  int mask;			/* Mask for circular buffer */
+} *LMSR, _lmsstate;
+
+#endif
+
+extern LMSR new_lmsr(CXB signal,
+		     int ssize,
+		     int delay,
+		     REAL adaptation_rate,
+		     REAL leakage,
+		     int adaptive_filter_size,
+		     int filter_type);
+
+extern void del_lmsr(LMSR lms);
+
+extern void lmsr_adapt(LMSR lms);
+
+extern BLMS new_blms(CXB signal,
+		     REAL adaptation_rate,
+		     REAL leak_rate,
+		     int filter_type,
+		     int pbits);
+
+extern void blms_adapt(BLMS blms);
+
+extern void del_blms(BLMS blms);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/README
@@ -0,0 +1,8 @@
+This package is non-native. As it is created from a source repository, no 
+tarball archive of the sources exists. Therefore it is created withing
+this package.
+
+Obtaining the original sources
+==============================
+# ./debian/rules get-orig-source
+Then move the tarball to the parent directory.
--- /dev/null
+++ dttsp-0~svn675/ringb.c
@@ -0,0 +1,484 @@
+/** 
+* @file ringb.c
+* @brief ring buffer functions 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+  Derived from jack/ringbuffer.h
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 3 of the License, or
+    (at your option) any later version.
+    
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software 
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+    Original
+    Copyright (C) 2000 Paul Davis
+    Copyright (C) 2003 Rohan Drape
+
+    Derived
+    Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+    Doxygen comments added by Dave Larsen, KV0S
+*/
+
+#include <ringb.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a ring buffer 
+* 
+* @param sz2 
+* @return *ringb_t
+*/
+/* ---------------------------------------------------------------------------- */
+ringb_t *
+ringb_create(size_t sz2) {
+  ringb_t *rb = (ringb_t *) safealloc(1, sizeof(ringb_t), "Ring creation");
+  rb->buf = safealloc(1, sz2, "Ring buffer buf");
+  rb->size = sz2;		// power-of-2-sized
+  rb->mask = rb->size - 1;
+  rb->wptr = rb->rptr = 0;
+  return rb;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a float ring buffer 
+* 
+* @param sz2 
+* @return *ringb_float_t
+*/
+/* ---------------------------------------------------------------------------- */
+ringb_float_t *
+ringb_float_create(size_t sz2) {
+  ringb_float_t *rb = (ringb_float_t *) safealloc(1, sizeof(ringb_float_t),
+						  "Float Ring creation");
+  rb->buf =
+    (float *) safealloc(1, sz2 * sizeof(float), "Ring buffer float buf");
+  rb->size = sz2;		// power-of-2-sized
+  rb->mask = rb->size - 1;
+  rb->wptr = rb->rptr = 0;
+  return rb;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a usemem ring buffer 
+* 
+* @param usemem 
+* @param sz2 
+* @return *ringb_t
+*/
+/* ---------------------------------------------------------------------------- */
+ringb_t *
+ringb_create_usemem(char *usemem, size_t sz2) {
+  ringb_t *rb = (ringb_t *) usemem;
+  rb->buf = usemem + sizeof(ringb_t);
+  rb->size = sz2;		// power-of-2-sized
+  rb->mask = rb->size - 1;
+  rb->wptr = rb->rptr = 0;
+  return rb;
+}
+
+
+/* -------------------------------------------------------------------------- */
+/** @brief Free the ring buffer memory 
+* 
+* @param rb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_free(ringb_t *rb) {
+  safefree(rb->buf);
+  safefree((char *) rb);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Free the float ring buffor memory 
+* 
+* @param rb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_float_free(ringb_float_t *rb) {
+  safefree((void *) rb->buf);
+  safefree((char *) rb);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the ring buffer 
+* 
+* @param rb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_reset(ringb_t *rb) {
+  // NB not thread-safe
+  rb->rptr = 0;
+  rb->wptr = 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Reset the float ring buffer 
+* 
+* @param rb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_float_reset(ringb_float_t *rb) {
+  // NB not thread-safe
+  rb->rptr = 0;
+  rb->wptr = 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Clear the ring buffer 
+* 
+* @param rb 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_clear(ringb_t *rb, size_t nbytes) {
+  size_t i;
+  char zero = 0;
+  for (i = 0; i < nbytes; i++)
+    ringb_write(rb, &zero, 1);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Clear the float ring buffer 
+* 
+* @param rb 
+* @param nfloats 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_float_clear(ringb_float_t *rb, size_t nfloats) {
+  size_t i;
+  float zero = 0;
+  for (i = 0; i < nfloats; i++)
+    ringb_float_write(rb, &zero, 1);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Restart the ring buffer 
+* 
+* @param rb 
+* @param nbytes 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_restart(ringb_t *rb, size_t nbytes) {
+  ringb_reset(rb);
+  ringb_clear(rb, nbytes);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Restart the float ring buffer 
+* 
+* @param rb 
+* @param nfloats 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_float_restart(ringb_float_t *rb, size_t nfloats) {
+  ringb_float_reset(rb);
+  ringb_float_clear(rb, nfloats);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief  Read the ring buffer space 
+* 
+* @param rb 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_read_space(const ringb_t *rb) {
+  size_t w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    return w - r;
+  else
+    return (w - r + rb->size) & rb->mask;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read the float ring buffer space 
+* 
+* @param rb 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_float_read_space(const ringb_float_t *rb) {
+  size_t w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    return w - r;
+  else
+    return (w - r + rb->size) & rb->mask;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Write space ring buffer  
+* 
+* @param rb 
+* 
+* @return size_t 
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_write_space(const ringb_t *rb) {
+  size_t w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    return ((r - w + rb->size) & rb->mask) - 1;
+  else if (w < r)
+    return r - w - 1;
+  else
+    return rb->size - 1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Write space flaot ring buffer 
+* 
+* @param rb 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_float_write_space(const ringb_float_t *rb) {
+  size_t w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    return ((r - w + rb->size) & rb->mask) - 1;
+  else if (w < r)
+    return r - w - 1;
+  else
+    return rb->size - 1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read ring buffer 
+* 
+* @param rb 
+* @param dest 
+* @param cnt 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_read(ringb_t *rb, char *dest, size_t cnt) {
+  size_t free_cnt, cnt2, to_read, n1, n2;
+  if ((free_cnt = ringb_read_space(rb)) == 0)
+    return 0;
+  to_read = cnt > free_cnt ? free_cnt : cnt;
+  if ((cnt2 = rb->rptr + to_read) > rb->size)
+    n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
+  else
+    n1 = to_read, n2 = 0;
+  memcpy(dest, &(rb->buf[rb->rptr]), n1);
+  rb->rptr = (rb->rptr + n1) & rb->mask;
+  if (n2) {
+    memcpy(dest + n1, &(rb->buf[rb->rptr]), n2);
+    rb->rptr = (rb->rptr + n2) & rb->mask;
+  }
+  return to_read;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read a float ring buffer 
+* 
+* @param rb 
+* @param dest 
+* @param cnt 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_float_read(ringb_float_t *rb, float *dest, size_t cnt) {
+  size_t free_cnt, cnt2, to_read, n1, n2;
+  if ((free_cnt = ringb_float_read_space(rb)) == 0)
+    return 0;
+  to_read = cnt > free_cnt ? free_cnt : cnt;
+  if ((cnt2 = rb->rptr + to_read) > rb->size)
+    n1 = rb->size - rb->rptr, n2 = cnt2 & rb->mask;
+  else
+    n1 = to_read, n2 = 0;
+  memcpy(dest, &(rb->buf[rb->rptr]), n1 * sizeof(float));
+  rb->rptr = (rb->rptr + n1) & rb->mask;
+  if (n2) {
+    memcpy(dest + n1, &(rb->buf[rb->rptr]), n2 * sizeof(float));
+    rb->rptr = (rb->rptr + n2) & rb->mask;
+  }
+  return to_read;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Peek into a ring buffer 
+* 
+* @param rb 
+* @param dest 
+* @param cnt 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_peek(ringb_t *rb, char *dest, size_t cnt) {
+  size_t free_cnt, cnt2, to_read, n1, n2, tmp_rptr;
+  tmp_rptr = rb->rptr;
+  if ((free_cnt = ringb_read_space(rb)) == 0)
+    return 0;
+  to_read = cnt > free_cnt ? free_cnt : cnt;
+  if ((cnt2 = tmp_rptr + to_read) > rb->size)
+    n1 = rb->size - tmp_rptr, n2 = cnt2 & rb->mask;
+  else
+    n1 = to_read, n2 = 0;
+  memcpy(dest, &(rb->buf[tmp_rptr]), n1);
+  tmp_rptr = (tmp_rptr + n1) & rb->mask;
+  if (n2)
+    memcpy(dest + n1, &(rb->buf[tmp_rptr]), n2);
+  return to_read;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Write a ring buffer 
+* 
+* @param rb 
+* @param src 
+* @param cnt 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_write(ringb_t *rb, const char *src, size_t cnt) {
+  size_t free_cnt, cnt2, to_write, n1, n2;
+  if ((free_cnt = ringb_write_space(rb)) == 0)
+    return 0;
+  to_write = cnt > free_cnt ? free_cnt : cnt;
+  if ((cnt2 = rb->wptr + to_write) > rb->size)
+    n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
+  else
+    n1 = to_write, n2 = 0;
+  memcpy(&(rb->buf[rb->wptr]), src, n1);
+  rb->wptr = (rb->wptr + n1) & rb->mask;
+  if (n2) {
+    memcpy(&(rb->buf[rb->wptr]), src + n1, n2);
+    rb->wptr = (rb->wptr + n2) & rb->mask;
+  }
+  return to_write;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Write a float ring buffer 
+* 
+* @param rb 
+* @param src 
+* @param cnt 
+* @return size_t
+*/
+/* ---------------------------------------------------------------------------- */
+size_t
+ringb_float_write(ringb_float_t *rb, const float *src, size_t cnt) {
+  size_t free_cnt, cnt2, to_write, n1, n2;
+  if ((free_cnt = ringb_float_write_space(rb)) == 0)
+    return 0;
+  to_write = cnt > free_cnt ? free_cnt : cnt;
+  if ((cnt2 = rb->wptr + to_write) > rb->size)
+    n1 = rb->size - rb->wptr, n2 = cnt2 & rb->mask;
+  else
+    n1 = to_write, n2 = 0;
+  memcpy(&(rb->buf[rb->wptr]), src, n1 * sizeof(float));
+  rb->wptr = (rb->wptr + n1) & rb->mask;
+  if (n2) {
+    memcpy(&(rb->buf[rb->wptr]), src + n1, n2 * sizeof(float));
+    rb->wptr = (rb->wptr + n2) & rb->mask;
+  }
+  return to_write;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Read advanced ring buffer 
+* 
+* @param rb 
+* @param cnt 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_read_advance(ringb_t *rb, size_t cnt) {
+  rb->rptr = (rb->rptr + cnt) & rb->mask;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Write advanced ring buffer 
+* 
+* @param rb 
+* @param cnt 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_write_advance(ringb_t *rb, size_t cnt) {
+  rb->wptr = (rb->wptr + cnt) & rb->mask;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get the read vector of from the ring buffer
+* 
+* @param rb 
+* @param vec 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_get_read_vector(const ringb_t *rb, ringb_data_t *vec) {
+  size_t free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    free_cnt = w - r;
+  else
+    free_cnt = (w - r + rb->size) & rb->mask;
+  if ((cnt2 = r + free_cnt) > rb->size) {
+    vec[0].buf = &(rb->buf[r]), vec[0].len = rb->size - r;
+    vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
+  } else {
+    vec[0].buf = &(rb->buf[r]), vec[0].len = free_cnt;
+    vec[1].len = 0;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get the write vector ring buffer 
+* 
+* @param rb 
+* @param vec 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ringb_get_write_vector(const ringb_t *rb, ringb_data_t *vec) {
+  size_t free_cnt, cnt2, w = rb->wptr, r = rb->rptr;
+  if (w > r)
+    free_cnt = ((r - w + rb->size) & rb->mask) - 1;
+  else if (w < r)
+    free_cnt = r - w - 1;
+  else
+    free_cnt = rb->size - 1;
+  if ((cnt2 = w + free_cnt) > rb->size) {
+    vec[0].buf = &(rb->buf[w]), vec[0].len = rb->size - w;
+    vec[1].buf = rb->buf, vec[1].len = cnt2 & rb->mask;
+  } else {
+    vec[0].buf = &(rb->buf[w]), vec[0].len = free_cnt;
+    vec[1].len = 0;
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/speechproc.c
@@ -0,0 +1,117 @@
+/** 
+* @file speechproc.c
+* @brief Function to implement speech processing 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+   
+  This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Original design in Visual Basic for SDR by Phil Harman
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <speechproc.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new speech processor structure 
+* 
+* @param K 
+* @param MaxCompression 
+* @param spdat 
+* @param size 
+* @return SpeechProc
+*/
+/* ---------------------------------------------------------------------------- */
+SpeechProc
+newSpeechProc(REAL K, REAL MaxCompression, COMPLEX *spdat, int size) {
+  SpeechProc sp = (SpeechProc) safealloc(1, sizeof(speech_proc),
+					 "new speech processor");
+  sp->CG = newRLB(size + 1, NULL, "CG buffer in Speech Processor");
+  sp->K = K;
+  sp->MaxGain = pow(10.0, MaxCompression * 0.05);
+  sp->fac =
+    ((((0.0000401002 * MaxCompression) - 0.0032093390) * MaxCompression + 0.0612862687) * MaxCompression + 0.9759745718);
+  sp->LastCG = 1.0;
+  sp->SpeechProcessorBuffer = newCXB(size, spdat, "speech processor data");
+  sp->size = size;
+  return sp;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Delete speech processor structure and clean up 
+* 
+* @param sp 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delSpeechProc(SpeechProc sp) {
+  if (sp) {
+    delRLB(sp->CG);
+    delCXB(sp->SpeechProcessorBuffer);
+    safefree((char *) sp);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Speech processor function 
+* 
+* @param sp 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+SpeechProcessor(SpeechProc sp) {
+  int i;
+  REAL r = 0.0, Mag;
+
+  if (sp->MaxGain == 1.0)
+    return;
+  /// K was 0.4 in VB version, this value is better, perhaps due to filters that follow?
+  for (i = 0; i < sp->size; i++)
+    r = max(r, Cmag(CXBdata(sp->SpeechProcessorBuffer, i)));	// find the peak magnitude value in the sample buffer 
+
+  RLBdata(sp->CG, 0) = sp->LastCG;	// restore from last time
+  for (i = 1; i <= sp->size; i++) {
+    Mag = Cmag(CXBdata(sp->SpeechProcessorBuffer, i - 1));
+    if (Mag != 0.0) {
+      RLBdata(sp->CG, i) = RLBdata(sp->CG, i - 1) * (1 - sp->K) + (sp->K * r / Mag);	//  Frerking's formula
+      if (RLBdata(sp->CG, i) > sp->MaxGain)
+	RLBdata(sp->CG, i) = sp->MaxGain;
+    } else
+      RLBdata(sp->CG, i) = sp->MaxGain;
+  }
+  sp->LastCG = RLBdata(sp->CG, sp->size);	// save for next time 
+
+
+  for (i = 0; i < sp->size; i++)	// multiply each sample by its gain constant 
+    CXBdata(sp->SpeechProcessorBuffer, i) =
+      Cscl(CXBdata(sp->SpeechProcessorBuffer, i),
+	   (REAL) (RLBdata(sp->CG, i) / (sp->fac * pow(sp->MaxGain, 0.25))));
+}
--- /dev/null
+++ dttsp-0~svn675/THANKS
@@ -0,0 +1,4 @@
+
+  * Jonathan Marsden <jmarsden@fastmail.fm>
+	 Created a preliminary package of dttsp for ubuntu in 2010.
+	 Wrote man page for sdr-core.
--- /dev/null
+++ dttsp-0~svn675/splitfields.h
@@ -0,0 +1,56 @@
+/* splitfields.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _splitfields_h
+#define _splitfields_h
+
+#include <fromsys.h>
+#include <bufvec.h>
+#include <banal.h>
+
+#define MAXFLD 16384
+
+typedef struct _splitfld {
+  char *f[MAXFLD];
+  int n;
+} splitfld, *SPLIT;
+
+extern char *F(SPLIT, int);
+extern char **Fptr(SPLIT, int);
+extern int NF(SPLIT);
+
+extern int splitonto(SPLIT, char *, char *, char **, int);
+extern int spliton(SPLIT, char *, char *);
+extern void split(SPLIT, char *);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/oscillator.c
@@ -0,0 +1,161 @@
+/** 
+* @file oscillator.c
+* @brief Functions to implement the oscillator
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This routine implements a common fixed-frequency oscillator
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <oscillator.h>
+
+#define HUGE_PHASE 1256637061.43593
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a complex oscillator 
+* 
+* @param p 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+ComplexOSC(OSC p) {
+  int i;
+  COMPLEX z, delta_z;
+
+  if (OSCphase(p) > HUGE_PHASE)
+    OSCphase(p) -= HUGE_PHASE;
+
+  z = Cmplx((REAL) cos(OSCphase(p)), (IMAG) sin(OSCphase(p))),
+    delta_z = Cmplx((REAL) cos(OSCfreq(p)), (IMAG) sin(OSCfreq(p)));
+
+  for (i = 0; i < OSCsize(p); i++)
+    z = CXBdata((CXB) OSCbase(p), i) = Cmul(z, delta_z),
+    OSCphase(p) += OSCfreq(p);
+}
+
+#ifdef notdef
+void
+ComplexOSC(OSC p) {
+  int i;
+  if (OSCphase(p) > 1256637061.43593)
+    OSCphase(p) -= 1256637061.43593;
+  for (i = 0; i < OSCsize(p); i++) {
+    OSCreal(p, i) = cos(OSCphase(p));
+    OSCimag(p, i) = sin(OSCphase(p));
+    OSCphase(p) += OSCfreq(p);
+  }
+}
+#endif
+
+/* -------------------------------------------------------------------------- */
+/** @brief private _phasemod 
+* 
+* @param angle 
+* @return double
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE double
+_phasemod(double angle) {
+  while (angle >= TWOPI)
+    angle -= TWOPI;
+  while (angle < 0.0)
+    angle += TWOPI;
+  return angle;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a REAL oscillator 
+* 
+* @param p 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+RealOSC(OSC p) {
+  int i;
+  for (i = 0; i < OSCsize(p); i++) {
+    OSCRdata(p, i) = (REAL) sin(OSCphase(p));
+    OSCphase(p) = _phasemod(OSCfreq(p) + OSCphase(p));
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new oscillator 
+* 
+* @param size 
+* @param TypeOsc 
+* @param Frequency 
+* @param Phase 
+* @param SampleRate 
+* @param tag 
+* @return OSC
+*/
+/* ---------------------------------------------------------------------------- */
+OSC
+newOSC(int size,
+       OscType TypeOsc,
+       double Frequency,
+       double Phase,
+       REAL SampleRate,
+       char *tag) {
+  OSC p = (OSC) safealloc(1, sizeof(oscillator), tag);
+  if ((OSCtype(p) = TypeOsc) == ComplexTone)
+    OSCbase(p) = (void *) newCXB(size,
+				 NULL,
+				 "complex buffer for oscillator output");
+  else
+    OSCbase(p) = (void *) newRLB(size,
+				 NULL, "real buffer for oscillator output");
+  OSCsize(p) = size;
+  OSCfreq(p) = 2.0 * M_PI * Frequency / SampleRate;
+  OSCphase(p) = Phase;
+  return p;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a oscillator 
+* 
+* @param p 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delOSC(OSC p) {
+  if (p->OscillatorType == ComplexTone)
+    delCXB((CXB) p->signalpoints);
+  else
+    delRLB((RLB) p->signalpoints);
+  if (p)
+    safefree((char *) p);
+}
--- /dev/null
+++ dttsp-0~svn675/resample.c
@@ -0,0 +1,162 @@
+/** 
+* @file resample.c
+* @brief Resampling functions 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <resample.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief New Polyphase FIR filter
+* 
+* @param source 
+* @param insize 
+* @param dest 
+* @param iold 
+* @param intrp 
+* @param phase 
+* @param decim 
+* @return ResSt
+*/
+/* ---------------------------------------------------------------------------- */
+ResSt
+newPolyPhaseFIR(CXB source,
+		int insize,
+		CXB dest,
+		int iold,
+		int intrp,
+		int phase,
+		int decim) {
+  ResSt r = (ResSt) safealloc(1, sizeof(resampler), "PF Resampler");
+
+  r->iold  = iold;
+  r->intrp = intrp;
+  r->phase = phase;
+  r->decim = decim;
+  r->nflt  = 31 * decim;
+  r->nold  = nblock2(r->nflt);
+  r->mask  = r->nold - 1;
+  r->inp   = CXBbase(source);
+  r->nnew  = insize;
+  r->out   = CXBbase(dest);
+  r->old   = (COMPLEX *) safealloc(r->nold, sizeof(COMPLEX), "resampler past");
+  r->filt  = newFIR_Lowpass_REAL(0.45f / (REAL) decim, (REAL) intrp, r->nflt);
+
+  return r;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a Polypahse FIR filter 
+* 
+* @param r 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delPolyPhaseFIR(ResSt r) {
+  if (r)
+    delFIR_Lowpass_REAL(r->filt),
+    safefree((char *) r->old),
+    safefree((char *) r);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief PolyPhase FIR filter 
+* 
+* @param r 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+PolyPhaseFIR(ResSt r) {
+  int i, n = 0;
+
+  for (i = 0; i < r->nnew; i++) {
+
+    r->old[r->iold] = r->inp[i];
+
+    while (r->phase < r->intrp) {
+      COMPLEX sum = cxzero;
+      int j = r->iold, k;
+
+      for (k = r->phase; k < r->nflt; k += r->intrp) {
+	sum = Cadd(sum, Cscl(r->old[j], FIRtap(r->filt, k)));
+	j = (j + r->mask) & r->mask;
+      }
+
+      r->out[n] = Cscl(sum, (REAL) r->intrp);
+      r->phase += r->decim;
+      n++;
+    }
+
+    r->iold = (r->iold + 1) & r->mask;
+    r->phase -= r->intrp;
+  }
+
+  r->nout = n;
+}
+
+/** 
+* *inp              pointer to inp COMPLEX data array
+* *out              pointer to out COMPLEX data array
+* filt              pointer to filt coefficients array
+* *old              pointer to buffer used as filt memory. Initialized
+*                   all data to 0 before 1st call.  length is calculated
+*                   from nflt
+* nold              length of old
+* nnew              length of inp array :note that "out" may differ in length
+* nflt              number of filt taps in array "filtcoeff": < nold
+* iold              index to where next inp sample is to be stored in
+*                   "old",initalized 0 to before first call
+* intrp             interpolation factor: out rate = inp rate * interp / decim.
+* phase             filt phase number (index), initialized to 0
+* decim             decimation factor:
+*                   out rate = (inp rate * interp/decim)
+* nout              number of out samples placed in array "out"
+*
+* DESCRIPTION: This function is used to change the sampling rate of the data.
+*              The inp is first upsampled to a multiple of the desired
+*              sampling rate and then down sampled to the desired sampling rate.
+*
+*              Ex. If we desire a 7200 Hz sampling rate for a signal that has
+*                  been sampled at 8000 Hz the signal can first be upsampled
+*                  by a factor of 9 which brings it up to 72000 Hz and then
+*                  down sampled by a factor of 10 which results in a sampling
+*                  rate of 7200 Hz.
+*
+* NOTES:
+*        Also, the "*old" MUST be 2^N REALs long. This
+*        routine uses circular addressing on this buffer assuming that
+*        it is 2^N REALs in length.
+*/
--- /dev/null
+++ dttsp-0~svn675/spectrum.h
@@ -0,0 +1,88 @@
+/* spectrum.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _spectrum_h
+#define _spectrum_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <ringb.h>
+#include <lmadf.h>
+#include <fftw3.h>
+#include <window.h>
+
+#define SPEC_MAG	(0)
+#define SPEC_PWR	(1)
+#define SPEC_SEMI_RAW	(0)
+#define SPEC_PRE_FILT	(1)
+#define SPEC_POST_FILT	(2)
+#define SPEC_POST_AGC	(3)
+#define SPEC_POST_DET	(4)
+#define SPEC_PREMOD	(4)
+#define SPEC_LAST_TIME	(0)
+#define SPEC_LAST_FREQ	(1)  
+
+
+typedef
+struct _spec_block {
+  BOOLEAN flag, polyphase;
+  Windowtype wintype;
+  int buflen,
+      fill,
+      label,
+      last,
+      mask,
+      planbits,
+      rxk,
+      scale,
+      size,
+      stamp,
+      type;
+  CXB accum, timebuf, freqbuf;
+  REAL *output, *oscope, *window;
+  fftwf_plan plan;
+} SpecBlock;
+
+extern void init_spectrum(SpecBlock *sb);
+extern void reinit_spectrum(SpecBlock *sb);
+extern void snap_spectrum(SpecBlock *sb, int label, int stamp);
+extern void snap_scope(SpecBlock *sb, int label, int stamp);
+extern void compute_spectrum(SpecBlock *sb);
+extern void finish_spectrum(SpecBlock *sb);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/fromsys.h
@@ -0,0 +1,74 @@
+/* fromsys.h
+   stuff we need to import everywhere 
+ This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _fromsys_h
+#define _fromsys_h
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/wait.h>  
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  
+#include <signal.h>
+#include <time.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <math.h>
+#include <getopt.h>
+
+#include <jack/jack.h>
+#include <jack/ringbuffer.h>
+
+#include <gsl/gsl_errno.h>
+#include <gsl/gsl_wavelet.h>  
+
+#ifndef M_PI
+#define M_PI 3.14159265358928
+#endif
+
+#include <assert.h>
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN (2048)
+#endif
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/update.h
@@ -0,0 +1,46 @@
+/* update.h
+
+common defs and code for parm update
+   
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006,2007 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _update_h
+#define _update_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <datatypes.h>
+#include <thunk.h>
+
+extern int do_update(char *str, FILE *log);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/halfband.h
@@ -0,0 +1,123 @@
+// halfband.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+or
+
+The DTTS Microwave Society
+3125 Capilano Crescent #201
+North Vancouver, BC V7R 4X5
+Canada
+*/			   
+
+#ifndef _halfband_h
+#define _halfband_h
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/wait.h>  
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  
+#include <signal.h>
+#include <time.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <math.h>
+#include <getopt.h>
+#include <assert.h>
+
+#ifndef M_PI
+#define M_PI 3.14159265358928
+#endif
+
+#include <datatypes.h>
+#include <complex.h>
+#include <bufvec.h>			   
+			   
+//==================================================================
+
+typedef
+struct hb_ap {
+  REAL c, x[3], y[3];
+} hb_ap_t;
+
+typedef
+struct hb_ap_casc {
+  int numf;
+  hb_ap_t **apf;
+} hb_ap_casc_t;
+
+typedef
+struct hb_filt {
+  hb_ap_casc_t *a, *b;
+  REAL old;
+} hb_filt_t;
+
+REAL hb_ap_proc(hb_ap_t *, REAL);
+hb_ap_t *new_hb_ap(REAL coefficient);
+void del_hb_ap(hb_ap_t *);
+
+REAL hb_ap_casc_proc(hb_ap_casc_t *, REAL);
+hb_ap_casc_t *new_hb_ap_casc(REAL *, int);
+void del_hp_ap_casc(hb_ap_casc_t *);
+
+REAL hb_filt_proc(hb_filt_t *, REAL);
+hb_filt_t *new_hb_filt(int, int);
+void del_hb_filt(hb_filt_t *);
+
+//==================================================================
+
+typedef
+struct _half_band {
+  struct {
+    struct {
+      hb_filt_t *re, *im;
+    } gen;
+  } filt;
+  struct {
+    CXB i, o;
+  } buf;
+} HalfBandInfo, *HalfBander;
+
+extern void HalfBandit(HalfBander h);
+extern HalfBander newHalfBander(int ord, BOOLEAN steep, CXB ibuf, CXB obuf);
+extern void delHalfBander(HalfBander h);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/rtone.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python
+# rtone rate dur Hz dB file
+
+import sys
+import wave
+import math as M
+import numpy as N
+
+if len(sys.argv) <> 6:
+    print >>sys.stderr, "usage:"
+    print >>sys.stderr, "rtone.py rate dur freq dB file"
+    sys.exit(1)
+
+rate = float(sys.argv[1])
+dur  = float(sys.argv[2])
+Hz   = float(sys.argv[3])
+dB   = float(sys.argv[4])
+name = sys.argv[5]
+
+fp = wave.open(name, 'wb')
+
+nchannels = 1
+sampwidth = 2
+framerate = int(rate)
+nframes   = int(rate*dur+0.5)
+comptype  = "NONE"
+compname  = "NONE"
+
+fp.setparams((nchannels,
+              sampwidth,
+              framerate,
+              nframes,
+              comptype,
+              compname))
+
+twopi = 2.0*M.pi
+nbuf  = 1024
+scl   = 32768*(10.0**(float(dB)/20.0))
+phs   = 0.0
+inc   = twopi*Hz/rate
+
+while nframes > 0:
+    num = min(nbuf, nframes)
+    buf = N.zeros(num)
+    for i in range(num):
+        buf[i] = M.cos(phs)*scl
+        phs += inc
+    fp.writeframes(buf.clip(-32768,32767.999).astype(N.int16).tostring())
+    while phs >= +twopi: phs -= twopi
+    while phs <= -twopi: phs += twopi
+    nframes -= num
+
+fp.close()
--- /dev/null
+++ dttsp-0~svn675/ztone2.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+# ztone2 rate dur Hz_A dB_A Hz_B dB_B file
+
+import sys
+import wave
+import math as M
+import numpy as N
+
+if len(sys.argv) <> 8:
+    print >>sys.stderr, "usage:"
+    print >>sys.stderr, "ztone2.py rate dur A dB_A B dB_B file"
+    sys.exit(1)
+
+rate = float(sys.argv[1])
+dur  = float(sys.argv[2])
+Hz_A = float(sys.argv[3])
+dB_A = float(sys.argv[4])
+Hz_B = float(sys.argv[5])
+dB_B = float(sys.argv[6])
+name = sys.argv[7]
+
+fp = wave.open(name, 'wb')
+
+nchannels = 2
+sampwidth = 2
+framerate = int(rate)
+nframes   = int(rate*dur+0.5)
+comptype  = "NONE"
+compname  = "NONE"
+
+fp.setparams((nchannels,
+              sampwidth,
+              framerate,
+              nframes,
+              comptype,
+              compname))
+
+twopi = 2.0*M.pi
+nbuf  = 1024
+
+scl_A = 32768*(10.0**(float(dB_A)/20.0))
+phs_A = 0.0
+inc_A = twopi*Hz_A/rate
+
+scl_B = 32768*(10.0**(float(dB_B)/20.0))
+phs_B = 0.0
+inc_B = twopi*Hz_B/rate
+
+while nframes > 0:
+    num = min(nbuf, nframes)
+    buf = N.zeros((num,2))
+
+    for i in range(num):
+
+        buf[i][0]  = M.cos(phs_A)*scl_A
+        buf[i][1]  = M.sin(phs_A)*scl_A
+        buf[i][0] += M.cos(phs_B)*scl_B
+        buf[i][1] += M.sin(phs_B)*scl_B
+
+        phs_A += inc_A
+        phs_B += inc_B
+
+    fp.writeframes(buf.clip(-32768,32767.999).astype(N.int16).tostring())
+
+    while phs_A >= +twopi: phs_A -= twopi
+    while phs_A <= -twopi: phs_A += twopi
+    while phs_B >= +twopi: phs_B -= twopi
+    while phs_B <= -twopi: phs_B += twopi
+
+    nframes -= num
+
+fp.close()
--- /dev/null
+++ dttsp-0~svn675/ztone.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+# ztone rate dur Hz dB file
+
+import sys
+import wave
+import math as M
+import numpy as N
+
+if len(sys.argv) <> 6:
+    print >>sys.stderr, "usage:"
+    print >>sys.stderr, "ztone.py rate dur freq dB file"
+    sys.exit(1)
+
+rate = float(sys.argv[1])
+dur  = float(sys.argv[2])
+Hz   = float(sys.argv[3])
+dB   = float(sys.argv[4])
+name = sys.argv[5]
+
+fp = wave.open(name, 'wb')
+
+nchannels = 2
+sampwidth = 2
+framerate = int(rate)
+nframes   = int(rate*dur+0.5)
+comptype  = "NONE"
+compname  = "NONE"
+
+fp.setparams((nchannels,
+              sampwidth,
+              framerate,
+              nframes,
+              comptype,
+              compname))
+
+twopi = 2.0*M.pi
+nbuf  = 1024
+scl   = 32768*(10.0**(float(dB)/20.0))
+phs   = 0.0
+inc   = twopi*Hz/rate
+
+while nframes > 0:
+    num = min(nbuf, nframes)
+    buf = N.zeros((num,2))
+    for i in range(num):
+        buf[i][0] = M.cos(phs)*scl
+        buf[i][1] = M.sin(phs)*scl
+        phs += inc
+    fp.writeframes(buf.clip(-32768,32767.999).astype(N.int16).tostring())
+    while phs >= +twopi: phs -= twopi
+    while phs <= -twopi: phs += twopi
+    nframes -= num
+
+fp.close()
--- /dev/null
+++ dttsp-0~svn675/spottone.h
@@ -0,0 +1,78 @@
+/* spottone.h */
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _spottone_h
+#define _spottone_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <oscillator.h>
+
+#define SpotTone_IDLE (0)
+#define SpotTone_WAIT (1)
+#define SpotTone_RISE (2)
+#define SpotTone_STDY (3)
+#define SpotTone_FALL (4)
+#define SpotTone_HOLD (5)
+
+typedef struct _spot_tone_gen {
+  REAL curr, gain, mul, scl, sr;
+  struct {
+    REAL freq;
+    OSC gen;
+  } osc;
+  struct {
+    REAL dur, incr;
+    int want, have;
+  } rise, fall;
+  int size, stage;
+  CXB buf;
+} SpotToneGenDesc, *SpotToneGen;
+
+extern SpotToneGen newSpotToneGen(REAL gain,	// dB
+				  REAL freq,	// Hz
+				  REAL rise,	// msec
+				  REAL fall,	// msec
+				  int size,	// buflen
+				  REAL samplerate);
+extern void delSpotToneGen(SpotToneGen gen);
+extern void setSpotToneGenVals(SpotToneGen gen,
+			       REAL gain, REAL freq, REAL rise, REAL fall);
+extern void SpotToneOn(SpotToneGen gen);
+extern void SpotToneOff(SpotToneGen gen);
+extern BOOLEAN SpotTone(SpotToneGen gen);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/stkstuff.h
@@ -0,0 +1,110 @@
+// stkstuff.h
+// DSP algorithms inspired by Stk. From-scratch in C.
+// GPL v3
+
+#ifndef _stkstuff_h
+#define _stkstuff_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+typedef struct _stk_filter {
+  REAL gain;
+  struct { RLB g, b, a, x, y; } fil;
+} STKFiltInfo, *STKFilt;
+
+extern STKFilt newSTKFilt(REAL *b, int nb, REAL *a, int na);
+extern void delSTKFilt(STKFilt f);
+extern void STKFilt_clear(STKFIlt f);
+extern void STKFilt_set_coeffs(STKFilt f,
+			       REAL *b, int nb, REAL *a, int na,
+			       BOOLEAN clearstate);
+extern void STKFilt_set_numerator(STKFilt f,
+				  REAL *b, int nb,
+				  BOOLEAN clearstate);
+extern void STKFilt_set_denominator(STKFilt f,
+				    REAL *a, int na,
+				    BOOLEAN clearstate);
+extern void STKFilt_set_gain(STKFilt f, REAL gain);
+extern REAL STKFilt_get_gain(STKFilt f);
+extern REAL STKFilt_last_out(STKFilt f);
+extern REAL STKFilt_tick(STKFilt f, REAL input);
+
+typedef struct _stk_delay {
+  REAL gain;
+  struct { RLB g, b, a, x, y; } fil;
+  struct { int i, o, t; } del;
+} STKDelayInfo, *STKDelay;
+
+extern STKDelay newSTKDelay(int delay, int max_delay);
+extern void delSTKDelay(STKDelay d);
+extern void STKDelay_clear(STKDelay d);
+extern void STKDelay_set_delay(STKDelay d, int delay);
+extern int  STKDelay_get_delay(STKDelay d);
+extern void STKDelay_set_max_delay(STKDelay d, int max_delay);
+extern int  STKDelay_get_max_delay(STKDelay d);
+extern REAL STKDelay_energy(STKDelay d);
+extern REAL STKDelay_contents_at(STKDelay d, int tap);
+extern REAL STKDelay_last_out(STKDelay d);
+extern REAL STKDelay_next_out(STKDelay d);
+extern REAL STKDelay_compute_sample(STKDelay d, REAL input);
+extern REAL STKDelay_tick(STKDelay d, REAL input);
+
+typedef struct _stk_delay_a {
+  REAL gain;
+  struct { RLB g, b, a, x, y; } fil;
+  struct {
+    struct { int i, o; } pt;
+    REAL t;
+    struct {
+      REAL alpha, coeff, ap_input, next_output;
+      BOOLEAN do_next_out;
+    } A;
+  } del;
+} STKDelayAInfo, *STKDelayA;
+
+extern STKDelayA newSTKDelayA(REAL delay, int max_delay);
+extern void delSTKDelayA(STKDelayA d);
+extern void STKDelayA_clear(STKDelayA d);
+extern void STKDelayA_set_delay(STKDelayA d, REAL delay);
+extern REAL STKDelayA_get_delay(STKDelayA d);
+extern void STKDelayA_set_max_delay(STKDelayA d, int max_delay);
+extern REAL STKDelayA_get_max_delay(STKDelayA d);
+extern REAL STKDelayA_energy(STKDelayA d);
+extern REAL STKDelayA_contents_at(STKDelayA d, int tap_delay);
+extern REAL STKDelayA_last_out(STKDelayA d);
+extern REAL STKDelayA_next_out(STKDelayA d);
+extern REAL STKDelayA_compute_sample(STKDelayA d, REAL input);
+extern REAL STKDelayA_tick(STKDelayA d, REAL input);
+
+typedef struct _stk_delay_l {
+  REAL gain;
+  struct { RLB b, a, x, y; } fil;
+  struct {
+    struct { int i, o; } pt;
+    REAL t;
+  } del;
+  struct {
+    REAL alpha, om_alpha, next_output;
+    BOOLEAN do_next_out;
+  } delL;
+} STKDelayLInfo, *STKDelayL;
+
+extern STKDelayL newSTKDelayL(int delay, int max_delay);
+extern void delSTKDelayL(STKDelayL d);
+extern void STKDelayL_clear(STKDelayL d);
+extern void STKDelayL_set_delay(STKDelayL d, int delay);
+extern REAL STKDelayL_get_delay(STKDelayL d);
+extern void STKDelayL_set_max_delay(STKDelayL d, int max_delay);
+extern REAL STKDelayL_get_max_delay(STKDelayL d);
+extern REAL STKDelayL_energy(STKDelayL d);
+extern REAL STKDelayL_contents_at(STKDelayL d, int tap_delay);
+extern REAL STKDelayL_last_out(STKDelayL d);
+extern REAL STKDelayL_next_out(STKDelayL d);
+extern REAL STKDelayL_compute_sample(STKDelayL d, REAL input);
+extern REAL STKDelayL_tick(STKDelayL d, REAL input);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/oscillator.h
@@ -0,0 +1,77 @@
+/* oscillator.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _oscillator_h
+#define _oscillator_h
+
+#include <fromsys.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+#define ComplexTone 1
+#define RealTone 0
+
+typedef int OscType;
+
+typedef struct _oscillator {
+  int size;
+  void *signalpoints;
+  double Phase;
+  double Frequency;
+  OscType OscillatorType;
+} oscillator, *OSC;
+
+
+#define OSCbase(p)     ((p)->signalpoints)
+#define OSCCbase(p)    (CXBbase((CXB)((p)->signalpoints)))
+#define OSCCdata(p, i) (CXBbase((CXB)((p)->signalpoints))[(i)])
+#define OSCreal(p, i)  (CXBbase((CXB)((p)->signalpoints))[(i)].re)
+#define OSCimag(p, i)  (CXBbase((CXB)((p)->signalpoints))[(i)].im)
+
+#define OSCRbase(p)    (RLBbase((RLB)((p)->signalpoints)))
+#define OSCRdata(p, i) (RLBbase((RLB)((p)->signalpoints))[(i)])
+
+#define OSCsize(p)     ((p)->size)
+#define OSCphase(p)    ((p)->Phase)
+#define OSCfreq(p)     ((p)->Frequency)
+#define OSCtype(p)     ((p)->OscillatorType)
+
+extern void ComplexOSC(OSC);
+extern void RealOSC(OSC);
+extern OSC newOSC(int size, OscType TypeOsc, double Frequency,
+		  double Phase, REAL SampleRate, char *tag);
+extern void delOSC(OSC);
+extern void fixOSC(OSC p, double Frequency, double Phase, REAL SampleRate);
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/stkstuff.c
@@ -0,0 +1,488 @@
+/** 
+* @file stkstuff.c
+* @brief DSP algorithms inspired by Stk. From-scratch in C.
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY  
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+*/
+
+#include <stkstuff.h>
+
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief  Create a new STK Filter structure 
+* 
+* @param b 
+* @param nb 
+* @param a 
+* @param na 
+* @return STKFilt
+*/
+/* ---------------------------------------------------------------------------- */
+STKFilt
+newSTKFilt(REAL *b, int nb, REAL *a, int na) {
+  STKFilt f = (STKFilt) safealloc(1, sizeof(STKFiltInfo), "STKFiltInfo");
+  f->fil.g = 1.0;
+  f->fil.b = newRLB(nb, 0, "STKFiltInfo fil.b");
+  memcpy((char *) RLBbase(f->fil.b), (char *) b, nb * sizeof(REAL));
+  f->fil.a = newRLB(na, 0, "STKFiltInfo fil.a");
+  memcpy((char *) RLBbase(f->fil.a), (char *) a, na * sizeof(REAL));
+  f->fil.x = newRLB(nb, 0, "STKFiltInfo fil.x");
+  f->fil.y = newRLB(na, 0, "STKFiltInfo fil.y");
+  return f;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a STK Filter structure 
+* 
+* @param f -- the STK structure  
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delSTKFilt(STKFilt f) {
+  if (f) {
+    delRLB(f->fil.b);
+    delRLB(f->fil.a);
+    delRLB(f->fil.x);
+    delRLB(f->fil.y);
+    safefree((char *) f);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Clear the STK filter structure 
+* 
+* @param f 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKFilt_clear(STKFilt f) {
+  memset((char *) RLBbase(f->fil.x), 0, RLBsize(f->fil.x) * sizeof(REAL));
+  memset((char *) RLBbase(f->fil.y), 0, RLBsize(f->fil.y) * sizeof(REAL));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the filter coefficients in a STK filter structure 
+* 
+* @param f -- stk filter structure 
+* @param b 
+* @param nb 
+* @param a 
+* @param na 
+* @param clearstate 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKFilt_set_coeffs(STKFilt f,
+		   REAL *b, int nb, REAL *a, int na,
+		   BOOLEAN clearstate) {
+  if (nb != RLBsize(f->fil.b)) {
+    delRLB(f->fil.b);
+    f->fil.b = newRLB(nb, 0, "STKFiltInfo fil.b");
+    memcpy((char *) RLBbase(f->fil.b), (char *) b, nb * sizeof(REAL));
+  }
+  if (clearstate)
+    memset((char *) RLBbase(f->fil.x), 0, RLBsize(f->fil.x) * sizeof(REAL));
+
+  if (na != RLBsize(f->fil.a)) {
+    delRLB(f->fil.a);
+    f->fil.a = newRLB(na, 0, "STKFiltInfo fil.a");
+    memcpy((char *) RLBbase(f->fil.a), (char *) a, na * sizeof(REAL));
+  }
+  if (clearstate)
+    memset((char *) RLBbase(f->fil.y), 0, RLBsize(f->fil.y) * sizeof(REAL));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the numerator in a STK filter structure
+* 
+* @param f 
+* @param b 
+* @param nb 
+* @param clearstate 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKFilt_set_numerator(STKFilt f,
+		      REAL *b, int nb,
+		      BOOLEAN clearstate) {
+  if (nb != RLBsize(f->fil.b)) {
+    delRLB(f->fil.b);
+    f->fil.b = newRLB(nb, 0, "STKFiltInfo fil.b");
+    memcpy((char *) RLBbase(f->fil.b), (char *) b, nb * sizeof(REAL));
+  }
+  if (clearstate)
+    memset((char *) RLBbase(f->fil.x), 0, RLBsize(f->fil.x) * sizeof(REAL));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the demoniator in a STK filter structure
+* 
+* @param f 
+* @param a 
+* @param na 
+* @param clearstate 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKFilt_set_denominator(STKFilt f,
+			REAL *a, int na,
+			BOOLEAN clearstate) {
+  if (na != RLBsize(f->fil.a)) {
+    delRLB(f->fil.a);
+    f->fil.a = newRLB(na, 0, "STKFiltInfo fil.a");
+    memcpy((char *) RLBbase(f->fil.a), (char *) a, na * sizeof(REAL));
+  }
+  if (clearstate)
+    memset((char *) RLBbase(f->fil.y), 0, RLBsize(f->fil.y) * sizeof(REAL));
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief set the STK Filter gain 
+* 
+* @param f 
+* @param gain 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKFilt_set_gain(STKFilt f, REAL gain) {
+  f->fil.g = gain;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief get the STK Filter gain 
+* 
+* @param f 
+* @param gain 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKFilt_get_gain(STKFilt f, REAL gain) {
+  return f->fil.g;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief get the last value out of the STK Filter 
+* 
+* @param f 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKFilt_last_out(STKFilt f) {
+  return f->fil.y[0];
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief set tick in STK Filter structure 
+* 
+* @param f 
+* @param input 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKFilt_tick(STKFilt f, REAL input) {
+  REAL
+    g  = f->fil.g,
+    *b = RLBbase(f->fil.b),
+    *a = RLBbase(f->fil.a),
+    *x = RLBbase(f->fil.x),
+    *y = RLBbase(f->fil.y);
+  int
+    nb = RLBsize(f->fil.b),
+    na = RLBsize(f->fil.a),
+    i;
+
+  y[0] = 0.0, x[0] = g * input;
+  
+  for (i = nb - 1; i > 0; --i)
+    y[0] += b[i] * x[i], x[i] = x[i - 1];
+  
+  y[0] += b[0] * x[0];
+
+  for (i = n1 - 1; i > 0; --i)
+    y[0] += -a[i] * y[i], y[i] = y[i - 1];
+
+  return y[0];
+}
+
+//==================================================================
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new STK structure delay 
+* 
+* This "works" but it's a scruffy basic design.
+* Contortions imposed by stretching the Filter
+*   to cover the interpolating Delay Line cases...
+* Another software engineering victory for C++.
+* Fix this eventually. Yeah, right.
+*
+* @param delay 
+* @param max_delay 
+* @return STKDelay
+*/
+/* ---------------------------------------------------------------------------- */
+STKDelay
+newSTKDelay(int delay, int max_delay) {
+  STKDelay d = (STKDelay) safealloc(1, sizeof(STKDelayInfo), "STKDelayInfo");
+  d->fil.x = newRLB(max_delay + 1, 0, "STKDelayInfo fil.x");
+  d->fil.y = newRLB(1, 0, "STKDelayInfo fil.y");
+  d->del.t = delay;
+  return d;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy the STK structure delay 
+* 
+* @param d 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+delSTKDelay(STKDelay d) {
+  if (d) {
+    delRLB(d->fil.x);
+    delRLB(d->fil.y);
+    // d->fil.? otherwise untouched. Slick, huh?
+    safefree((char *) d);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Clear the STK structure delay 
+* 
+* @param d 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKDelay_clear(STKDelay d) {
+  memset((char *) RLBbase(d->fil.x), 0, RLBsize(d->fil.x) * sizeof(REAL));
+  RLBdata(d->fil.y, 0) = 0.0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the STK structure delay 
+* 
+* @param d 
+* @param delay 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKDelay_set_delay(STKDelay d, int delay) {
+  if (delay >= RLBsize(d->fil.x)) {
+    if ((d->del.o = d->del.i + 1) == RLBsize(d->fil.x))
+      d->del.o = 0;
+    d->del.t = RLBsize(d->fil.x);
+  } else if (delay < 0) {
+    d->del.o = d->del.i;
+    d->del.t = 0;
+  } else {
+    if (d->del.i >= delay)
+      d->del.o = d->del.i - delay;
+    else
+      d->del.o = RLBsize(d->fil.x) + d->del.i - delay;
+    d->del.t = delay;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get the STK structure delay delay  
+* 
+* @param d 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+STKDelay_get_delay(STKDelay d) {
+  return d->del.t;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Set the STK structure delay maximum delay 
+* 
+* @param d 
+* @param max_delay 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+STKDelay_set_max_delay(STKDelay d, int max_delay) {
+  if ((d->del.t < max_delay) || (max_delay >= RLBsize(d->fil.x))) {
+    RLB r = newRLB(max_delay + 1, 0, "STKDelay alter max");
+    memcpy((char *) RLBbase(r),
+	   (char *) RLBbase(d->fil.x),
+	   min(RLBsize(r), RLBsize(d->fil.x)) * sizeof(REAL));
+    delRLB(d->fil.x);
+    d->fil.x = r;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get the STK structure delay maximum delay 
+* 
+* @param d 
+* @return int
+*/
+/* ---------------------------------------------------------------------------- */
+int
+STKDelay_get_max_delay(STKDelay d) {
+  return RLBsize(d->fil.x) - 1;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Calucalte the STK structure delay energy  
+* 
+* @param d 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_energy(STKDelay d) {
+  REAL e = 0.0;
+  int i;
+  if (d->del.i >= d->del.o) {
+    for (i = d->del.o; i < d->del.i; i++)
+      e += RLBdata(d->fil.x, i) * RLBdata(d->fil.x, i);
+  } else {
+    for (i = d->del.o; i < inputs_.size(); i++)
+      e += RLBdata(d->fil.x, i) * RLBdata(d->fil.x, i);
+    for (i = 0; i < d->del.i; i++)
+      e += RLBdata(d->fil.x, i) * RLBdata(d->fil.x, i);
+  }
+  return e;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Get the STK structure delay for contents a at tap
+* 
+* @param d 
+* @param tap 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_contents_at(STKDelay d, int tap) {
+  if (0 < tap && tap <= d->del.t) {
+    if ((tap = d->del.i - tap) < 0)
+      tap += RLBsize(d->fil.x);
+    return RLBdata(d->fil.x, tap);
+  } else
+    return 0.0;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Return the last value out of STK structure delay
+* 
+* @param d 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_last_out(STKDelay d){
+  return RLBdata(d->fil.y, 0);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Return the nexxt value out of a STK structure delay 
+* 
+* @param d 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_next_out(STKDelay d) {
+  return RLBdata(d->fil.x, d->del.o);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Compute a sample from a STK structure delay 
+* 
+* @param d 
+* @param input 
+* @return REALyy
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_compute_sample(STKDelay d, REAL input) {
+  RLBdata(d->fil.x, d->del.i) = input;
+  if (++d->del.i >= RLBsize(d->fil.x)) d->del.i = 0;
+
+  RLBdata(d->fil.y, 0) = RLBdata(d->fil.x, d->del.o);
+  if (++d->del.o >= RLBsize(d->fil.x)) d->del.o = 0;
+
+  return RLBdata(d->fil.y, 0);
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Return the sample from the STK structure delay based on d and input 
+* 
+* @param d 
+* @param input 
+* @return REAL
+*/
+/* ---------------------------------------------------------------------------- */
+REAL
+STKDelay_tick(STKDelay d, REAL input) {
+  return STKDelay_compute_sample(d, input);
+}
+
+//------------------------------------------------------------------
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new STK structure delay 
+* 
+* @param delay 
+* @param max_delay 
+* @return STKDelay
+*/
+/* ---------------------------------------------------------------------------- */
+STKDelay
+newSTKDelayA(REAL delay, int max_delay) {
+  STKDelayA d = (STKDelayA) safealloc(1, sizeof(STKDelayAInfo), "STKDelayAInfo");
+  d->fil.x = newRLB(max_delay + 1, 0, "STKDelayAInfo fil.x");
+  d->fil.y = newRLB(1, 0, "STKDelayAInfo fil.y");
+  d->del.t = delay;
+  d->del.A.do_next_out = TRUE;
+  return d;
+}
+
--- /dev/null
+++ dttsp-0~svn675/resample.h
@@ -0,0 +1,69 @@
+/* resample.h
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _resample_h
+#define _resample_h
+
+#include <fromsys.h>
+#include <banal.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+#include <filter.h>
+#include <fftw3.h>
+
+typedef
+struct resample_state {
+  COMPLEX *inp, *out, *old;
+  RealFIR filt;
+  int nold,
+      nnew,
+      nout,
+      nflt,
+      iold,
+      intrp,
+      phase,
+      decim,
+      mask;
+} resampler, *ResSt;
+
+extern ResSt newPolyPhaseFIR(CXB source,
+			     int insize,
+			     CXB dest,
+			     int iold,
+			     int intrp,
+			     int phsf,
+			     int decim);
+extern void PolyPhaseFIR(ResSt r);
+extern void delPolyPhaseFIR(ResSt r);
+#endif
--- /dev/null
+++ dttsp-0~svn675/config.guess
@@ -0,0 +1,1502 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+#   Free Software Foundation, Inc.
+
+timestamp='2009-12-30'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Originally written by Per Bothner.  Please send patches (context
+# diff format) to <config-patches@gnu.org> and include a ChangeLog
+# entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
+Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep -q __ELF__
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux${UNAME_RELEASE}
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	eval $set_cc_for_build
+	SUN_ARCH="i386"
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH="x86_64"
+	    fi
+	fi
+	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[456])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    *:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    *:Interix*:*)
+    	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    authenticamd | genuineintel | EM64T)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	else
+	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
+	LIBC=gnu
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=${UNAME_MACHINE}el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=${UNAME_MACHINE}
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
+    padre:Linux:*:*)
+	echo sparc-unknown-linux-gnu
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    xtensa*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
+        exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	echo i586-pc-haiku
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    i386)
+		eval $set_cc_for_build
+		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		      grep IS_64BIT_ARCH >/dev/null
+		  then
+		      UNAME_PROCESSOR="x86_64"
+		  fi
+		fi ;;
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    c34*)
+	echo c34-convex-bsd
+	exit ;;
+    c38*)
+	echo c38-convex-bsd
+	exit ;;
+    c4*)
+	echo c4-convex-bsd
+	exit ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+and
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
--- /dev/null
+++ dttsp-0~svn675/noiseblanker.c
@@ -0,0 +1,115 @@
+/** 
+* @file noiseblanker.c
+* @brief Functions to implement a noise blanker
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <noiseblanker.h>
+
+/* -------------------------------------------------------------------------- */
+/** @brief Create a new noise blanker
+* 
+* @param sigbuf 
+* @param threshold 
+* @return NB
+*/
+/* ---------------------------------------------------------------------------- */
+NB
+new_noiseblanker(CXB sigbuf, REAL threshold) {
+  NB nb = (NB) safealloc(1, sizeof(nbstate), "new nbstate");
+  nb->sigbuf = sigbuf;
+  nb->threshold = threshold;
+  nb->average_mag = 1.0;
+  nb->hangtime = 0;
+  nb->sigindex = 0;
+  nb->delayindex = 2;
+  memset(nb->delay, 0, 8 * sizeof(COMPLEX));
+  return nb;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Destroy a noise blanker 
+* 
+* @param logical if nb exists 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+del_nb(NB nb) { if (nb) safefree((char *) nb); }
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run a noise blanker 
+* 
+* @param nb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+noiseblanker(NB nb) {
+  int i;
+  for (i = 0; i < CXBhave(nb->sigbuf); i++) {
+    REAL cmag = Cmag(CXBdata(nb->sigbuf, i));
+    nb->delay[nb->sigindex] = CXBdata(nb->sigbuf, i);
+    nb->average_mag = (REAL) (0.999 * (nb->average_mag) + 0.001 * cmag);
+    if ((nb->hangtime == 0) && (cmag > (nb->threshold * nb->average_mag)))
+      nb->hangtime = 7;
+    if (nb->hangtime > 0) {
+      CXBdata(nb->sigbuf, i) = Cmplx(0.0, 0.0);
+      nb->hangtime--;
+    } else
+      CXBdata(nb->sigbuf, i) = nb->delay[nb->delayindex];
+    nb->sigindex = (nb->sigindex + 7) & 7;
+    nb->delayindex = (nb->delayindex + 7) & 7;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Run SDR OM noise blanker 
+* 
+* @param nb 
+* @return void
+*/
+/* ---------------------------------------------------------------------------- */
+void
+SDROMnoiseblanker(NB nb) {
+  int i;
+  for (i = 0; i < CXBhave(nb->sigbuf); i++) {
+    REAL cmag = Cmag(CXBdata(nb->sigbuf, i));
+    nb->average_sig = Cadd(Cscl(nb->average_sig, 0.75),
+			   Cscl(CXBdata(nb->sigbuf, i), 0.25));
+    nb->average_mag = 0.999 * nb->average_mag + 0.001 * cmag;
+    if (cmag > nb->threshold * nb->average_mag)
+      CXBdata(nb->sigbuf, i) = nb->average_sig;
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/am_demod.c
@@ -0,0 +1,210 @@
+/** 
+* @file am_demod.c
+* @brief Functions to perform AM demodulation 
+* @author Frank Brickle, AB2KT and Bob McGwier, N4HY 
+
+
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+Doxygen comments added by Dave Larsen, KV0S
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#include <am_demod.h>
+
+/*------------------------------------------------------------------------------*/
+/* private to AM */
+/*------------------------------------------------------------------------------*/
+
+/* -------------------------------------------------------------------------- */
+/** 
+ * @brief Initialize a phased lock loop
+* 
+* @param am 
+* @param samprate 
+* @param freq 
+* @param lofreq 
+* @param hifreq 
+* @param bandwidth 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+init_pll(AMD am,
+	 REAL samprate,
+	 REAL freq,
+	 REAL lofreq,
+	 REAL hifreq,
+	 REAL bandwidth) {
+  REAL fac = (REAL) (TWOPI / samprate);
+  am->pll.freq.f = freq * fac;
+  am->pll.freq.l = lofreq * fac;
+  am->pll.freq.h = hifreq * fac;
+  am->pll.phs = 0.0;
+  am->pll.delay = cxJ;
+
+  am->pll.iir.alpha = bandwidth * fac;	/* arm filter */
+  am->pll.alpha = am->pll.iir.alpha * 0.3f;	/* pll bandwidth */
+  am->pll.beta = am->pll.alpha * am->pll.alpha * 0.25f;	/* second order term */
+  am->pll.fast_alpha = am->pll.alpha;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief run phased lock loop 
+* 
+* @param am 
+* @param sig 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE void
+pll(AMD am, COMPLEX sig) {
+  COMPLEX z = Cmplx((REAL) cos(am->pll.phs), (REAL) sin(am->pll.phs));
+  REAL diff;
+
+  am->pll.delay.re = z.re * sig.re + z.im * sig.im;
+  am->pll.delay.im = -z.im * sig.re + z.re * sig.im;
+  diff = Cmag(sig) * ATAN2(am->pll.delay.im, am->pll.delay.re);
+
+  am->pll.freq.f += am->pll.beta * diff;
+
+  if (am->pll.freq.f < am->pll.freq.l)
+    am->pll.freq.f = am->pll.freq.l;
+  if (am->pll.freq.f > am->pll.freq.h)
+    am->pll.freq.f = am->pll.freq.h;
+
+  am->pll.phs += am->pll.freq.f + am->pll.alpha * diff;
+
+  while (am->pll.phs >= TWOPI)
+    am->pll.phs -= (REAL) TWOPI;
+  while (am->pll.phs < 0)
+    am->pll.phs += (REAL) TWOPI;
+}
+
+/* -------------------------------------------------------------------------- */
+/** @brief Demodulate signal
+* 
+* @param am 
+*/
+/* ---------------------------------------------------------------------------- */
+PRIVATE REAL
+dem(AMD am) {
+  am->lock.curr = 0.999 * am->lock.curr + 0.001 * fabs(am->pll.delay.im);
+  am->lock.prev = am->lock.curr;
+  am->dc = 0.9999f * am->dc + 0.0001f * am->pll.delay.re;
+  return am->pll.delay.re - am->dc;
+}
+
+/*-----------------------------------------------------------------------------*/
+/* public */ 
+/*------------------------------------------------------------------------------*/
+
+void
+/* -------------------------------------------------------------------------- */
+/** @brief AM Demodulation
+* 
+* @param am 
+*/
+/* ---------------------------------------------------------------------------- */
+AMDemod(AMD am) {
+  int i;
+  REAL demout;
+  switch (am->mode) {
+  case SAMdet:
+    for (i = 0; i < am->size; i++) {
+      pll(am, CXBdata(am->ibuf, i));
+      demout = dem(am);
+      CXBdata(am->obuf, i) = Cmplx(demout, demout);
+    }
+    break;
+  case AMdet:
+    for (i = 0; i < am->size; i++) {
+      am->lock.curr = Cmag(CXBdata(am->ibuf, i));
+      am->dc = 0.9999f * am->dc + 0.0001f * am->lock.curr;
+      am->smooth = 0.5f * am->smooth + 0.5f * (am->lock.curr - am->dc);
+      /* demout = am->smooth; */
+      CXBdata(am->obuf, i) = Cmplx(am->smooth, am->smooth);
+    }
+    break;
+  }
+}
+
+AMD
+/* -------------------------------------------------------------------------- */
+/** @brief New AM demodulation object
+* 
+* @param samprate 
+* @param f_initial 
+* @param f_lobound 
+* @param f_hibound 
+* @param f_bandwid 
+* @param size 
+* @param ivec 
+* @param ovec 
+* @param mode 
+* @param tag 
+*/
+/* ---------------------------------------------------------------------------- */
+newAMD(REAL samprate,
+       REAL f_initial,
+       REAL f_lobound,
+       REAL f_hibound,
+       REAL f_bandwid,
+       int size,
+       COMPLEX *ivec,
+       COMPLEX *ovec,
+       AMMode mode,
+       char *tag) {
+  AMD am = (AMD) safealloc(1, sizeof(AMDDesc), tag);
+
+  am->size = size;
+  am->ibuf = newCXB(size, ivec, tag);
+  am->obuf = newCXB(size, ovec, tag);
+  am->mode = mode;
+  init_pll(am, samprate, f_initial, f_lobound, f_hibound, f_bandwid);
+
+  am->lock.curr = 0.5;
+  am->lock.prev = 1.0;
+  am->dc = 0.0;
+
+  return am;
+}
+
+void
+/* -------------------------------------------------------------------------- */
+/** @brief delete an AM Demodulation object
+* 
+* @param am 
+*/
+/* ---------------------------------------------------------------------------- */
+delAMD(AMD am) {
+  if (am) {
+    delCXB(am->ibuf);
+    delCXB(am->obuf);
+    safefree((char *) am);
+  }
+}
--- /dev/null
+++ dttsp-0~svn675/delay.h
@@ -0,0 +1,84 @@
+// delay.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+
+or
+
+The DTTS Microwave Society
+3125 Capilano Crescent #201
+North Vancouver, BC V7R 4X5
+Canada
+*/			   
+
+#ifndef _delay_h
+#define _delay_h
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/wait.h>  
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  
+#include <signal.h>
+#include <time.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <math.h>
+#include <getopt.h>
+#include <assert.h>
+
+#ifndef M_PI
+#define M_PI 3.14159265358928
+#endif
+
+#include <datatypes.h>
+#include <complex.h>
+#include <bufvec.h>			   
+
+typedef
+struct _delay_line {
+  struct {
+    int i, o;
+  } point;
+  int delay;
+} DelayLineInfo, *DelayLine;
+
+
+
+#endif
--- /dev/null
+++ dttsp-0~svn675/dcblock.h
@@ -0,0 +1,55 @@
+// dcblock.h
+/*
+This file is part of a program that implements a Software-Defined Radio.
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+The authors can be reached by email at
+
+ab2kt@arrl.net
+or
+rwmcgwier@gmail.com
+
+or by paper mail at
+
+The DTTS Microwave Society
+6 Kathleen Place
+Bridgewater, NJ 08807
+*/
+
+#ifndef _dcblock_h
+#define _dcblock_h
+
+#include <fromsys.h>
+#include <defs.h>
+#include <banal.h>
+#include <splitfields.h>
+#include <datatypes.h>
+#include <bufvec.h>
+#include <cxops.h>
+
+typedef struct _dcblocker {
+  CXB buf;
+  REAL xm1, ym1;
+} DCBlockerInfo, *DCBlocker;
+
+extern void DCBlock(DCBlocker dcb);
+extern void resetDCBlocker(DCBlocker dcb);
+extern DCBlocker newDCBlocker(CXB buf);
+extern void delDCBlocker(DCBlocker dcb);
+
+#endif
